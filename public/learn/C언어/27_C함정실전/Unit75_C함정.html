<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unit 75. C언어 함정·트릭 총정리 — C 언어</title>
    <link rel="stylesheet" href="../common.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>Unit 75. C언어 함정·트릭 총정리</h1>
            <div class="sub">UB · 형변환 함정 · 포인터 위험 · 버퍼 오버플로 · 코딩 스타일</div>
            <span class="unit-badge">Chapter 27 · C함정·실전</span>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span></div>
            <div class="meta"><span class="tag pri">⚠️ 함정</span><span class="tag acc">📝 15문제</span><span class="tag">⏱
                    45분</span></div>
        </div>
        <div class="stu-bar"><label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label><label>📅 날짜 <input
                    type="date" id="stu-date"></label></div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p><button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg"><a href="../26_DP그래프/Unit74_그래프.html">← Unit 74</a><span class="tag active">Unit 75</span><a
                href="Unit76_멀티파일.html">Unit 76 →</a></div>
        <div class="ft">⚠️ C언어 함정 총정리 · Unit 75</div>
    </div>
    <script>
        const P = [
            {
                n: 1, t: "정의되지 않은 동작 (UB) Top 5", d: 2,
                q: `아래 코드들은 모두 UB입니다. 왜 그런지 설명하세요.
<pre class="code-c">(A) int a=1; a = a++ + ++a;
(B) int *p = NULL; *p = 5;
(C) int a[3]; a[5] = 10;
(D) int a=INT_MAX; a = a+1;
(E) int a=5; a = a/0;</pre>`,
                a: `<span class="key">정답</span><pre class="code-c">(A) 같은 변수를 시퀀스 포인트 없이 2번 변경
    → <span class="err">UB!</span> 결과 예측 불가

(B) NULL 포인터 역참조
    → <span class="err">세그폴트!</span>

(C) 배열 범위 초과 (out-of-bounds)
    → 메모리 오염, 크래시 가능

(D) 부호 있는 정수 오버플로
    → UB (unsigned는 wrapping되지만 signed는 UB)

(E) 0으로 나누기
    → UB, 대부분 프로그램 종료</pre><div class="trace"><span class="err">UB = 컴파일러가 뭘 해도 합법!</span><br>디버깅 불가, 보안 취약점 원인<br>"작동하니까 OK" ✕ → 표준 확인!</div>`},

            {
                n: 2, t: "= vs == 실수", d: 1,
                q: `아래 코드의 문제를 찾으세요.
<pre class="code-c">int x = 5;
if (x = 3) {
    printf("같다!\\n");
}
printf("x = %d\\n", x);</pre>`,
                a: `<span class="key">정답</span><pre class="code-c"><span class="err">// x = 3 은 대입! (== 이어야 비교)</span>
<span class="cm">// x에 3이 대입되고, 3은 참이므로</span>
출력: 같다!
x = 3

<span class="cm">// 방어적 코딩: 상수를 왼쪽에!</span>
if (3 == x) { ... } <span class="cm">// 실수하면 컴파일 에러</span></pre>`},

            {
                n: 3, t: "sizeof 함정", d: 2,
                q: `아래 sizeof 결과를 쓰세요.
<pre class="code-c">char a[] = "Hello";
char *b = "Hello";
int c[10];
printf("%lu\\n", sizeof(a));
printf("%lu\\n", sizeof(b));
printf("%lu\\n", sizeof(c));

void func(int arr[]) {
    printf("%lu\\n", sizeof(arr)); <span class="cm">// ?!</span>
}</pre>`,
                a: `<span class="key">정답</span><div class="output-box">6<br>8<br>40<br>8</div><div class="trace">sizeof(a) = 6 (Hello + \\0 = 6바이트)<br>sizeof(b) = 8 (<span class="err">포인터 크기!</span> 64bit)<br>sizeof(c) = 40 (int×10 = 4×10)<br><br><span class="err">함수에 전달된 배열 = 포인터로 붕괴!</span><br>sizeof(arr) = 포인터 크기 = 8</div>`
            },

            {
                n: 4, t: "signed/unsigned 비교 함정", d: 3,
                q: `아래 코드의 출력을 예측하세요.
<pre class="code-c">int a = -1;
unsigned int b = 1;
if (a < b)
    printf("a가 작다\\n");
else
    printf("a가 크다\\n");
printf("a=%u\\n", (unsigned)a);</pre>`,
                a: `<span class="key">정답</span><div class="output-box">a가 크다<br>a=4294967295</div><div class="trace"><span class="err">-1 vs 1u 비교</span><br>signed를 unsigned로 자동 변환!<br>-1 → 4294967295 (UINT_MAX)<br>4294967295 > 1 → "a가 크다"<br><br>⚠️ signed와 unsigned 절대 섞지 말것!</div>`
            },

            {
                n: 5, t: "문자열 리터럴 수정 함정", d: 2,
                q: `아래 코드의 문제점을 설명하세요.
<pre class="code-c">char *s1 = "Hello";
char s2[] = "Hello";
s1[0] = 'h'; <span class="cm">// ?</span>
s2[0] = 'h'; <span class="cm">// ?</span></pre>`,
                a: `<span class="key">정답</span><pre class="code-c">char *s1 = "Hello";  <span class="cm">// 읽기 전용 메모리!</span>
s1[0] = 'h';          <span class="err">// 💣 세그폴트 or UB!</span>

char s2[] = "Hello";  <span class="cm">// 스택에 복사본!</span>
s2[0] = 'h';          <span class="cm">// ✅ OK!</span></pre><div class="trace">문자열 리터럴 "Hello"는 .rodata 영역<br>포인터 → 읽기 전용 원본 가리킴<br>배열 → 스택에 복사 → 수정 가능</div>`},

            {
                n: 6, t: "dangling pointer / double free", d: 2,
                q: `각 코드의 위험성을 설명하세요.
<pre class="code-c"><span class="cm">// (A) Dangling pointer</span>
int *p = (int*)malloc(sizeof(int));
free(p);
*p = 42; <span class="cm">// ?</span>

<span class="cm">// (B) Double free</span>
int *q = (int*)malloc(sizeof(int));
free(q);
free(q); <span class="cm">// ?</span>

<span class="cm">// (C) Memory leak</span>
void leak() {
    int *r = (int*)malloc(100);
    return; <span class="cm">// ?</span>
}</pre>`,
                a: `<span class="key">정답</span><pre class="code-c">(A) <span class="err">Use-After-Free!</span>
    해제된 메모리 접근 → UB, 보안 취약점
    대응: free 후 p = NULL;

(B) <span class="err">Double Free!</span>
    힙 메타데이터 파괴 → 크래시/보안 취약
    대응: free 후 q = NULL; (NULL free는 안전)

(C) <span class="err">Memory Leak!</span>
    malloc한 것을 free 안 함
    오래 실행되면 메모리 고갈</pre>`},

            {
                n: 7, t: "매크로 부작용 함정", d: 2,
                q: `아래 코드의 문제를 찾으세요.
<pre class="code-c">#define MAX(a,b) ((a)>(b)?(a):(b))
int x=3, y=5;
int z = MAX(x++, y++);
printf("x=%d y=%d z=%d", x, y, z);</pre>`,
                a: `<span class="key">정답</span><pre class="code-c"><span class="cm">// MAX(x++, y++) 전개:</span>
<span class="cm">// ((x++)>(y++)?(x++):(y++))</span>
<span class="cm">// 3>5? No → y++ (두 번째)</span>
<span class="cm">// x++한번, y++두번 실행!</span>

<span class="err">// 결과: x=4, y=7, z=6</span>
<span class="cm">// y가 2번 증가! (의도치 않은 부작용)</span>

<span class="cm">// 해결: inline 함수 사용!</span>
static inline int max(int a, int b) {
    return a > b ? a : b;
}</pre>`},

            {
                n: 8, t: "switch fallthrough 함정", d: 1,
                q: `아래 switch의 출력을 쓰세요.
<pre class="code-c">int x = 2;
switch(x) {
    case 1: printf("하나 ");
    case 2: printf("둘 ");
    case 3: printf("셋 ");
    default: printf("기타 ");
}</pre>`,
                a: `<span class="key">정답</span><div class="output-box">둘 셋 기타 </div><div class="trace"><span class="err">break 없으면 다음 case로 떨어짐!</span><br>case 2 → "둘" → case 3 → "셋" → default → "기타"<br><br>// 올바른 코드:<br>case 2: printf("둘"); break;</div>`
            },

            {
                n: 9, t: "gets() 보안 취약점", d: 2,
                q: `gets()가 위험한 이유와 대안을 설명하세요.
<pre class="code-c">char buf[10];
gets(buf); <span class="cm">// 사용자가 20글자 입력하면?</span></pre>`,
                a: `<span class="key">정답</span><pre class="code-c"><span class="err">// gets()는 버퍼 크기 확인 안 함!</span>
<span class="cm">// 20글자 입력 → 10바이트 넘어 스택 파괴</span>
<span class="cm">// → 버퍼 오버플로 공격 가능!</span>

<span class="cm">// C11에서 gets() 완전 제거됨!</span>

<span class="cm">// 안전한 대안:</span>
fgets(buf, sizeof(buf), stdin); <span class="cm">// 크기 제한!</span>

<span class="cm">// 줄바꿈 제거:</span>
buf[strcspn(buf, "\\n")] = '\\0';</pre><div class="trace">gets → fgets 교체 = C 보안 필수!<br>scanf("%s") 도 같은 위험! → scanf("%9s") 사용</div>`},

            {
                n: 10, t: "정수 승격 (Integer Promotion)", d: 3,
                q: `아래 코드의 출력을 예측하세요.
<pre class="code-c">char a = 0xFF;
unsigned char b = 0xFF;
printf("%d %d\\n", a, b);
printf("%d\\n", sizeof('A'));
printf("%d\\n", sizeof(1.0f + 'A'));</pre>`,
                a: `<span class="key">정답</span><div class="output-box">-1 255<br>4<br>4</div><div class="trace">char 0xFF = signed → -1 (부호 확장)<br>unsigned char 0xFF = 255<br><br>sizeof('A') = 4! (C에서 char 리터럴은 int!)<br>C++에서는 sizeof('A') = 1<br><br>1.0f + 'A' → float + int → float → 4</div>`
            },

            {
                n: 11, t: "쉼표 연산자 함정", d: 2,
                q: `쉼표 연산자의 결과를 예측하세요.
<pre class="code-c">int a = (1, 2, 3);
printf("%d\\n", a);
int b = 1, 2, 3; <span class="cm">// 이건?</span>
for (int i=0, j=10; i<j; i++, j--)
    printf("%d-%d ", i, j);</pre>`,
                a: `<span class="key">정답</span><pre class="code-c">a = 3 <span class="cm">// 쉼표 연산자: 마지막 값!</span>
<span class="cm">(1,2,3) → 1 평가, 2 평가, 3 반환</span>

int b = 1, 2, 3; <span class="err">// 컴파일 에러!</span>
<span class="cm">// 이 쉼표는 변수 선언 구분자</span>

<span class="cm">// for문에서 유용:</span>
0-10 1-9 2-8 3-7 4-6</pre>`},

            {
                n: 12, t: "volatile 키워드", d: 2,
                q: `volatile의 용도와 효과를 설명하세요.
<pre class="code-c">volatile int flag = 0;
<span class="cm">// 왜 필요한가?</span></pre>`,
                a: `<span class="key">정답</span><pre class="code-c"><span class="cm">// volatile: 컴파일러 최적화 방지!</span>
volatile int flag = 0;

<span class="cm">// 없으면 컴파일러가 이 루프를 제거할 수 있음:</span>
while (flag == 0) { } <span class="cm">// 무한 대기</span>

<span class="cm">// 사용처:</span>
<span class="cm">// 1. 하드웨어 레지스터 (임베디드)</span>
<span class="cm">// 2. 인터럽트 서비스 루틴 (ISR)</span>
<span class="cm">// 3. 시그널 핸들러</span>
<span class="cm">// 4. 멀티스레드 (단, mutex도 필요!)</span></pre>`},

            {
                n: 13, t: "배열과 포인터 혼동", d: 2,
                q: `배열과 포인터의 차이를 코드로 보여주세요.
<pre class="code-c">int a[5] = {1,2,3,4,5};
int *p = a;
<span class="cm">// 같은 점과 다른 점?</span></pre>`,
                a: `<span class="key">정답</span><pre class="code-c"><span class="cm">// 같은 점:</span>
a[i] == p[i] == *(a+i) == *(p+i) <span class="cm">// 접근 동일</span>

<span class="cm">// 다른 점:</span>
sizeof(a) = 20  <span class="cm">// 배열 전체 크기</span>
sizeof(p) = 8   <span class="cm">// 포인터 크기</span>

&a → int(*)[5]  <span class="cm">// 배열 포인터 (배열 전체)</span>
&p → int**      <span class="cm">// 포인터의 포인터</span>

a = p; <span class="err">// 불가! 배열은 대입 불가</span>
p = a; <span class="cm">// OK! 배열→포인터 붕괴</span>

a++; <span class="err">// 불가! 배열은 상수</span>
p++; <span class="cm">// OK!</span></pre>`},

            {
                n: 14, t: "숨겨진 메모리 정렬 (Struct Padding)", d: 3,
                q: `구조체 크기를 예측하세요.
<pre class="code-c">struct A { char a; int b; char c; };
struct B { int b; char a; char c; };
struct C { char a; char c; int b; };
printf("%lu %lu %lu", sizeof(struct A),
       sizeof(struct B), sizeof(struct C));</pre>`,
                a: `<span class="key">정답</span><div class="output-box">12 8 8</div><div class="trace">struct A: [a(1)+패딩(3)][b(4)][c(1)+패딩(3)] = 12<br>struct B: [b(4)][a(1)c(1)+패딩(2)] = 8<br>struct C: [a(1)c(1)+패딩(2)][b(4)] = 8<br><br><span class="val">멤버 순서가 크기를 바꿈!</span><br>큰 것부터 배치 → 패딩 최소화</div>`
            },

            {
                n: 15, t: "🏆 안전한 C 코딩 체크리스트", d: 1,
                q: `안전한 C 프로그래밍을 위한 체크리스트를 완성하세요.
<pre class="code-c"><span class="cm">// ✅ 해야 할 것 / ❌ 하지 말 것</span></pre>`,
                a: `<span class="key">정답</span><pre class="code-c"><span class="cm">✅ 해야 할 것:</span>
1. malloc 후 NULL 체크
2. free 후 포인터 = NULL
3. gets → fgets 교체
4. sprintf → snprintf 교체
5. 배열 인덱스 범위 검증
6. signed/unsigned 혼합 비교 금지
7. 변수 초기화 후 사용
8. switch에 break 명시
9. 헤더 가드 (#ifndef) 사용
10. 컴파일 경고 수준 -Wall -Werror

<span class="cm">❌ 하지 말 것:</span>
1. 같은 변수 다중 수정 (a = a++ + ++a)
2. 매크로에 부작용 있는 인수
3. 문자열 리터럴 수정
4. free된 메모리 접근
5. 함수에서 지역변수 주소 반환</pre>`}
        ];
        const c = document.getElementById('problems'); P.forEach(p => { const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}>​</span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 답을 작성하세요" rows="8"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="../submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>