<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>⚙️ 알고리즘 설계 학습지 Level 4 — 효율성과 최적화</title>
    <link rel="stylesheet" href="algorithm.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>⚙️ 알고리즘 설계(Algorithm Design) 완전정복</h1>
            <div class="sub">Level 4 · 효율성과 최적화 — 시간복잡도, 알고리즘 전략, 자료구조 기초</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span><span></span></div>
            <div class="meta"><span class="tag pri">📘 Level 4/5</span><span class="tag ok">🟠 난이도 ★★★★☆</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 90~110분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fff7ed">📖</span> 효율적인 알고리즘이란?</h2>
            <p>같은 문제를 풀더라도 <strong>더 빠르고, 더 적은 메모리</strong>로 해결하는 알고리즘이 좋은 알고리즘입니다. <strong>시간 복잡도(Big-O)</strong>로
                알고리즘의 효율을 측정합니다.</p>
            <ul>
                <li><strong>O(1)</strong> — 상수 시간: 입력 크기에 관계없이 일정</li>
                <li><strong>O(log N)</strong> — 로그 시간: 이진 탐색 (매번 절반)</li>
                <li><strong>O(N)</strong> — 선형 시간: 전부 한 번씩 확인</li>
                <li><strong>O(N log N)</strong> — 효율적 정렬 (병합/퀵)</li>
                <li><strong>O(N²)</strong> — 이중 반복: 버블/선택/삽입 정렬</li>
                <li><strong>O(2ⁿ)</strong> — 지수 시간: 모든 경우의 수 (매우 느림!)</li>
            </ul>
            <div class="tip">Big-O는 '최악의 경우의 성장률'을 나타냅니다. N이 커질수록 차이가 극적으로 벌어져요!</div>
        </div>

        <div class="ex">
            <h3>📌 예제: N=1000일 때 각 복잡도의 연산 횟수</h3>
            <div class="flow"><span class="s">O(1)=1</span><span class="a">|</span><span class="s">O(log
                    N)≈10</span><span class="a">|</span><span class="s">O(N)=1,000</span><span class="a">|</span><span
                    class="s">O(N²)=1,000,000</span><span class="a">|</span><span class="s">O(2ⁿ)=???</span></div>
            <p>→ O(2¹⁰⁰⁰)은 우주의 원자 수보다 많음! 알고리즘 선택이 얼마나 중요한지!</p>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="알고리즘_Level1.html">Level 1</a>
            <a href="알고리즘_Level2.html">Level 2</a>
            <a href="알고리즘_Level3.html">← Level 3</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 4</span>
            <a href="알고리즘_Level5.html">Level 5 →</a>
        </div>
        <div class="ft">⚙️ 알고리즘 설계 완전정복 · Level 4/5 · 효율성과 최적화 60문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "복잡도 비교 기초", d: 1, q: "다음을 <strong>빠른 순서</strong>대로 나열하세요: O(N²), O(1), O(N), O(log N), O(N log N)", a: "O(1) < O(log N) < O(N) < O(N log N) < O(N²)<br><span class='key'>핵심</span> 상수 < 로그 < 선형 < 선형로그 < 이차 = 효율 순서!" },
            { n: 2, t: "반복문 복잡도", d: 1, q: "다음 코드의 시간 복잡도는?<br><code>for i=1 to N: print(i)</code>", a: "N번 반복 → <strong>O(N)</strong><br><span class='key'>핵심</span> 단일 반복문 = 선형 시간!" },
            { n: 3, t: "이중 반복문 복잡도", d: 2, q: "다음 코드의 시간 복잡도는?<br><code>for i=1 to N:<br>&nbsp;&nbsp;for j=1 to N:<br>&nbsp;&nbsp;&nbsp;&nbsp;print(i,j)</code>", a: "바깥 N번 × 안쪽 N번 = N² → <strong>O(N²)</strong><br><span class='key'>핵심</span> 이중 반복문 = N²! 중첩될수록 기하급수적!" },
            { n: 4, t: "실생활 복잡도", d: 1, q: "전화번호부에서 이름을 찾을 때, <strong>①처음부터 한 장씩</strong>과 <strong>②중간부터 절반씩</strong>의 복잡도는?", a: "①처음부터 = 순차 탐색 = <strong>O(N)</strong><br>②절반씩 = 이진 탐색 = <strong>O(log N)</strong><br><span class='key'>핵심</span> 이진 탐색은 전화번호부 찾기의 자연스러운 방법!" },
            { n: 5, t: "N=1,000,000일 때", d: 2, q: "N=100만일 때, O(N)과 O(N²)는 각각 몇 번 연산하나요? (1초에 1억 번 연산 가능)", a: "O(N) = 1,000,000 → <strong>0.01초</strong><br>O(N²) = 1,000,000,000,000 = 10¹² → <strong>10,000초 (약 2.8시간!)</strong><br><span class='key'>핵심</span> N이 100만이면 O(N²)는 현실적으로 불가능!" },
            { n: 6, t: "상수는 무시", d: 2, q: "3N+5와 N의 복잡도 차이는?<br>100N과 N²는 N이 얼마일 때 역전되나요?", a: "3N+5 = <strong>O(N)</strong> (상수 3, +5 무시)<br>100N vs N²: N=100일 때 같음, N>100이면 N²가 더 느림!<br><span class='key'>핵심</span> Big-O는 성장률! 상수는 N이 크면 의미 없어짐." },
            { n: 7, t: "탐욕 알고리즘: 동전", d: 2, q: "730원을 <strong>가장 적은 동전 수</strong>로 만드세요. (500,100,50,10원)", a: "500원 × 1 = 500 (남: 230)<br>100원 × 2 = 200 (남: 30)<br>50원 × 0<br>10원 × 3 = 30<br>총 <strong>6개</strong>의 동전<br><span class='key'>핵심</span> 탐욕(Greedy): 항상 큰 것부터 = 최적해!" },
            { n: 8, t: "탐욕이 실패하는 경우", d: 3, q: "동전이 [1원, 3원, 4원]일 때, <strong>6원</strong>을 탐욕으로 만들면? 최적해는?", a: "탐욕: 4+1+1 = <strong>3개</strong><br>최적: 3+3 = <strong>2개!</strong><br>탐욕이 실패! → 동적 프로그래밍 필요<br><span class='key'>핵심</span> 탐욕은 항상 최적이 아니다! 반례가 중요." },
            { n: 9, t: "스택(Stack) 기초", d: 2, q: "스택에 순서대로 A, B, C를 넣고(push), <strong>2번 꺼내면(pop)</strong> 결과는?", a: "push A → push B → push C → [A,B,C(top)]<br>pop → C 꺼냄 → pop → B 꺼냄<br>남은 스택: [A], 꺼낸 순서: <strong>C, B</strong><br><span class='key'>핵심</span> 스택 = LIFO(Last In, First Out)! 후입선출." },
            { n: 10, t: "큐(Queue) 기초", d: 2, q: "큐에 순서대로 1, 2, 3을 넣고, <strong>2번 꺼내면</strong> 결과는?", a: "enqueue 1,2,3 → [1,2,3]<br>dequeue → 1 꺼냄 → dequeue → 2 꺼냄<br>남은 큐: [3], 꺼낸 순서: <strong>1, 2</strong><br><span class='key'>핵심</span> 큐 = FIFO(First In, First Out)! 선입선출." },
            { n: 11, t: "스택 vs 큐", d: 1, q: "다음 상황에서 <strong>스택과 큐 중</strong> 어떤 것을 써야 하나요?<br>①뒤로 가기 버튼 ②프린터 대기열 ③Ctrl+Z(실행 취소)", a: "①뒤로 가기 = <strong>스택</strong> (마지막 방문 페이지부터)<br>②프린터 = <strong>큐</strong> (먼저 보낸 것부터 인쇄)<br>③실행 취소 = <strong>스택</strong> (마지막 작업부터 취소)<br><span class='key'>핵심</span> 최근 것 먼저=스택, 순서대로=큐!" },
            { n: 12, t: "재귀(Recursion) 기초", d: 2, q: "다음 재귀 함수의 결과는?<br><code>f(n): 만약 n=0이면 0 반환, 아니면 n+f(n-1) 반환</code><br>f(4)=?", a: "f(4) = 4+f(3) = 4+3+f(2) = 4+3+2+f(1) = 4+3+2+1+f(0) = 4+3+2+1+0 = <strong>10</strong><br><span class='key'>핵심</span> 재귀 = 자기 자신을 호출! 1+2+3+4=10" },
            { n: 13, t: "재귀 vs 반복", d: 2, q: "팩토리얼을 <strong>반복문과 재귀</strong> 두 가지로 쓰세요. 어떤 차이가 있나요?", a: "<strong>반복:</strong> 결과=1, i=1~N: 결과*=i<br><strong>재귀:</strong> f(N)=N×f(N-1), f(1)=1<br>차이: 재귀는 직관적이지만 메모리(호출 스택) 사용 더 많음<br><span class='key'>핵심</span> 두 방법 모두 결과는 같지만 성능이 다를 수 있다!" },
            { n: 14, t: "분할 정복", d: 2, q: "<strong>분할 정복(Divide & Conquer)</strong>의 3단계를 설명하고, 예시를 드세요.", a: "① <strong>분할(Divide)</strong>: 문제를 작은 부분으로 나누기<br>② <strong>정복(Conquer)</strong>: 작은 문제 각각 해결<br>③ <strong>결합(Combine)</strong>: 결과 합치기<br>예: 병합 정렬, 이진 탐색<br><span class='key'>핵심</span> 큰 문제 → 작은 문제 → 합치기 = D&C!" },
            { n: 15, t: "하노이 탑", d: 3, q: "<strong>하노이 탑</strong> 3개 원반을 옮기는 최소 이동 횟수와 과정을 쓰세요.", h: "N개 원반 = 2ⁿ-1 이동", a: "최소 이동: 2³-1 = <strong>7번</strong><br>과정: A→C, A→B, C→B, A→C, B→A, B→C, A→C<br>규칙: 큰 원반 위에 작은 원반만 올릴 수 있음<br><span class='key'>핵심</span> 하노이 = 재귀의 대표 문제! O(2ⁿ)" },
            { n: 16, t: "메모이제이션", d: 3, q: "피보나치를 재귀로 구하면 <strong>왜 느린지</strong> 설명하고, <strong>메모이제이션</strong>으로 해결하세요.", a: "재귀: f(5) → f(4)+f(3) → f(3)+f(2)+f(2)+f(1) → ...<br>f(3)이 여러 번 계산됨! → <strong>O(2ⁿ)</strong><br>메모이제이션: 계산 결과를 저장해두고 재사용 → <strong>O(N)</strong><br><span class='key'>핵심</span> 중복 계산 제거 = 메모이제이션 = 동적 프로그래밍의 핵심!" },
            { n: 17, t: "복잡도 판별 1", d: 2, q: "다음 반복의 복잡도는?<br><code>i=N, WHILE i>0: i=i÷2</code>", a: "N → N/2 → N/4 → ... → 1<br>N을 2로 몇 번 나눠야 1이 되나? = log₂N번<br>복잡도: <strong>O(log N)</strong><br><span class='key'>핵심</span> 절반씩 줄어듦 = 로그 복잡도!" },
            { n: 18, t: "복잡도 판별 2", d: 2, q: "다음의 복잡도는?<br><code>for i=1 to N:<br>&nbsp;&nbsp;for j=1 to i:<br>&nbsp;&nbsp;&nbsp;&nbsp;print(i,j)</code>", a: "i=1: 1번 + i=2: 2번 + ... + i=N: N번<br>합 = 1+2+...+N = N(N+1)/2 → <strong>O(N²)</strong><br><span class='key'>핵심</span> j가 i까지만이어도 합치면 N²/2 = O(N²)!" },
            { n: 19, t: "공간 복잡도", d: 2, q: "N개 숫자의 합을 구할 때, <strong>배열에 저장 vs 하나씩 더하기</strong>의 공간 복잡도를 비교하세요.", a: "배열 저장: O(N) 메모리 (N개 공간 필요)<br>하나씩 더하기: O(1) 메모리 (합계 변수 1개만)<br><span class='key'>핵심</span> 공간도 비용! 시간과 공간의 트레이드오프." },
            { n: 20, t: "탐욕: 회의실 배정", d: 3, q: "회의 시간이 [(1,4), (3,5), (0,6), (5,7), (3,8), (5,9), (6,10), (8,11), (8,12), (2,13)]일 때, <strong>가장 많은 회의</strong>를 배정하세요.", h: "끝나는 시간이 빠른 순서대로 선택!", a: "끝나는 시간순 정렬: (1,4)→(3,5)→(0,6)→(5,7)→(3,8)→(5,9)→(6,10)→(8,11)→(8,12)→(2,13)<br>선택: (1,4)→(5,7)→(8,11) = <strong>최대 3개!</strong><br>(1,4) OK → (3,5) 겹침 → (0,6) 겹침 → (5,7) OK → ... → (8,11) OK<br><span class='key'>핵심</span> 탐욕: 끝 시간 기준 정렬+겹치지 않는 것 선택!" },
            { n: 21, t: "배열 vs 연결 리스트", d: 2, q: "배열과 연결 리스트의 <strong>장단점</strong>을 비교하세요. (접근/삽입/삭제)", a: "<strong>배열:</strong> 접근 O(1)✅, 삽입 O(N)❌, 삭제 O(N)❌<br><strong>연결 리스트:</strong> 접근 O(N)❌, 삽입 O(1)✅, 삭제 O(1)✅<br><span class='key'>핵심</span> 읽기 많으면 배열, 삽입/삭제 많으면 연결 리스트!" },
            { n: 22, t: "해시 테이블", d: 2, q: "<strong>해시 테이블(Hash Table)</strong>이 탐색을 O(1)로 만드는 원리를 설명하세요.", a: "키(Key) → 해시 함수 → 인덱스 → 바로 접근!<br>예: '사과' → hash('사과') = 3 → 배열[3]에 저장<br>찾을 때: '사과' → 3 → 바로 발견!<br><span class='key'>핵심</span> 해시 = 키를 숫자로 변환하여 바로 접근! 딕셔너리의 원리." },
            { n: 23, t: "두 수의 합", d: 2, q: "[2,7,11,15]에서 합이 <strong>9가 되는 두 수</strong>를 찾으세요. O(N) 방법으로.", h: "해시 테이블을 사용하면?", a: "O(N²) 방법: 모든 쌍 비교 → 느림!<br>O(N) 방법: 해시 사용 → 각 수마다 '9-현재수'가 해시에 있는지 확인<br>2 → 9-2=7 있나? → 아직 없음, 2 저장 → 7 → 9-7=2 있나? → ✅!<br>답: <strong>2+7=9</strong><br><span class='key'>핵심</span> 해시로 O(N²)→O(N) = 극적 최적화!" },
            { n: 24, t: "이진 트리 기초", d: 2, q: "이진 트리에서 <strong>루트, 부모, 자식, 리프(잎)</strong>를 설명하세요.", a: "<strong>루트:</strong> 가장 위의 노드 (시작점)<br><strong>부모:</strong> 위에 연결된 노드<br><strong>자식:</strong> 아래에 연결된 노드 (왼쪽/오른쪽 최대 2개)<br><strong>리프:</strong> 자식이 없는 맨 끝 노드<br><span class='key'>핵심</span> 트리 = 계층적 데이터 구조! 파일 시스템이 대표적." },
            { n: 25, t: "완전 탐색 vs 최적화", d: 2, q: "4자리 비밀번호(0~9)를 <strong>완전 탐색</strong>으로 맞추려면 최대 몇 번?", a: "10×10×10×10 = <strong>10,000번</strong><br>한 자리 알면: 10³=1,000번 (10배 빨라짐!)<br><span class='key'>핵심</span> 완전 탐색 = O(10ⁿ), 정보가 늘면 줄어듦!" },
            { n: 26, t: "동적 프로그래밍: 계단", d: 3, q: "계단 N칸을 <strong>1칸 또는 2칸씩</strong> 올라가며 꼭대기에 도달하는 방법 수를 구하세요. N=5일 때.", h: "N칸 방법 = (N-1칸 방법) + (N-2칸 방법)", a: "f(1)=1, f(2)=2<br>f(3)=f(2)+f(1)=3<br>f(4)=f(3)+f(2)=5<br>f(5)=f(4)+f(3)=<strong>8</strong><br><span class='key'>핵심</span> 피보나치와 같은 구조! DP의 대표 문제." },
            { n: 27, t: "복잡도 비교표", d: 2, q: "N=100일 때, 다음 복잡도 각각의 <strong>대략적 연산 횟수</strong>를 구하세요: O(1), O(log N), O(N), O(N log N), O(N²), O(2ⁿ)", a: "O(1) = <strong>1</strong><br>O(log 100) ≈ <strong>7</strong><br>O(N) = <strong>100</strong><br>O(100×7) ≈ <strong>700</strong><br>O(N²) = <strong>10,000</strong><br>O(2¹⁰⁰) ≈ <strong>10³⁰</strong> (불가능!)<br><span class='key'>핵심</span> 2ⁿ은 N=100만 넘어도 우주 수명으로도 안 끝남!" },
            { n: 28, t: "스택으로 괄호 검사", d: 3, q: "'((()))'이 <strong>올바른 괄호</strong>인지 스택으로 확인하세요.", a: "( → push → (( → push → ((( → push<br>) → pop, 매칭! → )) → pop → ) → pop<br>스택 비어있음 → <strong>올바른 괄호!</strong><br>'(()'은? → pop, pop → 스택에 ( 남음 → 잘못됨!<br><span class='key'>핵심</span> 스택 = 괄호 매칭의 완벽한 도구!" },
            { n: 29, t: "BFS 기초", d: 3, q: "<strong>BFS(너비 우선 탐색)</strong>을 설명하고, 큐를 사용하는 이유를 쓰세요.", a: "BFS: 시작점에서 <strong>가까운 것부터</strong> 방문<br>①시작점 큐에 넣기 ②큐에서 꺼내기 ③이웃 노드 큐에 넣기 ④반복<br>큐 사용 이유: FIFO = 먼저 발견한 것 먼저 방문!<br><span class='key'>핵심</span> BFS = 큐 + 레벨별 탐색! 최단 경로에 사용." },
            { n: 30, t: "DFS 기초", d: 3, q: "<strong>DFS(깊이 우선 탐색)</strong>을 설명하고, 스택(또는 재귀)을 사용하는 이유를 쓰세요.", a: "DFS: 한 방향으로 <strong>끝까지</strong> 간 후 되돌아오기<br>①시작점 스택에 넣기 ②스택에서 꺼내기 ③이웃 노드 스택에 넣기 ④반복<br>스택 사용: LIFO = 최근 발견한 것 먼저 = 깊이 우선!<br><span class='key'>핵심</span> DFS = 스택/재귀 + 깊이 우선! 미로 탐색에 사용." },
            { n: 31, t: "최적 부분 구조", d: 3, q: "<strong>최적 부분 구조</strong>란 무엇인가요? 최단 경로를 예로 설명하세요.", a: "A→C 최단 경로가 A→B→C라면, A→B 구간도 최단 경로여야 함!<br>전체 최적해 = 부분 최적해의 조합<br><span class='key'>핵심</span> 최적 부분 구조 = DP/탐욕 알고리즘 적용 조건!" },
            { n: 32, t: "정렬 복잡도 비교", d: 2, q: "각 정렬의 <strong>평균 시간 복잡도</strong>를 쓰세요: 버블, 선택, 삽입, 병합, 퀵", a: "버블: O(N²) / 선택: O(N²) / 삽입: O(N²)<br>병합: <strong>O(N log N)</strong> / 퀵: <strong>O(N log N)</strong><br><span class='key'>핵심</span> N log N이 비교 기반 정렬의 이론적 한계!" },
            { n: 33, t: "큐로 BFS 추적", d: 3, q: "그래프 A-B, A-C, B-D, C-D에서 A부터 <strong>BFS 순서</strong>를 추적하세요.", a: "큐: [A] → A 방문, B,C 추가 → [B,C]<br>B 방문, D 추가 → [C,D]<br>C 방문 (D 이미 추가) → [D]<br>D 방문 → 빈 큐 → 끝!<br>방문 순서: <strong>A→B→C→D</strong><br><span class='key'>핵심</span> BFS = 레벨별로! A(0단계)→B,C(1단계)→D(2단계)" },
            { n: 34, t: "백트래킹", d: 3, q: "<strong>백트래킹</strong>이란 무엇인가요? 미로에서의 예를 들어 설명하세요.", a: "백트래킹: 가능한 경로를 탐색하다 <strong>막히면 되돌아가서</strong> 다른 길 시도<br>미로: 갈림길에서 한 쪽 선택 → 막다른 골목 → 돌아와서 다른 쪽<br>불필요한 경로는 <strong>가지치기(pruning)</strong>로 건너뜀<br><span class='key'>핵심</span> 완전 탐색 + 가지치기 = 효율적 탐색!" },
            { n: 35, t: "O(N) 최대 이익", d: 3, q: "주식 가격 [7,1,5,3,6,4]에서 <strong>한 번 사고 팔아</strong> 최대 이익을 구하세요.", h: "지금까지의 최저가를 추적하면서 현재가-최저가 계산", a: "최저=7 → (1: 최저=1) → (5: 이익=4) → (3: 이익=2) → (6: 이익=<strong>5</strong>) → (4: 이익=3)<br>최대 이익 = <strong>5</strong> (1에 사서 6에 팔기)<br><span class='key'>핵심</span> 최저가 추적 = O(N)으로 해결! 이중 반복 불필요." },
            { n: 36, t: "연결 리스트 반전", d: 3, q: "연결 리스트 1→2→3→4를 <strong>4→3→2→1</strong>로 뒤집는 알고리즘을 쓰세요.", a: "① 이전=null, 현재=1 ② 다음=현재.next ③ 현재.next=이전 ④ 이전=현재 ⑤ 현재=다음 ⑥ ②~⑤ 반복<br>1→null, 2→1, 3→2, 4→3<br><span class='key'>핵심</span> 포인터 3개(이전/현재/다음) = 연결 리스트 조작의 핵심!" },
            { n: 37, t: "시간 vs 공간 트레이드오프", d: 2, q: "<strong>시간-공간 트레이드오프</strong>의 실생활 예를 드세요.", a: "①전화번호 외우기 vs 연락처 저장: 메모리↑, 시간↓<br>②매번 계산 vs 결과 캐시: 공간↑, 속도↑<br>③압축 파일 vs 원본 파일: 공간↓, 처리시간↑<br><span class='key'>핵심</span> 빠르게 하려면 메모리를 써야 하고, 메모리를 줄이면 느려짐!" },
            { n: 38, t: "이진 탐색 트리", d: 3, q: "<strong>이진 탐색 트리(BST)</strong>에 [5,3,7,1,4,6,8]을 순서대로 삽입하세요.", a: "5(루트) → 3<5(왼) → 7>5(오) → 1<5,<3(왼왼) → 4<5,>3(왼오) → 6<7(오왼) → 8>7(오오)<br>검색: O(log N)! 정렬된 데이터를 효율적으로 저장/검색.<br><span class='key'>핵심</span> BST = 왼쪽<부모<오른쪽! 검색/삽입/삭제 O(log N)" },
            { n: 39, t: "다익스트라 개념", d: 3, q: "<strong>다익스트라 알고리즘</strong>이 최단 경로를 찾는 원리를 설명하세요.", a: "①출발점 거리=0, 나머지=∞ ②거리가 가장 짧은 미방문 노드 선택 ③이웃 노드 거리 업데이트 (더 짧으면 갱신) ④모든 노드 방문까지 반복<br><span class='key'>핵심</span> 탐욕 + 우선순위 큐 = 효율적 최단 경로!" },
            { n: 40, t: "종합: 알고리즘 전략 분류", d: 3, q: "다음 문제들에 <strong>적합한 알고리즘 전략</strong>(탐욕/분할정복/DP/완전탐색/백트래킹)을 연결하세요.<br>①거스름돈 ②병합정렬 ③피보나치 ④스도쿠 ⑤모든 순열", a: "①거스름돈 = <strong>탐욕</strong> (큰 것부터)<br>②병합정렬 = <strong>분할 정복</strong> (반으로 나눠 정렬)<br>③피보나치 = <strong>DP</strong> (중복 부분문제)<br>④스도쿠 = <strong>백트래킹</strong> (시도+되돌아가기)<br>⑤모든 순열 = <strong>완전 탐색</strong> (전부 나열)<br><span class='key'>핵심</span> 문제 유형에 맞는 전략 선택이 핵심!" },
            { n: 41, t: "N log N 이해", d: 2, q: "N=1000일 때 O(N log N)은 약 몇 번? O(N²)과 비교하세요.", a: "O(N log N) = 1000 × log₂(1000) ≈ 1000 × 10 = <strong>약 10,000번</strong><br>O(N²) = 1000 × 1000 = <strong>1,000,000번</strong><br>100배 차이!<br><span class='key'>핵심</span> N이 1000만 넘어도 100배 차이! 좋은 알고리즘의 위력." },
            { n: 42, t: "우선순위 큐", d: 2, q: "우선순위 큐에 (우선도, 값) 쌍 [(3,'A'), (1,'B'), (2,'C')]를 넣고 꺼내면?", a: "우선순위 높은 것 먼저: (1,'B') → (2,'C') → (3,'A')<br>(숫자 작을수록 우선순위 높다고 가정)<br><span class='key'>핵심</span> 우선순위 큐 = 항상 우선순위 높은 것 먼저 나오는 큐!" },
            { n: 43, t: "암호화 시간 복잡도", d: 2, q: "N자리 비밀번호를 <strong>무차별 대입(Brute Force)</strong>으로 깨는 시간 복잡도는? (각 자리 0~9)", a: "1자리: 10=10¹ / 2자리: 100=10² / N자리: <strong>10ⁿ</strong><br>O(10ⁿ) = 지수 시간! N=10이면 100억 번!<br><span class='key'>핵심</span> 비밀번호 길이 1 늘리면 → 10배 느려짐!" },
            { n: 44, t: "투 포인터 기법", d: 3, q: "정렬된 [1,2,3,4,6]에서 <strong>합이 6인 두 수</strong>를 O(N)으로 찾으세요.", a: "왼=0(→1), 오=4(→6) → 합=7>6 → 오--<br>왼=0(→1), 오=3(→4) → 합=5<6 → 왼++<br>왼=1(→2), 오=3(→4) → 합=<strong>6</strong> → 찾음!<br><span class='key'>핵심</span> 투 포인터 = 양쪽에서 좁혀가며 O(N)!" },
            { n: 45, t: "슬라이딩 윈도우", d: 3, q: "[1,3,2,6,4,1,8,5]에서 <strong>연속 3개 합의 최대</strong>를 구하세요.", a: "1+3+2=6 → 3+2+6=11 → 2+6+4=12 → 6+4+1=11 → 4+1+8=<strong>13</strong> → 1+8+5=14... 아, <strong>14</strong>!<br>슬라이딩: 새 합 = 이전 합 - 빠진 것 + 들어온 것<br><span class='key'>핵심</span> 슬라이딩 윈도우 = 창문을 밀며 O(N)!" },
            { n: 46, t: "그래프 표현", d: 2, q: "친구 관계 (A-B, A-C, B-D, C-D)를 <strong>인접 행렬</strong>과 <strong>인접 리스트</strong>로 표현하세요.", a: "<strong>인접 행렬:</strong> A-B=1, A-C=1, B-D=1, C-D=1 (나머지=0)<br><strong>인접 리스트:</strong> A:[B,C] B:[A,D] C:[A,D] D:[B,C]<br><span class='key'>핵심</span> 행렬: 접근 O(1), 메모리 O(N²) / 리스트: 메모리 O(E)" },
            { n: 47, t: "동적 프로그래밍: 배낭", d: 3, q: "배낭 용량=7kg. 물건: A(무게3,가치4), B(무게4,가치5), C(무게5,가치7). <strong>최대 가치</strong>는?", h: "모든 조합을 시도하되, 중복 계산을 저장", a: "A만: 4 / B만: 5 / C만: 7 / A+B: 3+4=7kg→가치9 ✅ / A+C: 3+5=8kg 초과 ❌ / B+C: 9kg 초과 ❌<br>최대 = <strong>A+B = 가치 9</strong><br><span class='key'>핵심</span> 0/1 배낭 문제 = DP의 대표 문제!" },
            { n: 48, t: "재귀 추적", d: 2, q: "재귀 함수의 실행을 추적하세요.<br><code>f(n): 만약 n≤1이면 1 반환, 아니면 f(n-1)×n 반환</code><br>f(5)=?", a: "f(5)=f(4)×5=f(3)×4×5=f(2)×3×4×5=f(1)×2×3×4×5=1×2×3×4×5=<strong>120</strong><br><span class='key'>핵심</span> 이것이 팩토리얼 재귀! 5!=120" },
            { n: 49, t: "알고리즘 선택", d: 2, q: "다음 상황에서 <strong>적절한 알고리즘</strong>을 고르세요.<br>①100만 개 정렬 ②정렬된 배열에서 값 찾기 ③최단 경로", a: "①100만 개 정렬 = <strong>O(N log N)</strong> 필요 → 병합/퀵 정렬<br>②정렬된 배열 = <strong>이진 탐색</strong> O(log N)<br>③최단 경로 = <strong>다익스트라/BFS</strong><br><span class='key'>핵심</span> 문제 크기와 특성에 맞는 알고리즘 선택!" },
            { n: 50, t: "종합: 복잡도 분석", d: 3, q: "다음 각 코드의 <strong>시간 복잡도</strong>를 분석하세요.<br>①단일 for (N번)<br>②이중 for (N×N)<br>③for + 이진탐색<br>④재귀 피보나치<br>⑤for 안에 절반 줄이기", a: "① <strong>O(N)</strong><br>② <strong>O(N²)</strong><br>③ <strong>O(N log N)</strong> = N번 반복 × log N<br>④ <strong>O(2ⁿ)</strong> = 중복 재귀<br>⑤ <strong>O(N log N)</strong> = N × log N<br><span class='key'>핵심</span> 복잡도 분석 = 알고리즘 평가의 필수 기술!" },
            { n: 51, t: "힙(Heap) 구조", d: 3, q: "<strong>최소 힙</strong>에 [5,3,8,1,4]를 넣으면 어떤 구조가 되나요?", a: "삽입 순서: 5→[5], 3→[3,5], 8→[3,5,8], 1→[1,3,8,5], 4→[1,3,8,5,4]<br>루트는 항상 최소값 = <strong>1</strong><br><span class='key'>핵심</span> 힙 = 부모≤자식! 최소/최대를 O(1)로 확인, 삽입/삭제 O(log N)" },
            { n: 52, t: "캐시의 원리", d: 2, q: "<strong>캐시(Cache)</strong>가 프로그램을 빠르게 만드는 원리를 설명하세요.", a: "자주 쓰는 데이터를 가까운 곳에 저장!<br>CPU 캐시: 메모리보다 100배 빠른 칩에 복사<br>웹 캐시: 이미 다운받은 이미지를 재활용<br><span class='key'>핵심</span> 시간-공간 트레이드오프의 대표적 활용!" },
            { n: 53, t: "분할 정복: 거듭제곱", d: 3, q: "2¹⁰을 <strong>분할 정복</strong>으로 효율적으로 계산하세요. (곱셈을 최소화)", a: "일반: 2×2×2×...×2 = 10번 곱셈<br>분할 정복: 2¹⁰=(2⁵)² → 2⁵=(2²)²×2 → 2²=4<br>4→4²×2=32→32²=1024<br>곱셈 <strong>4번</strong>만! (지수를 반으로)<br><span class='key'>핵심</span> 빠른 거듭제곱 = O(log N)! 암호학에서 핵심 사용." },
            { n: 54, t: "안정적인 정렬 선택", d: 2, q: "학생 성적표를 <strong>이름순으로 이미 정렬</strong>된 상태에서, 점수순으로 재정렬. 동점이면 이름순 유지하려면?", a: "<strong>안정 정렬</strong> 사용! (삽입/병합 정렬)<br>안정 정렬은 같은 값의 원래 순서를 유지하므로, 이름순이 보존됨.<br><span class='key'>핵심</span> 다중 기준 정렬 시 안정성이 핵심!" },
            { n: 55, t: "아모타이즈 분석", d: 3, q: "동적 배열(ArrayList)이 꽉 차면 <strong>2배로 확장</strong>합니다. N번 삽입의 평균 복잡도는?", a: "확장 발생: 1,2,4,8,...번째 → 복사 비용: 1+2+4+...+N ≈ 2N<br>총 비용 ≈ N(일반 삽입) + 2N(복사) = 3N<br>평균: 3N/N = <strong>O(1)</strong> (분할 상환)<br><span class='key'>핵심</span> 가끔 O(N)이 발생해도 평균은 O(1)!" },
            { n: 56, t: "비트 연산 활용", d: 3, q: "N이 <strong>2의 거듭제곱</strong>인지 한 번에 확인하는 방법은?", a: "N & (N-1) = 0 이면 2의 거듭제곱!<br>8: 1000 & 0111 = 0 ✅<br>6: 0110 & 0101 = 0100 ≠ 0 ❌<br><span class='key'>핵심</span> 비트 연산 = O(1)! 매우 빠른 체크법." },
            { n: 57, t: "알고리즘 패러다임 식별", d: 2, q: "다음 설명은 어떤 전략?<br>①'매 순간 최선을 선택' ②'문제를 작게 나누고 합침' ③'결과를 저장해 재사용' ④'모든 가능성을 시도'", a: "① <strong>탐욕(Greedy)</strong><br>② <strong>분할 정복(D&C)</strong><br>③ <strong>동적 프로그래밍(DP)</strong><br>④ <strong>완전 탐색(Brute Force)</strong><br><span class='key'>핵심</span> 4대 알고리즘 패러다임!" },
            { n: 58, t: "문자열 검색", d: 3, q: "'AABABACABABAC'에서 패턴 'ABABAC'를 찾으세요. 나이브 방법의 복잡도는?", a: "위치0: AABABA ≠ ABABAC ❌<br>위치1: ABABAC = ABABAC? → 위치 <strong>5</strong>에서 거짓<br>... 위치7: <strong>ABABAC</strong> ✅ 발견!<br>나이브: O(N×M), KMP로 개선 시 O(N+M)<br><span class='key'>핵심</span> 문자열 검색 = KMP/보이어무어로 최적화 가능!" },
            { n: 59, t: "최적화의 한계", d: 3, q: "<strong>NP 문제</strong>란 무엇인가요? 왜 중요한가요?", a: "NP: 답이 맞는지 <strong>검증은 빠르지만</strong>, 답을 <strong>찾는 건 매우 느린</strong> 문제<br>예: ①외판원 문제 ②스도쿠 ③배낭 문제<br>P=NP인지는 100만 달러 밀레니엄 문제!<br><span class='key'>핵심</span> 어떤 문제는 아무리 좋은 알고리즘이라도 근본적으로 느림!" },
            { n: 60, t: "종합: 실전 시스템 설계", d: 3, q: "1억 명의 사용자 데이터에서 <strong>특정 사용자 검색 시스템</strong>을 설계하세요. 어떤 자료구조와 알고리즘을 사용하겠습니까?", h: "해시맵? 이진 탐색 트리? 인덱스?", a: "(자유 응답) 핵심 고려사항:<br>✅ 해시 테이블: O(1) 검색, 충돌 처리 필요<br>✅ B-트리/인덱스: 디스크 기반 효율적 검색<br>✅ 캐시: 자주 찾는 사용자 메모리에<br>✅ 분산 시스템: 1억 명 → 서버 분할<br><span class='key'>핵심</span> 실전에서는 자료구조+알고리즘+인프라를 종합적으로!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : p.d <= 3 ? 'hd' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>