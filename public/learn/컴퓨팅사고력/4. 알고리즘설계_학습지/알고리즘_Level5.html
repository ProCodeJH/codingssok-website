<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>⚙️ 알고리즘 설계 학습지 Level 5 — 종합 알고리즘 설계</title>
    <link rel="stylesheet" href="algorithm.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>⚙️ 알고리즘 설계(Algorithm Design) 완전정복</h1>
            <div class="sub">Level 5 · 종합 알고리즘 설계 — 실전 문제 해결·순서도·창의적 설계</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span><span class="on"></span></div>
            <div class="meta"><span class="tag pri">📘 Level 5/5</span><span class="tag ok">🔴 난이도 ★★★★★</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 100~120분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fff7ed">📖</span> 종합 알고리즘 설계</h2>
            <p>Level 1~4에서 배운 모든 개념을 <strong>종합적으로 활용</strong>합니다. 실전 문제를 분석하고, 순서도를 그리며, 최적의 알고리즘을 설계합니다.</p>
            <ul>
                <li><strong>순서도(Flowchart)</strong> — 알고리즘을 시각적으로 표현</li>
                <li><strong>문제 분석</strong> — 입력/출력/제약 조건 파악</li>
                <li><strong>알고리즘 설계</strong> — 최적 전략 선택 및 구현</li>
                <li><strong>검증과 최적화</strong> — 정확성 확인 및 효율 개선</li>
            </ul>
            <div class="tip">순서도 기호: ○타원=시작/끝, □직사각형=처리, ◇마름모=조건, ▱평행사변형=입출력, →화살표=흐름</div>
        </div>

        <div class="ex">
            <h3>📌 예제: 순서도로 표현한 "짝수/홀수 판별"</h3>
            <div class="flow"><span class="s">○시작</span><span class="a">→</span><span class="s">▱N 입력</span><span
                    class="a">→</span><span class="s">◇N%2=0?</span><span class="a">→ YES →</span><span class="s">□"짝수"
                    출력</span><span class="a">→</span><span class="s">○끝</span></div>
            <p style="margin-left:200px">↓ NO → □"홀수" 출력 → ○끝</p>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="알고리즘_Level1.html">Level 1</a>
            <a href="알고리즘_Level2.html">Level 2</a>
            <a href="알고리즘_Level3.html">Level 3</a>
            <a href="알고리즘_Level4.html">← Level 4</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 5</span>
        </div>
        <div class="ft">⚙️ 알고리즘 설계 완전정복 · Level 5/5 · 종합 알고리즘 설계 60문제 · 🎉 최종 레벨!</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "순서도: 절대값", d: 2, q: "숫자를 입력받아 <strong>절대값</strong>을 출력하는 알고리즘을 <strong>순서도</strong>로 그리세요.", a: "○시작 → ▱N 입력 → ◇N<0? → YES: □N=-N → ▱N 출력 → ○끝<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ NO: ▱N 출력 → ○끝<br><span class='key'>핵심</span> 조건에 따라 처리 경로가 달라지는 기본 순서도!" },
            { n: 2, t: "순서도: 최대값 3개", d: 2, q: "세 수 A, B, C 중 <strong>최대값</strong>을 찾는 순서도를 그리세요.", a: "○시작 → ▱A,B,C 입력 → ◇A>B? → YES: □max=A / NO: □max=B → ◇max>C? → YES: ▱max 출력 / NO: ▱C 출력 → ○끝<br><span class='key'>핵심</span> 순차 비교 = 토너먼트식 최대값 찾기!" },
            { n: 3, t: "순서도: 구구단", d: 2, q: "N단 구구단을 출력하는 순서도를 그리세요. <strong>반복 기호</strong>를 사용하세요.", a: "○시작 → ▱N 입력 → □i=1 → ◇i≤9? → YES: □결과=N×i → ▱'N×i=결과' 출력 → □i=i+1 → (◇로 돌아감) → NO: ○끝<br><span class='key'>핵심</span> 반복문의 순서도 = 조건+화살표 되돌리기!" },
            { n: 4, t: "문제 분석: 자리 배치", d: 2, q: "30명 학생을 <strong>시험 자리</strong>로 배치합니다. 같은 반 학생이 이웃하지 않도록. <strong>입력/출력/제약조건</strong>을 분석하세요.", a: "입력: 30명 이름+반 번호<br>출력: 5×6 좌석 배치도<br>제약: 상하좌우 같은 반 불가<br>전략: 반 번호별 그룹 → 체스판 배치 or 무작위+검증<br><span class='key'>핵심</span> 문제 분석 = 입력/출력/제약조건 명확화가 첫걸음!" },
            { n: 5, t: "문제 분석: 시험 채점", d: 2, q: "객관식 시험 자동 채점 시스템을 설계하세요. <strong>입력/처리/출력</strong>을 명확히 나누세요.", a: "입력: 정답지(20문항), 학생 답안(N명×20문항)<br>처리: 각 학생 답안 vs 정답 비교, 맞은 문항 기록, 점수 계산<br>출력: 학생별 점수, 평균, 최고/최저, 문항별 정답률<br><span class='key'>핵심</span> IPO 분석 = Input → Process → Output!" },
            { n: 6, t: "의사 코드 작성", d: 2, q: "1~100 중 <strong>소수(Prime)</strong>를 모두 출력하는 알고리즘을 <strong>의사 코드</strong>로 쓰세요.", a: "FOR n = 2 TO 100:<br>&nbsp;&nbsp;isPrime = TRUE<br>&nbsp;&nbsp;FOR i = 2 TO √n:<br>&nbsp;&nbsp;&nbsp;&nbsp;IF n % i = 0: isPrime = FALSE, BREAK<br>&nbsp;&nbsp;IF isPrime: PRINT n<br>결과: 2,3,5,7,11,...,97 (25개)<br><span class='key'>핵심</span> 의사 코드 = 프로그래밍 가능한 수준의 알고리즘 서술!" },
            { n: 7, t: "에라토스테네스의 체", d: 3, q: "위의 소수 찾기를 <strong>에라토스테네스의 체</strong>로 최적화하세요.", a: "①2~100 모두 후보 ②2의 배수 제거(4,6,8...) ③3의 배수 제거(9,15...) ④5의 배수 제거 ⑤7의 배수 제거 → √100=10까지만!<br>남은 수 = 소수!<br><span class='key'>핵심</span> 체 = O(N log log N)! 일일이 확인보다 훨씬 빠름!" },
            { n: 8, t: "순서도: 자판기 전체", d: 3, q: "음료 자판기의 <strong>전체 작동 과정</strong>을 순서도로 그리세요. 투입금액, 선택, 잔돈 반환 포함.", a: "○시작 → ▱금액 투입 → □합계 갱신 → ◇충분한가? → NO: ▱'금액 부족' → (투입으로) → YES: ▱구매 가능 음료 표시 → ▱선택 → □음료 배출 → □잔돈=합계-가격 → ◇잔돈>0? → YES: □잔돈 배출 → ○끝<br><span class='key'>핵심</span> 실제 시스템의 순서도 = 상태 전이 포함!" },
            { n: 9, t: "알고리즘 설계: 미로 생성", d: 3, q: "N×N 미로를 <strong>자동 생성</strong>하는 알고리즘을 설계하세요.", h: "DFS + 벽 허물기 기법을 사용해보세요", a: "①모든 셀에 4면 벽 설정 ②시작셀 방문 표시 ③스택에 넣기 ④랜덤 이웃 선택 → 미방문이면 벽 허물기+방문+스택 push ⑤이웃 없으면 pop(백트래킹) ⑥스택 빌 때까지 반복<br><span class='key'>핵심</span> DFS + 백트래킹 = 완벽한 미로 생성!" },
            { n: 10, t: "문제 해결 5단계", d: 1, q: "알고리즘 문제 해결의 <strong>5단계</strong>를 쓰세요.", a: "① <strong>문제 이해</strong> — 무엇을 구하는가?<br>② <strong>입출력 분석</strong> — 입력/출력/제약<br>③ <strong>전략 수립</strong> — 어떤 기법? (탐욕/DP/분할정복...)<br>④ <strong>알고리즘 작성</strong> — 의사코드/순서도<br>⑤ <strong>검증/최적화</strong> — 테스트 케이스로 확인<br><span class='key'>핵심</span> 이 5단계를 항상 따르면 어떤 문제든 풀 수 있다!" },
            { n: 11, t: "테스트 케이스 설계", d: 2, q: "나누기 계산기(A÷B)의 <strong>테스트 케이스</strong>를 5개 이상 작성하세요.", a: "①10÷2=5 (정상) ②7÷2=3.5 (소수 결과) ③10÷0=오류! (0나누기) ④-6÷3=-2 (음수) ⑤0÷5=0 (0나누기) ⑥100÷3=33.33... (무한소수)<br><span class='key'>핵심</span> 경계값/예외값 테스트 = 완벽한 알고리즘의 핵심!" },
            { n: 12, t: "순서도: 로그인 시스템", d: 3, q: "로그인 시스템의 순서도를 그리세요. <strong>비밀번호 3회 실패 잠금, 비밀번호 찾기</strong> 포함.", a: "○시작 → ▱ID 입력 → ◇존재? → NO: '가입필요' → YES: □시도=0 → ▱PW 입력 → ◇맞음? → YES: '로그인 성공' → NO: □시도+1 → ◇시도=3? → YES: '계정 잠금, 비밀번호 찾기?' → NO: (PW 입력으로)<br><span class='key'>핵심</span> 실전 시스템 = 예외 처리가 70% 이상!" },
            { n: 13, t: "알고리즘 선택: 경로 탐색", d: 3, q: "<strong>네비게이션</strong>이 최단 경로를 찾는 알고리즘은? BFS, DFS, 다익스트라 중.", a: "<strong>다익스트라!</strong><br>BFS: 가중치 없는 그래프 → 모든 간선 같은 비용<br>DFS: 최단 경로 보장 ❌<br>다익스트라: 가중치(거리/시간) 있는 그래프 → 최적!<br><span class='key'>핵심</span> 도로마다 거리가 다르므로 가중치 있는 그래프 = 다익스트라!" },
            { n: 14, t: "재귀 순서도", d: 3, q: "팩토리얼 재귀를 <strong>순서도</strong>로 표현하세요.", a: "○시작 → ▱N 입력 → ◇N=0? → YES: □반환 1 → NO: □결과=N×f(N-1) → □반환 결과<br>f(N-1)에서 다시 같은 순서도 호출!<br><span class='key'>핵심</span> 재귀 순서도 = 자기 자신을 참조하는 순서도!" },
            { n: 15, t: "알고리즘 비교: 최단 경로", d: 3, q: "BFS, 다익스트라, A*의 <strong>차이점</strong>을 비교하세요.", a: "<strong>BFS:</strong> 가중치 없음, O(V+E), 큐<br><strong>다익스트라:</strong> 양의 가중치, O(V²) or O(E log V), 우선순위 큐<br><strong>A*:</strong> 다익스트라+휴리스틱, 목표까지 예상 거리 활용, 가장 빠름<br><span class='key'>핵심</span> 네비게이션은 A*! 목적지 방향 정보를 활용해 효율 극대화." },
            { n: 16, t: "설계: 추천 시스템", d: 3, q: "유튜브 영상 <strong>추천 알고리즘</strong>의 기본 원리를 설계하세요.", h: "비슷한 취향의 사용자 찾기 → 그 사용자의 시청 기록 추천", a: "①사용자 시청 기록 수집 ②비슷한 시청 패턴의 사용자 그룹 찾기(유사도 계산) ③그룹 내 다른 사용자가 본 영상 중 본인이 안 본 것 추천 ④인기도/최신성 가중치 적용<br><span class='key'>핵심</span> 협업 필터링(Collaborative Filtering) = 추천의 기본!" },
            { n: 17, t: "오류 분석", d: 2, q: "다음 알고리즘의 <strong>오류</strong>를 찾으세요.<br><code>i=1, 합=0, WHILE i<10: 합=합+i</code>", a: "오류: <strong>i가 증가하지 않음!</strong> → 무한 루프!<br>수정: WHILE 안에 i=i+1 추가<br>또한: i<10이면 1~9까지만 → 1~10이려면 i≤10<br><span class='key'>핵심</span> 반복문에서 변수 업데이트 누락 = 가장 흔한 버그!" },
            { n: 18, t: "오류 분석 2", d: 2, q: "배열 [5,3,7] 정렬 코드의 <strong>오류</strong>를 찾으세요.<br><code>for i=0 to 2: for j=0 to 2: if A[j]>A[j+1]: swap</code>", a: "오류: j가 2일 때 <strong>A[j+1]=A[3]</strong> → 배열 범위 초과!<br>수정: j=0 to <strong>1</strong> (길이-2까지)<br><span class='key'>핵심</span> 인덱스 초과(Off-by-one error) = 프로그래밍 가장 흔한 버그!" },
            { n: 19, t: "설계: 엘리베이터", d: 3, q: "5층 건물 엘리베이터의 <strong>운행 알고리즘</strong>을 설계하세요. 복수 요청 처리.", a: "①현재층, 이동방향, 요청 큐 관리 ②같은 방향 요청 먼저 처리(SCAN 알고리즘) ③위로 가는 중: 위층 요청 먼저 → 꼭대기 도달 시 방향 전환 ④아래로 가는 중: 아래층 요청 먼저<br><span class='key'>핵심</span> SCAN/LOOK 알고리즘 = 디스크 스케줄링과 동일 원리!" },
            { n: 20, t: "설계: 검색 엔진", d: 3, q: "간단한 <strong>문서 검색 엔진</strong>의 알고리즘을 설계하세요. 키워드로 문서 검색.", a: "①문서 색인: 각 단어 → 해당 문서 목록 (역인덱스) ②검색: 키워드 → 역인덱스 조회 → 문서 목록 ③순위: 키워드 등장 횟수(TF) × 희귀도(IDF) ④결과 정렬 후 상위 N개 반환<br><span class='key'>핵심</span> 역인덱스(Inverted Index) + TF-IDF = 검색의 핵심!" },
            { n: 21, t: "순서도: ATM 전체", d: 3, q: "ATM 기기의 <strong>전체 작운 과정</strong>을 순서도로 그리세요. 인증/입출금/이체/잔액조회.", a: "○시작 → 카드 삽입 → PIN 입력 → ◇인증? → NO: ◇3회? → YES: 카드 회수 → YES: 메뉴 표시 → ◇선택? → 1:출금 → 금액 입력 → ◇잔액≥? → YES: 출금 → 2:입금 → 금액 투입 → 3:이체 → 계좌+금액 → 4:잔액 → 표시 → 계속? → ○끝<br><span class='key'>핵심</span> 상태 기계(State Machine) 설계의 실전 예!" },
            { n: 22, t: "설계: 스마트 신호등", d: 3, q: "교통량에 따라 <strong>자동 조절되는 신호등</strong> 알고리즘을 설계하세요.", a: "①각 방향 차량 수 센서로 측정 ②초록 시간 = 기본시간 + (차량수 × 가중치) ③최소/최대 시간 제한 설정 ④긴급차량 감지 시 즉시 초록 전환 ⑤보행자 버튼 요청 처리<br><span class='key'>핵심</span> 센서+조건+동적 조절 = IoT 알고리즘의 실전!" },
            { n: 23, t: "완전 탐색: 조합", d: 3, q: "[1,2,3,4]에서 <strong>2개를 뽑는 모든 조합</strong>을 나열하세요.", a: "(1,2)(1,3)(1,4)(2,3)(2,4)(3,4) = <strong>6가지</strong><br>공식: C(4,2) = 4!/(2!×2!) = 6<br><span class='key'>핵심</span> 조합 = 순서 상관없이 선택! 경우의 수 계산의 기본." },
            { n: 24, t: "완전 탐색: 순열", d: 3, q: "[A,B,C]의 <strong>모든 순열</strong>을 나열하세요.", a: "ABC, ACB, BAC, BCA, CAB, CBA = <strong>6가지</strong><br>공식: P(3,3) = 3! = 6<br><span class='key'>핵심</span> 순열 = 순서가 중요! N! = N×(N-1)×...×1" },
            { n: 25, t: "설계: 암호화", d: 3, q: "간단한 <strong>치환 암호화</strong> 알고리즘을 설계하세요. 키를 사용한 암호화/복호화.", a: "암호화: 각 글자를 키만큼 시프트: 'HELLO' + 키3 = 'KHOOR'<br>복호화: 역으로 시프트: 'KHOOR' - 키3 = 'HELLO'<br><span class='key'>핵심</span> 시저 암호! 키 공간 = 26, 무차별 대입으로 깨짐 → 현대 암호와의 차이." },
            { n: 26, t: "재귀: 하노이 N개", d: 3, q: "하노이 탑 <strong>N개 원반</strong>의 재귀 알고리즘을 의사 코드로.", a: "hanoi(N, 출발, 도착, 경유):<br>&nbsp;&nbsp;IF N=1: 출발→도착 이동<br>&nbsp;&nbsp;ELSE:<br>&nbsp;&nbsp;&nbsp;&nbsp;hanoi(N-1, 출발, 경유, 도착)<br>&nbsp;&nbsp;&nbsp;&nbsp;출발→도착 이동<br>&nbsp;&nbsp;&nbsp;&nbsp;hanoi(N-1, 경유, 도착, 출발)<br><span class='key'>핵심</span> 3줄 재귀로 2ⁿ-1번 이동 = 재귀의 우아함!" },
            { n: 27, t: "시뮬레이션: 가위바위보 승률", d: 2, q: "가위바위보를 <strong>1000번 시뮬레이션</strong>하여 각각의 승률을 계산하는 알고리즘.", a: "①승/패/무=0 ②1000번 반복: ③AI=랜덤, 나=랜덤 ④판정→카운트 ⑤승률=승/1000×100%<br>이론: 각 33.3%에 수렴<br><span class='key'>핵심</span> 몬테카를로 시뮬레이션 = 확률을 실험으로 검증!" },
            { n: 28, t: "설계: 일정 관리", d: 3, q: "학교 시간표를 <strong>자동 배치</strong>하는 알고리즘을 설계하세요. 제약: 같은 시간 같은 선생님 불가.", a: "①과목/교사/교실/시간 데이터 ②백트래킹: 빈 시간에 과목 배치 시도 ③제약 확인: 교사 충돌? 교실 충돌? 연속 수업 초과? ④위반 시 되돌아가서 다른 배치 ⑤모든 과목 배치 완료 시 종료<br><span class='key'>핵심</span> 제약 만족 문제(CSP) = 백트래킹의 대표 응용!" },
            { n: 29, t: "데이터 압축 원리", d: 3, q: "'AAAAABBBCC'를 <strong>런 길이 인코딩(RLE)</strong>으로 압축하세요.", a: "'AAAAABBBCC' → '<strong>5A3B2C</strong>'<br>10글자 → 6글자! 약 40% 압축<br>반복 없으면 비효율: 'ABCD' → '1A1B1C1D' = 오히려 늘어남!<br><span class='key'>핵심</span> RLE = 연속 반복에 효과적! 비트맵 이미지에 사용." },
            { n: 30, t: "종합: CT 4단계 통합", d: 3, q: "'학교 도서관 관리 시스템'을 CT 4단계로 설계하세요.<br>① 분해 ② 패턴인식 ③ 추상화 ④ 알고리즘 설계", a: "①분해: 도서 등록/검색/대출/반납/연체관리<br>②패턴: 대출→반납 패턴, 인기 도서 패턴<br>③추상화: 책{제목,저자,ISBN}, 학생{이름,학번}<br>④알고리즘: 검색=이진탐색, 정렬=제목순, 연체=날짜 비교<br><span class='key'>핵심</span> CT 4단계의 완벽한 통합 = 컴퓨팅 사고력의 완성!" },
            { n: 31, t: "설계: 채팅 프로그램", d: 3, q: "간단한 <strong>채팅 프로그램</strong>의 메시지 전송 알고리즘을 설계하세요.", a: "①사용자 입력 → 메시지 생성(송신자, 내용, 시간) ②서버로 전송(큐에 저장) ③서버가 수신자에게 전달 ④수신자 화면에 표시 ⑤읽음 확인 → 송신자에게 알림<br><span class='key'>핵심</span> 메시지 큐 + 비동기 전송 = 실시간 통신의 기본!" },
            { n: 32, t: "병렬 vs 순차", d: 2, q: "밥+국+반찬 3가지를 만들 때, <strong>순차 vs 병렬</strong> 시간을 비교하세요. 밥 30분, 국 15분, 반찬 10분.", a: "순차: 30+15+10 = <strong>55분</strong><br>병렬: 밥 짓는 동안 국+반찬 동시 → <strong>30분</strong>!<br>25분 절약! (45% 단축)<br><span class='key'>핵심</span> 병렬 처리 = 독립적인 작업은 동시에!" },
            { n: 33, t: "설계: 자동 완성", d: 3, q: "검색창의 <strong>자동 완성(autocomplete)</strong> 알고리즘을 설계하세요.", h: "Trie(트라이) 자료구조를 생각해보세요", a: "①사전 단어를 트라이(Trie)에 저장 ②사용자 입력 문자마다 트라이 탐색 ③현재 노드 아래 모든 단어 후보 추출 ④빈도순 정렬 → 상위 5개 표시<br>예: 'co' → computer, code, color, cookie, copy<br><span class='key'>핵심</span> 트라이 = 접두사 검색에 최적! O(L) 시간 (L=입력 길이)" },
            { n: 34, t: "순서도: 자동 급수", d: 2, q: "화분 토양 습도를 측정하여 <strong>자동으로 물을 주는</strong> IoT 시스템 순서도.", a: "○시작 → □습도 센서 읽기 → ◇습도<30%? → YES: □펌프 ON → □5초 대기 → □펌프 OFF → □10분 대기 → (센서 읽기로) → NO: □10분 대기 → (센서 읽기로)<br><span class='key'>핵심</span> 센서+조건+실행기 = IoT 제어 루프의 표준 패턴!" },
            { n: 35, t: "설계: 음식 배달 매칭", d: 3, q: "음식 배달 앱에서 <strong>주문-배달기사 매칭</strong> 알고리즘을 설계하세요.", a: "①주문 발생 → 위치 기반 반경 내 배달기사 탐색 ②기사별 점수: 거리(가까울수록 ↑) + 현재 주문수(적을수록 ↑) + 평점 ③가장 높은 점수 기사에게 배정 ④수락/거절 응답 대기 → 거절 시 다음 기사<br><span class='key'>핵심</span> 다기준 점수 매칭 + 탐욕적 배정!" },
            { n: 36, t: "해시 충돌 해결", d: 3, q: "해시 테이블에서 <strong>충돌(collision)</strong>이 발생하면 어떻게 하나요? 2가지 방법.", a: "① <strong>체이닝:</strong> 같은 인덱스에 연결 리스트로 여러 값 저장<br>② <strong>개방 주소법:</strong> 다음 빈 칸 찾기 (선형 탐사)<br>좋은 해시 함수 = 충돌 최소화!<br><span class='key'>핵심</span> 충돌 해결 = 해시 테이블 성능의 핵심!" },
            { n: 37, t: "순서도: 게임 루프", d: 2, q: "게임의 <strong>메인 루프(Game Loop)</strong>를 순서도로.", a: "○시작 → □초기화 → (루프 시작) → □입력 처리 → □게임 로직 업데이트 → □화면 렌더링 → ◇종료? → NO: (루프 시작으로) → YES: □정리 → ○끝<br><span class='key'>핵심</span> Input→Update→Render = 모든 게임의 기본 구조!" },
            { n: 38, t: "설계: 스팸 필터", d: 3, q: "이메일 <strong>스팸 필터</strong>의 기본 알고리즘을 설계하세요.", a: "①이메일 단어 추출(토큰화) ②각 단어의 스팸 확률 계산(학습 데이터 기반) ③나이브 베이즈: P(스팸|단어들) 계산 ④확률 > 임계값 → 스팸 폴더, 아니면 → 수신함<br>특징 단어: '무료', '당첨', '긴급' 등<br><span class='key'>핵심</span> 나이브 베이즈 분류 = 확률 기반 알고리즘의 실전!" },
            { n: 39, t: "복잡도 최적화 실습", d: 3, q: "배열에서 <strong>중복 원소를 찾는</strong> 알고리즘을 O(N²)에서 O(N)으로 최적화하세요.", a: "O(N²): 이중 반복으로 모든 쌍 비교<br>O(N): 해시 셋 사용! 각 원소를 셋에 넣되, 이미 있으면 '중복!'<br><code>셋={}, 각 원소: 셋에 있나? → YES: 중복! / NO: 셋에 추가</code><br><span class='key'>핵심</span> 해시 = O(N²)→O(N) 마법! 공간 O(N) 트레이드오프." },
            { n: 40, t: "설계: 최단 경로 실전", d: 3, q: "5개 도시(A~E)와 도로 거리가 주어졌을 때, A에서 E까지 <strong>최단 경로</strong>를 다익스트라로.", h: "A-B:4, A-C:2, B-D:3, C-B:1, C-D:5, D-E:1", a: "A(0) → C(2) [A→C:2] → B(3) [A→C→B:2+1] → D(6) [A→C→B→D:2+1+3] → E(<strong>7</strong>) [A→C→B→D→E:2+1+3+1]<br><span class='key'>핵심</span> 다익스트라 = 가장 가까운 미방문 노드부터! 탐욕의 정수." },
            { n: 41, t: "설계: QR코드 스캔", d: 3, q: "QR코드를 <strong>스캔하여 URL을 추출</strong>하는 알고리즘의 주요 단계를 쓰세요.", a: "①카메라 이미지 캡처 ②흑백 변환(이진화) ③위치 패턴 3개 탐지 (네모 3개) ④기울기 보정 ⑤데이터 영역 추출 ⑥오류 정정(리드-솔로몬 코드) ⑦디코딩 → URL 문자열<br><span class='key'>핵심</span> 이미지 처리 + 에러 정정 + 디코딩 = 복합 알고리즘!" },
            { n: 42, t: "정렬 안정성과 실전", d: 2, q: "엑셀에서 성적표를 <strong>1차:반, 2차:번호순</strong>으로 정렬하는 전략은?", a: "방법: <strong>번호순 정렬 먼저 → 그 다음 반 정렬(안정 정렬!)</strong><br>안정 정렬이면 같은 반 안에서 번호순 유지됨!<br>또는: 비교 함수에서 (반, 번호) 튜플 비교<br><span class='key'>핵심</span> 다중 키 정렬 = 2차 키 먼저 정렬 + 1차 키 안정 정렬!" },
            { n: 43, t: "설계: 게임 AI", d: 3, q: "틱택토(삼목) 게임의 <strong>절대 지지 않는 AI</strong>를 설계하세요.", h: "미니맥스(Minimax) 알고리즘", a: "①모든 가능한 수 탐색(재귀) ②AI 턴: 점수 최대화 ③상대 턴: 점수 최소화 ④승리=+10, 패배=-10, 무승부=0 ⑤가장 높은 점수의 수 선택<br><span class='key'>핵심</span> 미니맥스 = 상대도 최선을 다한다고 가정! 게임 AI의 기본." },
            { n: 44, t: "그래프 사이클 탐지", d: 3, q: "방향 그래프에서 <strong>사이클(순환)</strong>이 있는지 탐지하는 알고리즘.", a: "DFS로 탐색하면서 '방문 중'인 노드를 다시 만나면 사이클!<br>상태: 미방문(0)/방문중(1)/완료(2)<br>방문중인 노드를 다시 발견 → 사이클 존재!<br><span class='key'>핵심</span> DFS + 3-state 색칠 = 사이클 탐지의 표준!" },
            { n: 45, t: "설계: 압축 알고리즘", d: 3, q: "<strong>허프만 코딩</strong>의 원리를 설명하세요. 'AABBBCCCC'를 압축.", a: "빈도: A=2, B=3, C=4<br>트리: C(0), B(10), A(11)<br>원본: 9문자×8비트=72비트<br>압축: 4×1+3×2+2×2=<strong>14비트</strong>!<br><span class='key'>핵심</span> 자주 나오는 문자 = 짧은 코드! 빈도 기반 최적 압축." },
            { n: 46, t: "동시성 문제", d: 3, q: "두 사람이 동시에 같은 계좌에서 출금하면 생기는 <strong>문제</strong>와 해결책을 쓰세요.", a: "잔액=1000, A가 800 출금, B가 500 출금<br>동시: 둘 다 잔액 1000 확인 → A 출금(200남) + B 출금(-300!)<br>해결: <strong>잠금(Lock)</strong> → 한 번에 한 명만 접근!<br><span class='key'>핵심</span> 경쟁 조건(Race Condition) = 동시성의 핵심 문제!" },
            { n: 47, t: "설계: 지도 앱", d: 3, q: "지도 앱이 <strong>현재 위치에서 목적지까지 안내</strong>하는 전체 알고리즘.", a: "①GPS로 현재 위치 ②목적지 검색(역인덱스) ③A* 알고리즘으로 최단/최적 경로 계산 ④실시간 교통 정보 반영(가중치 업데이트) ⑤턴바이턴 네비게이션(현재 위치 추적+다음 교차로 안내) ⑥경로 이탈 감지 → 재계산<br><span class='key'>핵심</span> GPS+그래프+A*+실시간 = 현대 네비게이션!" },
            { n: 48, t: "CT 통합: 스마트홈", d: 3, q: "'스마트홈 시스템'을 <strong>CT 4단계</strong>로 설계하세요.", a: "①분해: 조명/온도/보안/가전 각각 분리 ②패턴: 시간대별 사용 패턴, 에너지 소비 패턴 ③추상화: 디바이스{타입,상태,위치}, 룰{조건,동작} ④알고리즘: IF 온도>28 → 에어컨 ON, IF 외출 → 보안모드<br><span class='key'>핵심</span> CT 4단계가 실제 시스템 설계에 그대로 적용!" },
            { n: 49, t: "설계: 투표 시스템", d: 3, q: "온라인 투표 시스템의 알고리즘을 설계하세요. <strong>보안과 익명성</strong> 포함.", a: "①유권자 인증(신분 확인) ②투표 암호화(공개키) ③투표 기록(블록체인/변조 방지) ④중복 투표 방지(해시 기반) ⑤개표: 복호화 후 집계 ⑥결과 공개(투표자 익명 보장)<br><span class='key'>핵심</span> 암호화+무결성+익명성 = 보안 시스템의 3요소!" },
            { n: 50, t: "종합: 알고리즘 포트폴리오", d: 3, q: "지금까지 배운 <strong>모든 알고리즘 전략</strong>(탐욕/DP/분할정복/탐색/정렬/자료구조)을 표로 정리하세요.", a: "(자유 응답) 정리 포인트:<br>✅ 각 전략의 핵심 원리<br>✅ 대표 문제 예시<br>✅ 시간 복잡도<br>✅ 장단점<br>✅ 실생활 적용 사례<br><span class='key'>핵심</span> 이 표가 당신의 알고리즘 사전!" },
            { n: 51, t: "설계: 지하철 노선도", d: 3, q: "지하철 앱에서 <strong>최소 환승 경로</strong>를 찾는 알고리즘을 설계하세요.", a: "①역=노드, 연결=간선, 노선=색상 ②BFS: 환승 1번=깊이1, 2번=깊이2 ③같은 노선 이동=가중치 0 ④환승=가중치 1 ⑤최소 환승 수의 경로 반환<br><span class='key'>핵심</span> 환승=간선 가중치! BFS=최소 환승, 다익스트라=최소 시간!" },
            { n: 52, t: "설계: 음악 셔플", d: 2, q: "음악 앱의 <strong>셔플(무작위 재생)</strong> 알고리즘. 같은 곡이 연속 안 되게.", a: "Fisher-Yates 셔플 → 순서대로 재생 → 끝나면 다시 셔플<br>추가: 직전 N곡과 같은 아티스트 연속 방지 필터<br><span class='key'>핵심</span> 순수 랜덤 vs 체감 랜덤 = 사용자 경험 고려!" },
            { n: 53, t: "최적화: 캐시 전략", d: 3, q: "캐시 크기가 3인 LRU(Least Recently Used) 캐시에 [1,2,3,4,1,2,5,1,2,3]을 순서대로 접근할 때 히트/미스를 추적하세요.", a: "1(miss)[1] → 2(miss)[1,2] → 3(miss)[1,2,3] → 4(miss→1제거)[2,3,4] → 1(miss→2제거)[3,4,1] → 2(miss→3제거)[4,1,2] → 5(miss→4제거)[1,2,5] → 1(<strong>hit</strong>)[2,5,1] → 2(<strong>hit</strong>)[5,1,2] → 3(miss→5제거)[1,2,3]<br>히트: <strong>2번</strong>, 미스: 8번<br><span class='key'>핵심</span> LRU = 가장 오래 안 쓴 것 제거! 캐시의 표준 전략." },
            { n: 54, t: "설계: 주차장 시스템", d: 3, q: "<strong>자동 주차장 관리 시스템</strong>의 알고리즘을 설계하세요.", a: "①입차: 번호판 인식(OCR) → 빈 자리 탐색(가까운 것 우선) → 배정 ②주차: 자리별 센서로 점유 추적 ③출차: 번호판 인식 → 주차 시간 계산 → 요금 산정 → 결제 → 차단기 개방<br><span class='key'>핵심</span> OCR+센서+탐색+계산 = 복합 시스템 알고리즘!" },
            { n: 55, t: "설계: 비밀번호 해시", d: 3, q: "왜 비밀번호를 <strong>해시</strong>로 저장해야 하나요? 알고리즘을 설명하세요.", a: "평문 저장: DB 유출 시 비번 노출!<br>해시 저장: password → hash('password') = 'e5e9f...'<br>로그인: 입력 비번 해시 == 저장된 해시?<br>소금(Salt) 추가: hash(password+salt) → 같은 비번도 다른 해시!<br><span class='key'>핵심</span> 해시 = 일방향 함수! 원본 복원 불가 = 보안의 기본." },
            { n: 56, t: "설계: 추천 피드", d: 3, q: "SNS 피드에 게시물을 <strong>어떤 순서</strong>로 표시할지 알고리즘을 설계하세요.", a: "점수 = 시간 가중치(최신↑) × 친밀도(친한 친구↑) × 참여도(좋아요/댓글↑) × 콘텐츠 유형 선호(사진/동영상↑)<br>점수 높은 순으로 표시 + 다양성 보장(같은 사람 연속 방지)<br><span class='key'>핵심</span> 다기준 스코어링 = 추천 알고리즘의 핵심 패턴!" },
            { n: 57, t: "설계: 파일 시스템", d: 3, q: "컴퓨터 <strong>파일 시스템</strong>이 파일을 저장하고 찾는 알고리즘의 기본 원리.", a: "①트리 구조: 루트→폴더→하위폴더→파일 ②디스크 블록 할당(연속/연결/인덱스 방식) ③파일 검색: 경로를 따라 트리 순회 ④삭제: 블록 해제(데이터는 남아있음!) ⑤조각 모음: 연속 블록으로 재배치<br><span class='key'>핵심</span> 트리 + 블록 할당 + 인덱스 = OS 파일 시스템!" },
            { n: 58, t: "CT 통합: 택배 시스템", d: 3, q: "'전국 택배 배송 시스템'을 CT 4단계로 완전 설계하세요.", a: "①분해: 접수/분류/운송/배달/추적 ②패턴: 시간대별 물량, 지역별 배송 시간 패턴 ③추상화: 택배{송신, 수신, 무게, 상태}, 허브{위치, 용량} ④알고리즘: 경로최적화(TSP/다익스트라), 분류(바코드→해시), 배차(탐욕)<br><span class='key'>핵심</span> 대규모 물류 = CT의 궁극적 응용!" },
            { n: 59, t: "미래의 알고리즘", d: 2, q: "<strong>양자 컴퓨팅, 머신러닝, 유전 알고리즘</strong> 중 하나를 골라 원리를 설명하세요.", a: "<strong>유전 알고리즘:</strong> ①초기 해(무작위) 생성 ②적합도 평가 ③선택(좋은 해 살림) ④교차(두 해 섞기) ⑤변이(약간 변형) ⑥반복 → 최적해에 수렴!<br>자연 선택을 모방한 최적화!<br><span class='key'>핵심</span> 생물학에서 영감 = 메타휴리스틱 알고리즘!" },
            { n: 60, t: "🏆 최종 종합: 나의 프로젝트", d: 3, q: "실생활의 문제를 하나 선택하여 <strong>CT 4단계(분해, 패턴인식, 추상화, 알고리즘 설계)</strong>를 모두 적용한 완전한 솔루션을 설계하세요. <strong>순서도, 의사 코드, 복잡도 분석</strong>을 모두 포함하세요.", h: "이 문제가 Level 5의 최종 보스! 지금까지 배운 모든 것을 총동원하세요.", a: "(자유 응답) 최종 평가 기준:<br>✅ 실생활 문제 선정?<br>✅ CT 4단계 모두 적용?<br>✅ 순서도 포함?<br>✅ 의사 코드 작성?<br>✅ 시간/공간 복잡도 분석?<br>✅ 테스트 케이스 설계?<br>✅ 최적화 방안 제시?<br><br>🎉 <strong>축하합니다!</strong> 여기까지 완주했다면 당신은 알고리즘 설계 마스터입니다!<br><span class='key'>핵심</span> CT의 완성 = 분해+패턴+추상화+알고리즘이 하나로!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : p.d <= 3 ? 'hd' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>