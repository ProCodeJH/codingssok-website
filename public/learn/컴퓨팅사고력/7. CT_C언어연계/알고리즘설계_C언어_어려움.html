<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💻 알고리즘 설계 → C언어 (어려움) — DP·그래프·고급 설계</title>
    <link rel="stylesheet" href="ct_c.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>💻 알고리즘 설계(Algorithm Design) → C언어</h1>
            <div class="sub">어려움 · DP·그래프·고급 설계</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span></div>
            <div class="meta"><span class="tag pri"
                    style="background:rgba(245,158,11,.1);border-color:rgba(245,158,11,.3);color:#f59e0b">⚙️ 알고리즘
                    설계</span><span class="tag" style="color:var(--err);border-color:rgba(248,113,113,.3)">🔴
                    어려움</span><span class="tag acc">📝 20문제</span><span class="tag">⏱ 60~90분</span></div>
        </div>
        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>
        <div class="learn">
            <h2><span class="ico" style="background:rgba(248,113,113,.15)">⚙️</span> 어려움 난이도 안내</h2>
            <p>동적 프로그래밍(DP), 그래프 알고리즘(BFS/DFS), 분할 정복 최적화 등 <strong>대회 수준의 알고리즘 설계</strong>를 다룹니다!</p>
            <div class="tip">💡 DP = "이미 풀었던 작은 문제의 답을 기억해서 재활용"</div>
        </div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p><button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg"><a href="알고리즘설계_C언어_쉬움.html">← 쉬움</a><a href="알고리즘설계_C언어_보통.html">보통</a><span
                class="tag active">어려움</span></div>
        <div class="ft">💻 CT → C언어 · 알고리즘 설계 · 어려움 20문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "DP: 피보나치 메모이제이션", d: 4, q: "재귀 피보나치의 <strong>중복 계산을 제거</strong>하는 DP. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> memo[<span class='num'>50</span>]={<span class='num'>0</span>};<br><span class='ln'>2</span><span class='type'>int</span> <span class='fn'>fib</span>(<span class='type'>int</span> n){<br><span class='ln'>3</span>    <span class='kw'>if</span>(n<=<span class='num'>1</span>) <span class='kw'>return</span> n;<br><span class='ln'>4</span>    <span class='kw'>if</span>(memo[n]) <span class='kw'>return</span> memo[n];<br><span class='ln'>5</span>    <span class='kw'>return</span> memo[n]=<span class='fn'>fib</span>(n-<span class='num'>1</span>)+<span class='fn'>fib</span>(n-<span class='num'>2</span>);<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,<span class='fn'>fib</span>(<span class='num'>10</span>));</div>", a: "<span class='key'>출력</span> <code>55</code><br><span class='step'>DP vs 순수 재귀</span><div class='trace'>순수 재귀: fib(10) → 177번 호출! O(2ⁿ)<br>메모이제이션: fib(10) → 19번 호출! O(n)<br><br>memo[2]=1, memo[3]=2, memo[4]=3,<br>memo[5]=5, ... memo[10]=<span class='val'>55</span></div><div class='explain'>💡 <strong>메모이제이션(Top-Down DP)</strong>: 계산한 결과를 memo 배열에 저장! 같은 입력이 오면 다시 계산하지 않고 저장값 반환. 지수→선형 시간!</div>" },
            { n: 2, t: "DP: 동전 교환 (최소 개수)", d: 4, q: "동전 {1,3,5}원으로 <strong>7원</strong>을 만드는 최소 동전 수.<div class='code-block'><span class='type'>int</span> coins[]={<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>5</span>}, dp[<span class='num'>8</span>];<br><span class='fn'>memset</span>(dp,<span class='num'>127</span>,<span class='kw'>sizeof</span>(dp)); <span class='cm'>// 큰 값으로 초기화</span><br>dp[<span class='num'>0</span>]=<span class='num'>0</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>7</span>;i++)<br>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;<span class='num'>3</span>;j++)<br>        <span class='kw'>if</span>(coins[j]<=i && dp[i-coins[j]]+<span class='num'>1</span>&lt;dp[i])<br>            dp[i]=dp[i-coins[j]]+<span class='num'>1</span>;<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,dp[<span class='num'>7</span>]);</div>", a: "<span class='key'>출력</span> <code>3</code> (5+1+1 또는 3+3+1)<br><span class='step'>DP 테이블</span><div class='trace'>dp[0]=0<br>dp[1]=min(dp[0]+1)=<span class='val'>1</span> (1원 1개)<br>dp[2]=min(dp[1]+1)=<span class='val'>2</span><br>dp[3]=min(dp[2]+1,dp[0]+1)=<span class='val'>1</span> (3원 1개!)<br>dp[4]=min(dp[3]+1)=<span class='val'>2</span><br>dp[5]=min(dp[4]+1,dp[2]+1,dp[0]+1)=<span class='val'>1</span><br>dp[6]=min(dp[5]+1,dp[3]+1)=<span class='val'>2</span><br>dp[7]=min(dp[6]+1,dp[4]+1,dp[2]+1)=<span class='val'>3</span></div><div class='explain'>💡 <strong>Bottom-Up DP</strong>: 작은 문제(0원)부터 큰 문제(7원)까지 채워나가기! 그리디(큰 돈부터)와 달리 항상 최적해 보장.</div>" },
            { n: 3, t: "DP: 계단 오르기", d: 3, q: "1칸 또는 2칸씩 계단 오르기. <strong>5칸</strong>을 오르는 방법의 수는?<div class='code-block'><span class='type'>int</span> dp[<span class='num'>6</span>]={<span class='num'>0</span>};<br>dp[<span class='num'>0</span>]=<span class='num'>1</span>; dp[<span class='num'>1</span>]=<span class='num'>1</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>2</span>;i<=<span class='num'>5</span>;i++)<br>    dp[i]=dp[i-<span class='num'>1</span>]+dp[i-<span class='num'>2</span>];<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,dp[<span class='num'>5</span>]);</div>", a: "<span class='key'>출력</span> <code>8</code><br><span class='step'>추적</span><div class='trace'>dp[0]=1, dp[1]=1<br>dp[2]=dp[1]+dp[0]=1+1=<span class='val'>2</span><br>dp[3]=dp[2]+dp[1]=2+1=<span class='val'>3</span><br>dp[4]=dp[3]+dp[2]=3+2=<span class='val'>5</span><br>dp[5]=dp[4]+dp[3]=5+3=<span class='val'>8</span></div><div class='explain'>💡 점화식: dp[i]=dp[i-1]+dp[i-2]. 피보나치와 같은 구조! 'i번째 칸에 도달하는 방법 = (i-1에서 1칸) + (i-2에서 2칸)'.</div>" },
            { n: 4, t: "DP: 0/1 배낭 문제", d: 5, q: "무게 제한 <strong>7</strong>인 배낭에 물건을 넣어 가치 최대화.<div class='code-block'><span class='cm'>// 물건: (무게,가치) = (2,3),(3,4),(4,5),(5,6)</span><br><span class='type'>int</span> w[]={<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>4</span>,<span class='num'>5</span>},v[]={<span class='num'>3</span>,<span class='num'>4</span>,<span class='num'>5</span>,<span class='num'>6</span>};<br><span class='type'>int</span> dp[<span class='num'>8</span>]={<span class='num'>0</span>}; <span class='cm'>// dp[j]=무게 j까지의 최대 가치</span><br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>4</span>;i++)<br>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>7</span>;j>=w[i];j--)<br>        <span class='kw'>if</span>(dp[j-w[i]]+v[i]>dp[j]) dp[j]=dp[j-w[i]]+v[i];<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,dp[<span class='num'>7</span>]);</div>", a: "<span class='key'>출력</span> <code>9</code> (물건0+물건2: 무게6, 가치3+5=8... 최적: 물건1+물건2=무게7, 가치9)<br><span class='step'>핵심</span><div class='trace'>j를 역순(7→w[i])으로 순회: 각 물건을 1번만 사용!<br>dp[j] = max(dp[j], dp[j-w[i]]+v[i])</div><div class='explain'>💡 <strong>0/1 배낭</strong>: 각 물건을 '넣거나/안 넣거나'. 역순 순회로 중복 사용 방지! 자원 배분, 투자 최적화의 기본 모델.</div>" },
            { n: 5, t: "BFS: 최단 거리", d: 4, q: "그래프에서 <strong>BFS 최단 거리</strong>. 0에서 각 노드까지 거리는?<div class='code-block'><span class='cm'>// 그래프: 0-1, 0-2, 1-3, 2-3, 2-4</span><br><span class='type'>int</span> adj[<span class='num'>5</span>][<span class='num'>5</span>]={{<span class='num'>0</span>,<span class='num'>1</span>,<span class='num'>1</span>,<span class='num'>0</span>,<span class='num'>0</span>},{<span class='num'>1</span>,<span class='num'>0</span>,<span class='num'>0</span>,<span class='num'>1</span>,<span class='num'>0</span>},<br>{<span class='num'>1</span>,<span class='num'>0</span>,<span class='num'>0</span>,<span class='num'>1</span>,<span class='num'>1</span>},{<span class='num'>0</span>,<span class='num'>1</span>,<span class='num'>1</span>,<span class='num'>0</span>,<span class='num'>0</span>},{<span class='num'>0</span>,<span class='num'>0</span>,<span class='num'>1</span>,<span class='num'>0</span>,<span class='num'>0</span>}};<br><span class='type'>int</span> dist[<span class='num'>5</span>]; <span class='fn'>memset</span>(dist,-<span class='num'>1</span>,<span class='kw'>sizeof</span>(dist));<br>dist[<span class='num'>0</span>]=<span class='num'>0</span>; <span class='cm'>// 시작점</span><br><span class='cm'>// BFS 큐 처리 후...</span></div>", a: "<span class='key'>결과</span> dist = {0, 1, 1, 2, 2}<br><span class='step'>BFS 추적</span><div class='trace'>큐: [0] → dist[0]=0<br>0의 이웃 1,2 → dist[1]=<span class='val'>1</span>, dist[2]=<span class='val'>1</span><br>큐: [1,2]<br>1의 이웃 3 → dist[3]=<span class='val'>2</span><br>2의 이웃 4 → dist[4]=<span class='val'>2</span></div><div class='explain'>💡 <strong>BFS = 최단 거리</strong>! 가까운 노드부터 방문하므로 처음 도달한 거리가 최단. 미로 찾기, 네비게이션의 핵심!</div>" },
            { n: 6, t: "DFS: 깊이 우선 탐색", d: 3, q: "DFS로 그래프 탐색. <strong>방문 순서</strong>는?<div class='code-block'><span class='type'>int</span> visited[<span class='num'>5</span>]={<span class='num'>0</span>};<br><span class='cm'>// adj: 0-1, 0-2, 1-3, 2-4</span><br><span class='type'>void</span> <span class='fn'>dfs</span>(<span class='type'>int</span> v){<br>    visited[v]=<span class='num'>1</span>;<br>    <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,v);<br>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>5</span>;i++)<br>        <span class='kw'>if</span>(adj[v][i]&&!visited[i]) <span class='fn'>dfs</span>(i);<br>}<br><span class='fn'>dfs</span>(<span class='num'>0</span>);</div>", a: "<span class='key'>출력</span> <code>0 1 3 2 4</code><br><span class='step'>추적</span><div class='trace'>dfs(0): 방문 0, 이웃 1→dfs(1)<br>  dfs(1): 방문 1, 이웃 3→dfs(3)<br>    dfs(3): 방문 3, 이웃 없음(1은 방문됨)→복귀<br>  이웃 2→dfs(2)<br>  dfs(2): 방문 2, 이웃 4→dfs(4)<br>    dfs(4): 방문 4→복귀</div><div class='explain'>💡 <strong>DFS</strong>: 갈 수 있는 데까지 깊이 들어가고, 막히면 되돌아오기! 재귀=스택. 연결 요소 찾기, 사이클 검출에 사용.</div>" },
            { n: 7, t: "DP: LCS (최장 공통 부분수열)", d: 5, q: "\"ABCBD\"와 \"BDCAB\"의 <strong>LCS 길이</strong>는?<div class='code-block'><span class='type'>char</span> a[]=<span class='str'>\"ABCBD\"</span>,b[]=<span class='str'>\"BDCAB\"</span>;<br><span class='type'>int</span> dp[<span class='num'>6</span>][<span class='num'>6</span>]={{<span class='num'>0</span>}};<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>5</span>;i++)<br>  <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>1</span>;j<=<span class='num'>5</span>;j++)<br>    dp[i][j]=(a[i-<span class='num'>1</span>]==b[j-<span class='num'>1</span>])?dp[i-<span class='num'>1</span>][j-<span class='num'>1</span>]+<span class='num'>1</span><br>           :(dp[i-<span class='num'>1</span>][j]>dp[i][j-<span class='num'>1</span>]?dp[i-<span class='num'>1</span>][j]:dp[i][j-<span class='num'>1</span>]);<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,dp[<span class='num'>5</span>][<span class='num'>5</span>]);</div>", a: "<span class='key'>출력</span> <code>3</code> (LCS: \"BCB\" 또는 \"BCA\" 등)<br><span class='step'>점화식</span><div class='trace'>a[i]==b[j] → dp[i][j]=dp[i-1][j-1]+1 (둘 다 포함)<br>a[i]≠b[j] → dp[i][j]=max(dp[i-1][j],dp[i][j-1])</div><div class='explain'>💡 <strong>LCS</strong>: 두 문자열의 공통 부분수열 중 가장 긴 것! DNA 서열 비교, 파일 diff 알고리즘의 기초. 2D DP 테이블의 대표 문제.</div>" },
            { n: 8, t: "위상 정렬", d: 4, q: "DAG에서 <strong>의존성 순서</strong>대로 실행. 순서는?<div class='code-block'><span class='cm'>// 의존 관계: A→B, A→C, B→D, C→D</span><br><span class='cm'>// 진입차수: A=0, B=1, C=1, D=2</span><br><span class='cm'>// 진입차수 0인 것부터 큐에 넣기</span><br><span class='cm'>// 큐: [A] → A처리, B,C 진입차수 감소</span><br><span class='cm'>// 큐: [B,C] → B처리 → D 진입차수 감소</span><br><span class='cm'>// 큐: [C] → C처리 → D 진입차수 0</span><br><span class='cm'>// 큐: [D] → D처리</span></div>", a: "<span class='key'>순서</span> A → B → C → D (또는 A→C→B→D)<br><span class='step'>원리</span><div class='trace'>① 진입차수 0인 노드를 큐에 넣기<br>② 큐에서 꺼내 처리, 후속 노드의 진입차수 감소<br>③ 진입차수 0이면 큐에 추가<br>④ 큐가 빌 때까지 반복</div><div class='explain'>💡 <strong>위상 정렬</strong>: 선후 관계가 있는 작업의 실행 순서! 대학 수강 순서, 빌드 시스템, 작업 스케줄링에 사용.</div>" },
            { n: 9, t: "분할 정복: 최대 부분 배열", d: 4, q: "배열의 <strong>연속 부분 배열 최대 합</strong>. 카데인 알고리즘.<div class='code-block'><span class='type'>int</span> a[]={-<span class='num'>2</span>,<span class='num'>1</span>,-<span class='num'>3</span>,<span class='num'>4</span>,-<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>1</span>,-<span class='num'>5</span>,<span class='num'>4</span>};<br><span class='type'>int</span> cur=a[<span class='num'>0</span>],best=a[<span class='num'>0</span>];<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>9</span>;i++){<br>    cur=(a[i]>cur+a[i])?a[i]:cur+a[i];<br>    <span class='kw'>if</span>(cur>best) best=cur;<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,best);</div>", a: "<span class='key'>출력</span> <code>6</code> (부분 배열: [4,-1,2,1])<br><span class='step'>카데인 추적</span><div class='trace'>i=0: cur=-2, best=-2<br>i=1: max(1,-2+1=−1)→cur=1, best=1<br>i=2: max(-3,1-3=−2)→cur=-2<br>i=3: max(4,-2+4=2)→cur=4, best=4<br>i=4: cur=4-1=3<br>i=5: cur=3+2=5, best=5<br>i=6: cur=5+1=<span class='val'>6</span>, best=<span class='val'>6</span><br>i=7: cur=6-5=1<br>i=8: cur=1+4=5</div><div class='explain'>💡 <strong>카데인 알고리즘</strong>: O(n)에 최대 부분 배열 합! 핵심: 현재 합이 음수면 버리고 새로 시작. 주식 최대 수익 문제와 같은 구조!</div>" },
            { n: 10, t: "N-Queen 백트래킹", d: 5, q: "4×4 체스판에 <strong>4개 퀸</strong>을 서로 공격 못 하게 배치. 해의 수는?<div class='code-block'><span class='type'>int</span> col[<span class='num'>4</span>],cnt=<span class='num'>0</span>;<br><span class='type'>int</span> <span class='fn'>safe</span>(<span class='type'>int</span> r,<span class='type'>int</span> c){<br>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;r;i++)<br>        <span class='kw'>if</span>(col[i]==c||col[i]-i==c-r||col[i]+i==c+r) <span class='kw'>return</span> <span class='num'>0</span>;<br>    <span class='kw'>return</span> <span class='num'>1</span>;<br>}<br><span class='type'>void</span> <span class='fn'>solve</span>(<span class='type'>int</span> r){<br>    <span class='kw'>if</span>(r==<span class='num'>4</span>){cnt++;<span class='kw'>return</span>;}<br>    <span class='kw'>for</span>(<span class='type'>int</span> c=<span class='num'>0</span>;c&lt;<span class='num'>4</span>;c++)<br>        <span class='kw'>if</span>(<span class='fn'>safe</span>(r,c)){col[r]=c;<span class='fn'>solve</span>(r+<span class='num'>1</span>);}<br>}</div>", a: "<span class='key'>답</span> <code>2</code> (4-Queen의 해는 2개)<br><span class='step'>해</span><div class='trace'>해 1: col={1,3,0,2} → .Q.. / ...Q / Q... / ..Q.<br>해 2: col={2,0,3,1} → ..Q. / Q... / ...Q / .Q..</div><div class='explain'>💡 <strong>N-Queen 백트래킹</strong>: 놓기→체크→불가능하면 되돌리기! 가지치기(pruning)로 불필요한 탐색 제거. 제약 조건 만족 문제(CSP)의 대표!</div>" },
            { n: 11, t: "다익스트라 최단 경로", d: 5, q: "가중 그래프에서 <strong>최단 경로</strong> 개념. A→D 최소 비용은?<div class='code-block'><span class='cm'>// A→B:1, A→C:4, B→C:2, B→D:6, C→D:3</span><br><span class='cm'>// 다익스트라: 가장 가까운 미방문 노드부터!</span><br><span class='cm'>// dist[A]=0</span><br><span class='cm'>// A 처리: dist[B]=1, dist[C]=4</span><br><span class='cm'>// B 처리(가장 가까움): dist[C]=min(4,1+2)=3, dist[D]=7</span><br><span class='cm'>// C 처리: dist[D]=min(7,3+3)=6</span></div>", a: "<span class='key'>답</span> A→D 최소 비용 = <code>6</code> (A→B→C→D: 1+2+3)<br><span class='step'>다익스트라 원리</span><div class='trace'>① dist 배열을 ∞로 초기화, 시작점=0<br>② 가장 가까운 미방문 노드 선택<br>③ 이웃의 dist 갱신(더 짧으면 업데이트)<br>④ 모든 노드 방문까지 반복</div><div class='explain'>💡 <strong>다익스트라</strong>: 그리디+DP의 결합! 현재까지의 최단 거리를 기반으로 확장. 네비게이션의 핵심 알고리즘!</div>" },
            { n: 12, t: "DP: LIS (최장 증가 부분수열)", d: 4, q: "배열의 <strong>LIS 길이</strong>. 결과는?<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>3</span>,<span class='num'>1</span>,<span class='num'>4</span>,<span class='num'>1</span>,<span class='num'>5</span>,<span class='num'>9</span>,<span class='num'>2</span>,<span class='num'>6</span>}, n=<span class='num'>8</span>;<br><span class='type'>int</span> dp[<span class='num'>8</span>], ans=<span class='num'>1</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;n;i++){<br>    dp[i]=<span class='num'>1</span>;<br>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;i;j++)<br>        <span class='kw'>if</span>(a[j]&lt;a[i]&&dp[j]+<span class='num'>1</span>>dp[i]) dp[i]=dp[j]+<span class='num'>1</span>;<br>    <span class='kw'>if</span>(dp[i]>ans) ans=dp[i];<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,ans);</div>", a: "<span class='key'>출력</span> <code>5</code> (예: 1,4,5,9 또는 1,2,6 등... 실제 LIS: 1,4,5,9→길이4? 아닌 1,4,5,6 등)<br>실제 dp 배열:<div class='trace'>dp[0]=1 (3)<br>dp[1]=1 (1)<br>dp[2]=2 (1,4)<br>dp[3]=1 (1)<br>dp[4]=3 (1,4,5)<br>dp[5]=4 (1,4,5,9)<br>dp[6]=2 (1,2)<br>dp[7]=4 (1,4,5,6) 또는 (1,2,6): ans=<span class='val'>4</span></div><div class='explain'>💡 <strong>LIS DP</strong>: dp[i]=a[i]로 끝나는 LIS 길이. O(n²) 풀이. 이진 탐색으로 O(n log n)도 가능!</div>" },
            { n: 13, t: "플로이드-워셜", d: 5, q: "모든 쌍의 <strong>최단 거리</strong>를 한번에. 핵심 아이디어는?<div class='code-block'><span class='cm'>// 3중 반복: 경유지 k를 하나씩 추가</span><br><span class='kw'>for</span>(<span class='type'>int</span> k=<span class='num'>0</span>;k&lt;n;k++)<br>  <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;n;i++)<br>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;n;j++)<br>      <span class='kw'>if</span>(d[i][k]+d[k][j]&lt;d[i][j])<br>        d[i][j]=d[i][k]+d[k][j];</div>", a: "<span class='key'>핵심</span> d[i][j] = min(d[i][j], d[i][k]+d[k][j])<br><span class='step'>의미</span><br>• i→j 직행 vs i→k→j 경유<br>• k를 0,1,...,n-1까지 늘려가며 갱신<div class='explain'>💡 <strong>플로이드-워셜</strong>: 모든 쌍 최단 거리를 O(n³)에! 노드 수가 적을 때(≤500) 유용. 경유지를 하나씩 추가하는 아이디어가 핵심.</div>" },
            { n: 14, t: "분할 정복: 거듭제곱 행렬", d: 5, q: "행렬 거듭제곱으로 <strong>피보나치 O(log n)</strong> 계산. 원리는?<div class='code-block'><span class='cm'>// |F(n+1)| = |1 1|ⁿ × |1|</span><br><span class='cm'>// |F(n)  |   |1 0|    |0|</span><br><span class='cm'>// 행렬 거듭제곱을 빠른 거듭제곱으로!</span></div>", a: "<span class='key'>원리</span><div class='trace'>행렬 [[1,1],[1,0]]을 n번 곱하면<br>결과 행렬의 [0][0] = F(n+1), [1][0] = F(n)<br><br>빠른 거듭제곱으로 행렬을 O(log n)에 계산!</div><div class='explain'>💡 <strong>행렬 거듭제곱</strong>: 선형 점화식을 행렬로 표현→빠른 거듭제곱! F(10⁸) 같은 거대한 피보나치도 O(log n)에 계산. 경시대회 고급 기법!</div>" },
            { n: 15, t: "유니온-파인드", d: 4, q: "집합의 <strong>합치기+찾기</strong> 연산. 결과는?<div class='code-block'><span class='type'>int</span> parent[<span class='num'>5</span>]={<span class='num'>0</span>,<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>4</span>};<br><span class='type'>int</span> <span class='fn'>find</span>(<span class='type'>int</span> x){<span class='kw'>return</span> parent[x]==x?x:(parent[x]=<span class='fn'>find</span>(parent[x]));}<br><span class='type'>void</span> <span class='fn'>unite</span>(<span class='type'>int</span> a,<span class='type'>int</span> b){parent[<span class='fn'>find</span>(a)]=<span class='fn'>find</span>(b);}<br><span class='fn'>unite</span>(<span class='num'>0</span>,<span class='num'>1</span>); <span class='fn'>unite</span>(<span class='num'>2</span>,<span class='num'>3</span>); <span class='fn'>unite</span>(<span class='num'>1</span>,<span class='num'>3</span>);<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,<span class='fn'>find</span>(<span class='num'>0</span>)==<span class='fn'>find</span>(<span class='num'>3</span>));</div>", a: "<span class='key'>출력</span> <code>1</code> (같은 집합!)<div class='trace'>초기: {0},{1},{2},{3},{4}<br>unite(0,1): parent[0]=1 → {0,1}<br>unite(2,3): parent[2]=3 → {2,3}<br>unite(1,3): find(1)=1, find(3)=3 → parent[1]=3<br>→ {0,1,2,3} 하나의 집합!<br>find(0)==find(3) → 3==3 → <span class='val'>true</span></div><div class='explain'>💡 <strong>유니온-파인드</strong>: 경로 압축으로 거의 O(1)! 네트워크 연결 확인, 크루스칼 MST의 핵심 자료구조.</div>" },
            { n: 16, t: "DP: 편집 거리", d: 5, q: "\"kitten\"→\"sitting\" 변환 <strong>최소 편집 횟수</strong>. 3가지 연산: 삽입/삭제/교체.<div class='code-block'><span class='cm'>// dp[i][j] = a의 앞 i글자 → b의 앞 j글자 최소 편집</span><br><span class='cm'>// a[i]==b[j] → dp[i][j]=dp[i-1][j-1]</span><br><span class='cm'>// 다르면 → min(dp[i-1][j-1]+1, dp[i-1][j]+1, dp[i][j-1]+1)</span></div>", a: "<span class='key'>답</span> <code>3</code><br><span class='step'>변환 과정</span><div class='trace'>kitten → sitten (k→s 교체)<br>sitten → sittin (e→i 교체)<br>sittin → sitting (g 삽입)<br>최소 3회!</div><div class='explain'>💡 <strong>편집 거리(Levenshtein Distance)</strong>: 맞춤법 교정, DNA 비교의 핵심! 2D DP 테이블로 O(mn)에 계산. 실생활에서 가장 많이 쓰이는 DP 중 하나!</div>" },
            { n: 17, t: "세그먼트 트리 개념", d: 5, q: "배열의 <strong>구간 합</strong>을 빠르게 구하는 자료구조.<div class='code-block'><span class='cm'>// 배열: [2,4,1,3,5]</span><br><span class='cm'>// 세그먼트 트리:</span><br><span class='cm'>//        [15]      ← 전체 합</span><br><span class='cm'>//    [7]    [8]   ← 왼쪽/오른쪽 반</span><br><span class='cm'>//  [6] [1] [3] [5]</span><br><span class='cm'>//  [2][4]         ← 리프 노드</span></div>", a: "<span class='key'>시간 복잡도</span><br>구간 합 쿼리: O(log n)<br>값 업데이트: O(log n)<br>단순 배열: 쿼리 O(n), 업데이트 O(1)<div class='explain'>💡 <strong>세그먼트 트리</strong>: 구간 연산(합, 최소, 최대)을 O(log n)에! 대회 필수 자료구조. 트리의 각 노드가 구간의 결과를 미리 저장.</div>" },
            { n: 18, t: "투 포인터: 부분 배열 합", d: 4, q: "연속 부분 배열의 <strong>합이 S 이상인 최소 길이</strong>.<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>4</span>,<span class='num'>3</span>}, S=<span class='num'>7</span>;<br><span class='type'>int</span> l=<span class='num'>0</span>,sum=<span class='num'>0</span>,ans=<span class='num'>7</span>; <span class='cm'>// 7=최대+1</span><br><span class='kw'>for</span>(<span class='type'>int</span> r=<span class='num'>0</span>;r&lt;<span class='num'>6</span>;r++){<br>    sum+=a[r];<br>    <span class='kw'>while</span>(sum>=S){<br>        <span class='kw'>if</span>(r-l+<span class='num'>1</span>&lt;ans) ans=r-l+<span class='num'>1</span>;<br>        sum-=a[l++];<br>    }<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,ans);</div>", a: "<span class='key'>출력</span> <code>2</code> (부분 배열 [4,3])<div class='trace'>r=3: sum=8≥7 → ans=4, l++, sum=6<br>r=4: sum=10≥7 → ans=3, l++→sum=7≥7 → ans=<span class='val'>2</span>, l++<br>sum=4<br>r=5: sum=7≥7 → ans=2(유지)</div><div class='explain'>💡 <strong>투 포인터 슬라이딩</strong>: 오른쪽을 넓히고, 조건 만족하면 왼쪽을 줄이기! O(n)에 최소 길이 부분 배열 찾기.</div>" },
            { n: 19, t: "이진 탐색 응용: 매개변수 탐색", d: 4, q: "조건을 만족하는 <strong>최소/최대값</strong>을 이진 탐색으로. 구간 [1,100]에서 x²≥50인 최소 x는?<div class='code-block'><span class='type'>int</span> lo=<span class='num'>1</span>,hi=<span class='num'>100</span>,ans=<span class='num'>100</span>;<br><span class='kw'>while</span>(lo<=hi){<br>    <span class='type'>int</span> mid=(lo+hi)/<span class='num'>2</span>;<br>    <span class='kw'>if</span>((<span class='type'>long long</span>)mid*mid>=<span class='num'>50</span>){ans=mid;hi=mid-<span class='num'>1</span>;}<br>    <span class='kw'>else</span> lo=mid+<span class='num'>1</span>;<br>}</div>", a: "<span class='key'>답</span> <code>8</code> (8²=64≥50, 7²=49<50)<div class='trace'>lo=1,hi=100→mid=50: 2500≥50→ans=50,hi=49<br>lo=1,hi=49→mid=25: 625≥50→ans=25,hi=24<br>...점점 좁혀서...<br>lo=8,hi=8→mid=8: 64≥50→ans=<span class='val'>8</span>,hi=7→종료</div><div class='explain'>💡 <strong>매개변수 탐색</strong>: '답을 이진 탐색'! 조건의 경계값을 O(log range)에 찾기. 최적화 문제를 결정 문제로 변환하는 강력한 기법!</div>" },
            { n: 20, t: "🏆 알고리즘 설계 마스터 정리", d: 5, q: "고급 알고리즘 설계 전략을 <strong>분류</strong>하고, 각각의 적용 상황을 설명하세요.", a: "<span class='key'>고급 설계 전략 분류</span><div class='trace'>🔷 동적 프로그래밍 (DP)<br>  • 중복 부분 문제 + 최적 부분 구조<br>  • 메모이제이션(Top-Down) / 타뷸레이션(Bottom-Up)<br>  • 배낭, LCS, LIS, 편집거리<br><br>🔷 그래프 알고리즘<br>  • BFS: 최단 거리(비가중), 레벨 탐색<br>  • DFS: 연결 요소, 사이클 검출<br>  • 다익스트라: 가중 그래프 최단 경로<br>  • 플로이드: 모든 쌍 최단 경로<br><br>🔷 고급 자료구조<br>  • 유니온파인드: 집합 관리<br>  • 세그먼트 트리: 구간 쿼리<br><br>🔷 탐색 최적화<br>  • 매개변수 탐색: 답을 이진 탐색<br>  • 백트래킹+가지치기: 조합 탐색</div><div class='explain'>💡 알고리즘 설계의 궁극 목표: <strong>올바르고 효율적인 해법</strong>! 문제를 보고 '어떤 전략이 맞을까?'를 판단하는 눈을 키우는 것이 핵심 역량입니다.</div>" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => { const dc = p.d <= 3 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 코드 또는 답을 작성하세요"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>