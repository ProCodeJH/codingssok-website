<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💻 패턴인식 → C언어 (보통) — 복합 패턴과 배열 패턴</title>
    <link rel="stylesheet" href="ct_c.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>💻 패턴인식(Pattern Recognition) → C언어</h1>
            <div class="sub">보통 · 복합 패턴과 배열 패턴</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span></span></div>
            <div class="meta"><span class="tag pri"
                    style="background:rgba(16,185,129,.1);border-color:rgba(16,185,129,.3);color:#10b981">🔍
                    패턴인식</span><span class="tag warn">🟡 보통</span><span class="tag acc">📝 20문제</span><span
                    class="tag">⏱ 50~70분</span></div>
        </div>
        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>
        <div class="learn">
            <h2><span class="ico" style="background:rgba(16,185,129,.15)">🔍</span> 보통 난이도 안내</h2>
            <p>이중 반복문, 배열 탐색, 문자열 처리에서 <strong>복합 패턴</strong>을 발견합니다. 쉬움에서 배운 기본 패턴들을 <strong>조합하고 확장</strong>해요!</p>
            <div class="tip">💡 복합 패턴 = 기본 패턴의 조합. 레고 블록처럼 기본을 쌓으면 복잡한 것도 만들 수 있어요!</div>
        </div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p>
            <button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p>
                <button class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg">
            <a href="패턴인식_C언어_쉬움.html">← 쉬움</a>
            <span class="tag active">보통</span>
            <a href="패턴인식_C언어_어려움.html">어려움 →</a>
        </div>
        <div class="ft">💻 CT → C언어 · 패턴인식(Pattern Recognition) · 보통 20문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "다이아몬드 패턴", d: 2, q: "출력 결과를 쓰세요. (공백 포함!)<div class='code-block'><span class='ln'>1</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>3</span>;i++){<br><span class='ln'>2</span>    <span class='kw'>for</span>(<span class='type'>int</span> s=<span class='num'>0</span>;s&lt;<span class='num'>3</span>-i;s++) <span class='fn'>printf</span>(<span class='str'>\" \"</span>);<br><span class='ln'>3</span>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;<span class='num'>2</span>*i-<span class='num'>1</span>;j++) <span class='fn'>printf</span>(<span class='str'>\"*\"</span>);<br><span class='ln'>4</span>    <span class='fn'>printf</span>(<span class='str'>\"\\n\"</span>);<br><span class='ln'>5</span>}</div>", a: "<span class='key'>출력</span><div class='trace'>  *<br> ***<br>*****</div><span class='step'>패턴 분석</span><br>i=1: 공백 2 + 별 1 (2×1-1)<br>i=2: 공백 1 + 별 3 (2×2-1)<br>i=3: 공백 0 + 별 5 (2×3-1)<br>공백 = 3-i, 별 = 2i-1<br><div class='explain'>💡 피라미드 패턴: 공백이 줄고 별이 늘어요! 공백과 별의 수를 i에 대한 <strong>수식</strong>으로 표현하면 패턴이 보입니다.</div>" },
            { n: 2, t: "모래시계 패턴", d: 2, q: "위 삼각형 + 아래 삼각형 = 모래시계! 빈칸을 채우세요.<div class='code-block'><span class='cm'>// 위쪽: 별이 줄어드는 패턴</span><br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>3</span>;i>=<span class='num'>1</span>;i--){<br>    <span class='kw'>for</span>(<span class='type'>int</span> s=<span class='num'>0</span>;s&lt;<span class='num'>3</span>-i;s++) <span class='fn'>printf</span>(<span class='str'>\" \"</span>);<br>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;<span class='num'>2</span>*i-<span class='num'>1</span>;j++) <span class='fn'>printf</span>(<span class='str'>\"*\"</span>);<br>    <span class='fn'>printf</span>(<span class='str'>\"\\n\"</span>);<br>}<br><span class='cm'>// 아래쪽: 별이 늘어나는 패턴</span><br><span class='kw'>for</span>(<span class='type'>int</span> i=______;i<=______;i++){<br>    <span class='cm'>// 같은 구조!</span><br>}</div>", a: "<span class='key'>정답</span> <code>i=2; i<=3</code><br><span class='key'>출력</span><div class='trace'>*****<br> ***<br>  *<br> ***<br>*****</div><div class='explain'>💡 모래시계 = <strong>감소 삼각형 + 증가 삼각형</strong>! 두 번째 for는 i=2부터 (i=1은 꼭짓점, 이미 출력됨). 복잡한 패턴도 <strong>대칭 구조로 분해</strong>!</div>" },
            { n: 3, t: "체스판 패턴", d: 2, q: "체스판처럼 0과 1이 교대하는 4×4 출력을 쓰세요.<div class='code-block'><span class='ln'>1</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>4</span>;i++){<br><span class='ln'>2</span>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;<span class='num'>4</span>;j++)<br><span class='ln'>3</span>        <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,(i+j)%<span class='num'>2</span>);<br><span class='ln'>4</span>    <span class='fn'>printf</span>(<span class='str'>\"\\n\"</span>);<br><span class='ln'>5</span>}</div>", a: "<span class='key'>출력</span><div class='trace'>0 1 0 1<br>1 0 1 0<br>0 1 0 1<br>1 0 1 0</div><span class='step'>패턴</span> (i+j)%2 → i+j가 짝수면 0, 홀수면 1!<br><div class='trace'>i=0: (0+0)%2=0, (0+1)%2=1, (0+2)%2=0, (0+3)%2=1<br>i=1: (1+0)%2=1, (1+1)%2=0, (1+2)%2=1, (1+3)%2=0</div><div class='explain'>💡 <code>(i+j)%2</code>는 체스판 패턴의 수학적 공식! 행+열의 합이 짝수면 흰칸, 홀수면 검은 칸. 2D 좌표를 이용한 패턴!</div>" },
            { n: 4, t: "피보나치 패턴", d: 2, q: "피보나치 수열을 반복문으로 구현. 출력을 쓰세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a=<span class='num'>0</span>, b=<span class='num'>1</span>;<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>8</span>;i++){<br><span class='ln'>3</span>    <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,a);<br><span class='ln'>4</span>    <span class='type'>int</span> t=a+b; a=b; b=t;<br><span class='ln'>5</span>}</div>", a: "<span class='key'>출력</span> <code>0 1 1 2 3 5 8 13</code><br><span class='step'>추적</span><div class='trace'>i=0: 출력 0, t=0+1=1, a=1, b=1<br>i=1: 출력 1, t=1+1=2, a=1, b=2<br>i=2: 출력 1, t=1+2=3, a=2, b=3<br>i=3: 출력 2, t=2+3=5, a=3, b=5<br>i=4: 출력 3, t=3+5=8, a=5, b=8<br>i=5: 출력 5, t=5+8=13, a=8, b=13<br>i=6: 출력 8...<br>i=7: 출력 13...</div><div class='explain'>💡 피보나치 패턴: <strong>앞 두 수의 합 = 다음 수</strong>! 변수 3개(a, b, t)로 '슬라이딩 윈도우'처럼 이동하는 패턴. 자연계에서도 나타나는 유명한 수열!</div>" },
            { n: 5, t: "문자열 대소문자 패턴", d: 2, q: "대문자↔소문자 변환 패턴. 빈칸을 채우세요.<div class='code-block'><span class='ln'>1</span><span class='type'>void</span> <span class='fn'>toLower</span>(<span class='type'>char</span> s[]) {<br><span class='ln'>2</span>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>; s[i]; i++)<br><span class='ln'>3</span>        <span class='kw'>if</span>(s[i]>=<span class='str'>'A'</span> && s[i]<=<span class='str'>'Z'</span>)<br><span class='ln'>4</span>            s[i] += ______;<br><span class='ln'>5</span>}<br><span class='ln'>6</span><span class='cm'>// toLower(\"Hello\") → \"hello\"</span></div>", a: "<span class='key'>정답</span> <code>32</code> (또는 <code>'a'-'A'</code>)<br><span class='step'>패턴</span><div class='trace'>ASCII: A=65, a=97 → 차이 = <span class='val'>32</span><br>H(72)+32 = h(104) ✓<br>E(69)+32 = e(101) ✓<br>l(108): 이미 소문자 → skip<br>l(108): skip<br>o(111): skip</div><div class='explain'>💡 대소문자 변환 패턴: 항상 <strong>+32/-32</strong>! 이것은 ASCII 코드 테이블에서 대문자와 소문자의 고정 차이. 규칙만 알면 라이브러리 없이 변환 가능!</div>" },
            { n: 6, t: "팰린드롬 검사 패턴", d: 2, q: "문자열이 <strong>앞뒤 대칭(팰린드롬)</strong>인지 확인. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>isPalindrome</span>(<span class='type'>char</span> s[], <span class='type'>int</span> len) {<br><span class='ln'>2</span>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>; i&lt;len/<span class='num'>2</span>; i++)<br><span class='ln'>3</span>        <span class='kw'>if</span>(s[i] != s[len-<span class='num'>1</span>-i]) <span class='kw'>return</span> <span class='num'>0</span>;<br><span class='ln'>4</span>    <span class='kw'>return</span> <span class='num'>1</span>;<br><span class='ln'>5</span>}<br><span class='ln'>6</span><span class='cm'>// isPalindrome(\"level\",5) → ?</span><br><span class='ln'>7</span><span class='cm'>// isPalindrome(\"hello\",5) → ?</span></div>", a: "<span class='key'>정답</span> \"level\" → <strong>1</strong>(팰린드롬!), \"hello\" → <strong>0</strong><br><span class='step'>추적 \"level\"</span><div class='trace'>i=0: s[0]='l' == s[4]='l' ✓<br>i=1: s[1]='e' == s[3]='e' ✓<br>i=2: 2 < 2? 아니오 → 종료<br>return <span class='val'>1</span></div><span class='step'>추적 \"hello\"</span><div class='trace'>i=0: s[0]='h' == s[4]='o'? <span class='val'>✗ return 0</span></div><div class='explain'>💡 <strong>거울 패턴</strong>: s[i]와 s[len-1-i]를 비교! 문자열 뒤집기(분해 Level 2)와 같은 인덱스 패턴이에요.</div>" },
            { n: 7, t: "두 포인터 패턴", d: 2, q: "정렬된 배열에서 합이 target인 <strong>두 수</strong>를 찾기. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>5</span>,<span class='num'>7</span>,<span class='num'>9</span>};<br><span class='ln'>2</span><span class='type'>int</span> lo=<span class='num'>0</span>, hi=<span class='num'>4</span>, target=<span class='num'>8</span>;<br><span class='ln'>3</span><span class='kw'>while</span>(lo&lt;hi){<br><span class='ln'>4</span>    <span class='type'>int</span> sum=a[lo]+a[hi];<br><span class='ln'>5</span>    <span class='kw'>if</span>(sum==target) {<span class='fn'>printf</span>(<span class='str'>\"%d+%d\"</span>,a[lo],a[hi]); <span class='kw'>break</span>;}<br><span class='ln'>6</span>    <span class='kw'>else if</span>(sum&lt;target) lo++;<br><span class='ln'>7</span>    <span class='kw'>else</span> hi--;<br><span class='ln'>8</span>}</div>", a: "<span class='key'>출력</span> <code>1+7</code><br><span class='step'>추적</span><div class='trace'>lo=0, hi=4: a[0]+a[4]=1+9=10 > 8 → hi--<br>lo=0, hi=3: a[0]+a[3]=1+7=<span class='val'>8</span> == target → 출력 → break!</div><div class='explain'>💡 <strong>두 포인터 패턴</strong>: 양 끝에서 시작해서 중앙으로 좁혀가기! 합이 크면 hi를 줄이고, 작으면 lo를 올려요. O(n)에 해결! 이진 탐색과 함께 정렬 배열의 핵심 패턴.</div>" },
            { n: 8, t: "슬라이딩 윈도우 패턴", d: 2, q: "연속 3개 원소의 합 중 최대값. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>2</span>,<span class='num'>1</span>,<span class='num'>5</span>,<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>2</span>};<br><span class='ln'>2</span><span class='type'>int</span> sum=a[<span class='num'>0</span>]+a[<span class='num'>1</span>]+a[<span class='num'>2</span>], max=sum;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>3</span>;i&lt;<span class='num'>6</span>;i++){<br><span class='ln'>4</span>    sum += a[i] - a[i-<span class='num'>3</span>];<br><span class='ln'>5</span>    <span class='kw'>if</span>(sum>max) max=sum;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,max);</div>", a: "<span class='key'>출력</span> <code>9</code><br><span class='step'>추적</span><div class='trace'>초기: sum=2+1+5=<span class='val'>8</span>, max=8<br>i=3: sum=8+a[3]-a[0]=8+1-2=<span class='val'>7</span> (max 유지: 8)<br>i=4: sum=7+a[4]-a[1]=7+3-1=<span class='val'>9</span> (max=<span class='val'>9</span>!)<br>i=5: sum=9+a[5]-a[2]=9+2-5=<span class='val'>6</span> (max 유지: 9)</div><div class='explain'>💡 <strong>슬라이딩 윈도우</strong>: 새 원소 추가 + 오래된 원소 제거! 매번 3개를 다시 더하는 대신 +/- 하나씩만 하므로 O(n)으로 해결. 연속 구간 문제의 핵심 패턴!</div>" },
            { n: 9, t: "빈도수 세기 패턴", d: 2, q: "알파벳 빈도 카운팅. 가장 많은 문자는?<div class='code-block'><span class='ln'>1</span><span class='type'>char</span> s[]= <span class='str'>\"banana\"</span>;<br><span class='ln'>2</span><span class='type'>int</span> freq[<span class='num'>26</span>]={<span class='num'>0</span>};<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;s[i];i++)<br><span class='ln'>4</span>    freq[s[i]-<span class='str'>'a'</span>]++;<br><span class='ln'>5</span><span class='cm'>// freq[0]=? freq[1]=? freq[13]=?</span></div>", a: "<span class='key'>정답</span> freq[0]=3(a), freq[1]=1(b), freq[13]=2(n)<br><span class='step'>추적</span> \"banana\":<div class='trace'>b: 'b'-'a'=1 → freq[1]++  → freq[1]=<span class='val'>1</span><br>a: 'a'-'a'=0 → freq[0]++  → freq[0]=<span class='val'>1</span><br>n: 'n'-'a'=13 → freq[13]++ → freq[13]=<span class='val'>1</span><br>a: freq[0]++ → freq[0]=<span class='val'>2</span><br>n: freq[13]++ → freq[13]=<span class='val'>2</span><br>a: freq[0]++ → freq[0]=<span class='val'>3</span></div><div class='explain'>💡 <strong>빈도수 패턴</strong>: <code>s[i]-'a'</code>로 문자를 인덱스(0~25)로 변환! 26칸 배열 하나로 모든 알파벳 빈도를 셀 수 있어요. 이 패턴은 해시 맵의 기초!</div>" },
            { n: 10, t: "정렬 패턴 비교", d: 2, q: "버블정렬과 선택정렬의 <strong>공통 패턴</strong>을 찾으세요.<div class='code-block'><span class='cm'>// 버블정렬</span><br><span class='kw'>for</span>(i=<span class='num'>0</span>;i&lt;n-<span class='num'>1</span>;i++)<br>  <span class='kw'>for</span>(j=<span class='num'>0</span>;j&lt;n-<span class='num'>1</span>-i;j++)<br>    <span class='kw'>if</span>(a[j]>a[j+<span class='num'>1</span>]) swap(&a[j],&a[j+<span class='num'>1</span>]);<br><br><span class='cm'>// 선택정렬</span><br><span class='kw'>for</span>(i=<span class='num'>0</span>;i&lt;n-<span class='num'>1</span>;i++){<br>  min=i;<br>  <span class='kw'>for</span>(j=i+<span class='num'>1</span>;j&lt;n;j++)<br>    <span class='kw'>if</span>(a[j]&lt;a[min]) min=j;<br>  swap(&a[i],&a[min]);<br>}</div>", a: "<span class='key'>공통 패턴</span><br>① 이중 for문 (바깥=패스, 안쪽=비교)<br>② 비교(if)로 대소 판단<br>③ swap으로 교환<br>④ n-1번 반복하면 정렬 완료<br><span class='step'>차이점</span><br>• 버블: <strong>인접한 둘</strong>을 비교/교환 → 큰 것이 뒤로<br>• 선택: <strong>최솟값을 찾아</strong> 앞으로 → 작은 것이 앞으로<br><div class='explain'>💡 정렬 알고리즘들의 공통 패턴: <strong>비교 + 교환 + 반복</strong>! '무엇을 비교'하고 '언제 교환'하느냐만 달라요. 패턴을 알면 새로운 정렬도 만들 수 있어요!</div>" },
            { n: 11, t: "수열 패턴 예측", d: 2, q: "출력 결과를 쓰고, <strong>숨겨진 수학 공식</strong>을 찾으세요.<div class='code-block'><span class='ln'>1</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>5</span>;i++)<br><span class='ln'>2</span>    <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,i*(i+<span class='num'>1</span>)/<span class='num'>2</span>);</div>", a: "<span class='key'>출력</span> <code>1 3 6 10 15</code><br><span class='step'>패턴</span> 삼각수! (삼각형 모양으로 쌓는 수)<br><div class='trace'>i=1: 1×2/2 = <span class='val'>1</span> (•)<br>i=2: 2×3/2 = <span class='val'>3</span> (• •)<br>i=3: 3×4/2 = <span class='val'>6</span> (• • •)<br>i=4: 4×5/2 = <span class='val'>10</span><br>i=5: 5×6/2 = <span class='val'>15</span></div>또 다른 패턴: 1, 1+2=3, 1+2+3=6, 1+2+3+4=10...<br><div class='explain'>💡 공식 n(n+1)/2 = 1부터 n까지의 합! 가우스가 10살 때 발견한 공식이에요. 패턴을 수식으로 일반화하면 반복문 없이도 답을 구할 수 있습니다!</div>" },
            { n: 12, t: "2차원 배열 패턴", d: 2, q: "2차원 배열에서 <strong>대각선 원소</strong>의 합을 구하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> m[<span class='num'>3</span>][<span class='num'>3</span>] = {{<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>},{<span class='num'>4</span>,<span class='num'>5</span>,<span class='num'>6</span>},{<span class='num'>7</span>,<span class='num'>8</span>,<span class='num'>9</span>}};<br><span class='ln'>2</span><span class='type'>int</span> sum=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>3</span>;i++) sum += m[i][i];<br><span class='ln'>4</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,sum);</div>", a: "<span class='key'>출력</span> <code>15</code><br><span class='step'>패턴</span> 대각선 = 행번호와 열번호가 같은 위치!<div class='trace'>m[0][0]=<span class='val'>1</span> + m[1][1]=<span class='val'>5</span> + m[2][2]=<span class='val'>9</span> = <span class='val'>15</span></div>반대 대각선은? m[i][n-1-i]:<br>m[0][2]=3 + m[1][1]=5 + m[2][0]=7 = 15<br><div class='explain'>💡 주대각선: <code>m[i][i]</code>, 반대각선: <code>m[i][n-1-i]</code>! 2D 좌표에서 패턴을 수식으로 표현하는 것이 핵심. 두 대각선 합이 같은 것은 마방진의 성질!</div>" },
            { n: 13, t: "do-while 패턴", d: 2, q: "자릿수 구하기의 패턴. 출력 결과를 쓰세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> n=<span class='num'>4567</span>, digits=<span class='num'>0</span>;<br><span class='ln'>2</span><span class='kw'>do</span> {<br><span class='ln'>3</span>    digits++;<br><span class='ln'>4</span>    n /= <span class='num'>10</span>;<br><span class='ln'>5</span>} <span class='kw'>while</span>(n > <span class='num'>0</span>);<br><span class='ln'>6</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>, digits);</div>", a: "<span class='key'>출력</span> <code>4</code><br><span class='step'>추적</span><div class='trace'>n=4567: digits=1, n=456<br>n=456:  digits=2, n=45<br>n=45:   digits=3, n=4<br>n=4:    digits=4, n=0<br>n=0: 조건 거짓 → 종료</div><div class='explain'>💡 <strong>자릿수 패턴</strong>: 10으로 계속 나누면 자릿수만큼 반복! n=0이 되면 종료. do-while은 최소 1번 실행을 보장하므로 n=0일 때도 digits=1이 나옴!<br>역으로 각 자릿수 추출: n%10 → 마지막 자릿수(7), n/10 → 나머지(456)</div>" },
            { n: 14, t: "자릿수 합 패턴", d: 2, q: "각 자릿수의 합을 구하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> n=<span class='num'>1234</span>, sum=<span class='num'>0</span>;<br><span class='ln'>2</span><span class='kw'>while</span>(n > <span class='num'>0</span>) {<br><span class='ln'>3</span>    sum += n % <span class='num'>10</span>;<br><span class='ln'>4</span>    n /= <span class='num'>10</span>;<br><span class='ln'>5</span>}<br><span class='ln'>6</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>, sum);</div>", a: "<span class='key'>출력</span> <code>10</code><br><span class='step'>추적</span><div class='trace'>n=1234: sum+=1234%10=<span class='val'>4</span>, n=123<br>n=123:  sum+=123%10=<span class='val'>3</span>, n=12 (sum=7)<br>n=12:   sum+=12%10=<span class='val'>2</span>, n=1 (sum=9)<br>n=1:    sum+=1%10=<span class='val'>1</span>, n=0 (sum=10)</div>검증: 1+2+3+4 = <span class='val'>10</span> ✓<br><div class='explain'>💡 <code>%10</code>과 <code>/10</code>은 자릿수 처리의 <strong>골든 패턴</strong>! %10=마지막 자릿수 추출, /10=마지막 자릿수 제거. 이 패턴으로 역순 출력, 자릿수 합, 팰린드롬 수 검사 등 가능!</div>" },
            { n: 15, t: "배열 이동 패턴", d: 2, q: "배열을 <strong>오른쪽으로 1칸 회전</strong>하는 코드. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>4</span>,<span class='num'>5</span>};<br><span class='ln'>2</span><span class='type'>int</span> last=a[<span class='num'>4</span>];<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>4</span>;i>=<span class='num'>1</span>;i--) a[i]=a[i-<span class='num'>1</span>];<br><span class='ln'>4</span>a[<span class='num'>0</span>]=last;</div>", a: "<span class='key'>결과</span> <code>{5, 1, 2, 3, 4}</code><br><span class='step'>추적</span><div class='trace'>last = a[4] = <span class='val'>5</span> (백업)<br>i=4: a[4]=a[3]=4 → {1,2,3,4,4}<br>i=3: a[3]=a[2]=3 → {1,2,3,3,4}<br>i=2: a[2]=a[1]=2 → {1,2,2,3,4}<br>i=1: a[1]=a[0]=1 → {1,1,2,3,4}<br>a[0]=last=5 → {<span class='val'>5</span>,1,2,3,4} ✓</div><div class='explain'>💡 <strong>시프트 패턴</strong>: 뒤에서부터 옮겨야 덮어쓰기 방지! 마지막 원소를 미리 백업하고, 역순으로 밀고, 백업을 첫 위치에 넣어요.</div>" },
            { n: 16, t: "중복 제거 패턴", d: 2, q: "정렬된 배열에서 <strong>중복을 제거</strong>하는 코드. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>3</span>,<span class='num'>3</span>,<span class='num'>5</span>};<br><span class='ln'>2</span><span class='type'>int</span> j=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>7</span>;i++)<br><span class='ln'>4</span>    <span class='kw'>if</span>(a[i]!=a[j]) a[++j]=a[i];<br><span class='ln'>5</span><span class='cm'>// 결과 배열(j+1개) → ?</span></div>", a: "<span class='key'>결과</span> <code>{1, 2, 3, 5}</code> (4개)<br><span class='step'>추적</span><div class='trace'>j=0 (a[0]=1)<br>i=1: a[1]=1 == a[0]=1 → skip<br>i=2: a[2]=2 != a[0]=1 → a[1]=2, j=<span class='val'>1</span><br>i=3: a[3]=3 != a[1]=2 → a[2]=3, j=<span class='val'>2</span><br>i=4: a[4]=3 == a[2]=3 → skip<br>i=5: a[5]=3 == a[2]=3 → skip<br>i=6: a[6]=5 != a[2]=3 → a[3]=5, j=<span class='val'>3</span></div><div class='explain'>💡 <strong>두 포인터(fast/slow) 패턴</strong>! j=느린 포인터(고유 원소 위치), i=빠른 포인터(전체 탐색). 이전 값과 다를 때만 느린 포인터를 전진시켜요.</div>" },
            { n: 17, t: "재귀 패턴 vs 반복", d: 2, q: "같은 결과를 내는 재귀와 반복의 패턴을 비교하세요.<div class='code-block'><span class='cm'>// 재귀 버전</span><br><span class='type'>int</span> <span class='fn'>sumR</span>(<span class='type'>int</span> n){<br>    <span class='kw'>if</span>(n==<span class='num'>0</span>) <span class='kw'>return</span> <span class='num'>0</span>;<br>    <span class='kw'>return</span> n + sumR(n-<span class='num'>1</span>);<br>}<br><br><span class='cm'>// 반복 버전</span><br><span class='type'>int</span> <span class='fn'>sumL</span>(<span class='type'>int</span> n){<br>    <span class='type'>int</span> s=<span class='num'>0</span>;<br>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=n;i++) s+=i;<br>    <span class='kw'>return</span> s;<br>}<br><span class='cm'>// sumR(5) → ? / sumL(5) → ?</span></div>", a: "<span class='key'>둘 다</span> <strong>15</strong><br><span class='step'>패턴 대응</span><div class='trace'>재귀: base case = 종료조건<br>      n + f(n-1) = 반복 본문 + 축소<br><br>반복: i<=n = 종료조건<br>      s+=i = 본문, i++ = 축소</div><div class='explain'>💡 <strong>모든 재귀는 반복으로, 반복은 재귀로</strong> 변환 가능! 패턴 구조가 같기 때문이에요. 재귀의 종료조건=반복의 조건, 재귀의 크기축소=반복의 증감.</div>" },
            { n: 18, t: "swap 패턴 모음", d: 2, q: "세 가지 swap 방법의 <strong>공통점</strong>을 설명하세요.<div class='code-block'><span class='cm'>// 방법1: 임시변수</span><br><span class='type'>int</span> t=a; a=b; b=t;<br><br><span class='cm'>// 방법2: 덧셈/뺄셈</span><br>a=a+b; b=a-b; a=a-b;<br><br><span class='cm'>// 방법3: XOR</span><br>a=a^b; b=a^b; a=a^b;</div>", a: "<span class='key'>공통점</span> 모두 3단계로 두 값을 교환!<br><span class='step'>추적</span> a=3, b=7:<div class='trace'>방법1: t=3, a=7, b=3 ✓<br><br>방법2: a=3+7=10, b=10-7=3, a=10-3=7 ✓<br><br>방법3: a=3^7=4, b=4^7=3, a=4^3=7 ✓</div><div class='explain'>💡 세 방법 모두 <strong>'정보 보존 + 3단계 교환'</strong> 패턴! 방법1은 가장 직관적, 방법2는 임시변수 불필요(오버플로 주의), 방법3은 비트 연산(가장 빠름). 같은 문제를 다르게 풀 수 있다는 것도 패턴!</div>" },
            { n: 19, t: "증감 패턴 정리", d: 2, q: "i++, ++i, i+=2, i*=2의 <strong>차이와 패턴</strong>을 정리하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a=<span class='num'>5</span>, b;<br><span class='ln'>2</span>b = a++;   <span class='cm'>// b=? a=?</span><br><span class='ln'>3</span><span class='type'>int</span> c=<span class='num'>5</span>, d;<br><span class='ln'>4</span>d = ++c;   <span class='cm'>// d=? c=?</span></div>", a: "<span class='key'>정답</span> b=<strong>5</strong>, a=<strong>6</strong> / d=<strong>6</strong>, c=<strong>6</strong><br><span class='step'>패턴</span><br>• <code>a++</code> (후위): 먼저 사용 → 그 다음 증가<br>• <code>++a</code> (전위): 먼저 증가 → 그 다음 사용<br><div class='trace'>b = a++: b에 현재값 5 대입, 그 후 a=6<br>d = ++c: c를 먼저 6으로 증가, 그 후 d에 6 대입</div><div class='explain'>💡 후위(a++)는 '나중에', 전위(++a)는 '먼저'! 스택 push(arr[++top])와 pop(arr[top--])에서 이 차이가 핵심적이에요.</div>" },
            { n: 20, t: "🏆 패턴 변환 챌린지", d: 3, q: "아래 반복문의 패턴을 찾고, <strong>수식</strong>으로 바꿔 O(1)로 풀어보세요.<div class='code-block'><span class='cm'>// 1부터 N까지의 합</span><br><span class='type'>int</span> sum=<span class='num'>0</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>100</span>;i++) sum+=i;<br><span class='cm'>// sum = ?</span><br><br><span class='cm'>// 1부터 N까지 제곱의 합</span><br><span class='type'>int</span> sq=<span class='num'>0</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>10</span>;i++) sq+=i*i;<br><span class='cm'>// sq = ?</span></div>", a: "<span class='key'>정답</span> sum=<strong>5050</strong>, sq=<strong>385</strong><br><span class='step'>수식 변환</span><div class='trace'>1~N 합: n(n+1)/2<br>  100×101/2 = <span class='val'>5050</span> ✓<br><br>1~N 제곱합: n(n+1)(2n+1)/6<br>  10×11×21/6 = <span class='val'>385</span> ✓</div><div class='explain'>💡 반복 패턴을 <strong>닫힌 공식(closed form)</strong>으로 변환하면 O(n) → O(1)! 이것이 패턴 인식의 최종 목표예요: 패턴을 발견하면 반복 없이 바로 답을 구할 수 있습니다.</div>" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => { const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 코드 또는 답을 작성하세요"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>