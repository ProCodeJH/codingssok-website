<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Unit 66. ìŠ¤íƒ Â· í Â· íŠ¸ë¦¬ â€” C ì–¸ì–´</title>
    <link rel="stylesheet" href="../common.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>Unit 66. ìŠ¤íƒ Â· í Â· íŠ¸ë¦¬</h1>
            <div class="sub">ë°°ì—´/ì—°ê²°ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜ Â· BST Â· ìˆœíšŒ</div>
            <span class="unit-badge">Chapter 22 Â· ìë£Œêµ¬ì¡°</span>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span></div>
            <div class="meta"><span class="tag pri">ğŸ“š ìë£Œêµ¬ì¡°</span><span class="tag acc">ğŸ“ 15ë¬¸ì œ</span><span
                    class="tag">â± 55ë¶„</span></div>
        </div>
        <div class="stu-bar"><label>ğŸ‘¤ ì´ë¦„ <input type="text" id="stu-name" placeholder="ì´ë¦„"></label><label>ğŸ“… ë‚ ì§œ <input
                    type="date" id="stu-date"></label></div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>ëª¨ë“  ë¬¸ì œë¥¼ í’€ì—ˆë‚˜ìš”? ğŸ“¨</p><button class="btn-submit" id="btn-submit">ğŸ“„ ì œì¶œí•˜ê¸°</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">âœ…</div>
                <h3>ì œì¶œ ì™„ë£Œ!</h3>
                <p>í•™ìŠµì§€ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">ğŸ“ <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">í™•ì¸</button>
            </div>
        </div>
        <div class="pg"><a href="Unit65_ì—°ê²°ë¦¬ìŠ¤íŠ¸.html">â† Unit 65</a><span class="tag active">Unit 66</span><a
                href="../23_ê³ ê¸‰ë§ˆìŠ¤í„°/Unit67_ë©”ëª¨ë¦¬.html">Unit 67 â†’</a></div>
        <div class="ft">ğŸ“š ìŠ¤íƒÂ·íÂ·íŠ¸ë¦¬ Â· Unit 66</div>
    </div>
    <script>
        const P = [
            {
                n: 1, t: "ë°°ì—´ ê¸°ë°˜ ìŠ¤íƒ", d: 2,
                q: `ë°°ì—´ë¡œ ìŠ¤íƒì„ êµ¬í˜„í•˜ì„¸ìš”.
<pre class="code-c">#define MAX 100
typedef struct { int data[MAX]; int top; } Stack;
void init(Stack *s) { <span class="cm">/* ? */</span> }
void push(Stack *s, int val) { <span class="cm">/* ? */</span> }
int pop(Stack *s) { <span class="cm">/* ? */</span> }
int peek(Stack *s) { <span class="cm">/* ? */</span> }
int isEmpty(Stack *s) { <span class="cm">/* ? */</span> }</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">void init(Stack *s) { s->top = -1; }
int isEmpty(Stack *s) { return s->top == -1; }
void push(Stack *s, int val) { s->data[++(s->top)] = val; }
int pop(Stack *s) { return s->data[(s->top)--]; }
int peek(Stack *s) { return s->data[s->top]; }</pre><div class="trace">top=-1: ë¹ˆ ìŠ¤íƒ<br>push: top ì¦ê°€ í›„ ì €ì¥<br>pop: ê°’ ë°˜í™˜ í›„ top ê°ì†Œ<br>LIFO: Last In First Out!</div>`},

            {
                n: 2, t: "ê´„í˜¸ ê²€ì‚¬ (ìŠ¤íƒ í™œìš©)", d: 2,
                q: `ë¬¸ìì—´ì˜ ê´„í˜¸ê°€ ì˜¬ë°”ë¥¸ì§€ ê²€ì‚¬í•˜ì„¸ìš”.
<pre class="code-c"><span class="cm">// "(())" â†’ 1 (ì˜¬ë°”ë¦„)</span>
<span class="cm">// "([)]" â†’ 0 (ì˜ëª»ë¨)</span>
<span class="cm">// "{[()]}" â†’ 1 (ì˜¬ë°”ë¦„)</span>
int isValid(char *str) {
    <span class="cm">// ìŠ¤íƒìœ¼ë¡œ ê²€ì‚¬</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">int isValid(char *str) {
    char stack[100]; int top = -1;
    for (int i = 0; str[i]; i++) {
        char c = str[i];
        if (c=='('||c=='['||c=='{') stack[++top]=c;
        else {
            if (top == -1) return 0;
            char p = stack[top--];
            if ((c==')' && p!='(') ||
                (c==']' && p!='[') ||
                (c=='}' && p!='{')) return 0;
        }
    }
    return top == -1;
}</pre>`},

            {
                n: 3, t: "í›„ìœ„ í‘œê¸°ë²• ê³„ì‚°", d: 3,
                q: `í›„ìœ„ í‘œê¸°ì‹(ì˜ˆ: "3 4 + 2 *")ì„ ê³„ì‚°í•˜ì„¸ìš”.
<pre class="code-c"><span class="cm">// "3 4 +" â†’ 7</span>
<span class="cm">// "5 1 2 + 4 * + 3 -" â†’ 14</span>
int evalPostfix(char *expr) {
    <span class="cm">// ìŠ¤íƒìœ¼ë¡œ ê³„ì‚°</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">int evalPostfix(char *expr) {
    int stack[100], top=-1;
    for (int i=0; expr[i]; i++) {
        if (expr[i]==' ') continue;
        if (expr[i]>='0' && expr[i]<='9') {
            int num = 0;
            while (expr[i]>='0' && expr[i]<='9')
                num = num*10 + (expr[i++]-'0');
            stack[++top] = num; i--;
        } else {
            int b=stack[top--], a=stack[top--];
            switch(expr[i]) {
                case '+': stack[++top]=a+b; break;
                case '-': stack[++top]=a-b; break;
                case '*': stack[++top]=a*b; break;
                case '/': stack[++top]=a/b; break;
            }
        }
    }
    return stack[0];
}</pre>`},

            {
                n: 4, t: "ë°°ì—´ ê¸°ë°˜ í", d: 2,
                q: `ë°°ì—´ë¡œ ì›í˜• íë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
<pre class="code-c">#define MAX 100
typedef struct {
    int data[MAX]; int front, rear, count;
} Queue;
void enqueue(Queue *q, int val) { <span class="cm">/* ? */</span> }
int dequeue(Queue *q) { <span class="cm">/* ? */</span> }</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">void init(Queue *q) { q->front=0; q->rear=-1; q->count=0; }
void enqueue(Queue *q, int val) {
    q->rear = (q->rear + 1) % MAX;
    q->data[q->rear] = val;
    q->count++;
}
int dequeue(Queue *q) {
    int val = q->data[q->front];
    q->front = (q->front + 1) % MAX;
    q->count--;
    return val;
}</pre><div class="trace">ì›í˜• í: % MAXë¡œ ì¸ë±ìŠ¤ ìˆœí™˜!<br>FIFO: First In, First Out</div>`},

            {
                n: 5, t: "BFS ë¯¸ë¡œ íƒìƒ‰ (í í™œìš©)", d: 3,
                q: `íë¥¼ ì´ìš©í•´ì„œ ë¯¸ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ìœ¼ì„¸ìš”.
<pre class="code-c"><span class="cm">// 0: ì´ë™ê°€ëŠ¥, 1: ë²½</span>
<span class="cm">// (0,0)ì—ì„œ (N-1,M-1)ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬</span>
int bfs(int maze[][100], int n, int m) {
    <span class="cm">// í + ë°©ë¬¸ ë°°ì—´ë¡œ BFS</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">int dx[]={0,0,1,-1}, dy[]={1,-1,0,0};
int bfs(int maze[][100], int n, int m) {
    int dist[100][100]={0}, visited[100][100]={0};
    int qx[10000],qy[10000],front=0,rear=0;
    qx[rear]=0; qy[rear++]=0; visited[0][0]=1;
    while (front < rear) {
        int x=qx[front], y=qy[front++];
        if (x==n-1 && y==m-1) return dist[x][y];
        for (int d=0;d<4;d++) {
            int nx=x+dx[d], ny=y+dy[d];
            if (nx>=0&&nx<n&&ny>=0&&ny<m&&
                !visited[nx][ny]&&!maze[nx][ny]) {
                visited[nx][ny]=1;
                dist[nx][ny]=dist[x][y]+1;
                qx[rear]=nx; qy[rear++]=ny;
            }
        }
    }
    return -1;
}</pre>`},

            {
                n: 6, t: "BST ë…¸ë“œ ì‚½ì…", d: 2,
                q: `ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì— ê°’ì„ ì‚½ì…í•˜ì„¸ìš”.
<pre class="code-c">typedef struct TNode {
    int data;
    struct TNode *left, *right;
} TNode;
TNode* insert(TNode *root, int data) {
    <span class="cm">// ì¬ê·€ë¡œ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ì‚½ì…</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">TNode* createTNode(int data) {
    TNode *n=(TNode*)malloc(sizeof(TNode));
    n->data=data; n->left=n->right=NULL;
    return n;
}
TNode* insert(TNode *root, int data) {
    if (!root) return createTNode(data);
    if (data < root->data)
        root->left = insert(root->left, data);
    else if (data > root->data)
        root->right = insert(root->right, data);
    return root;
}</pre><div class="trace">ì‘ìœ¼ë©´ ì™¼ìª½, í¬ë©´ ì˜¤ë¥¸ìª½!<br>ì¬ê·€ë¡œ ë¹ˆ ìë¦¬ê¹Œì§€ ë‚´ë ¤ê°</div>`},

            {
                n: 7, t: "BST íƒìƒ‰", d: 2,
                q: `BSTì—ì„œ ê°’ì„ ì°¾ìœ¼ì„¸ìš”.
<pre class="code-c">TNode* search(TNode *root, int key) {
    <span class="cm">// keyë¥¼ ì°¾ì•„ ë…¸ë“œ í¬ì¸í„° ë°˜í™˜ (ì—†ìœ¼ë©´ NULL)</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">TNode* search(TNode *root, int key) {
    if (!root || root->data == key) return root;
    if (key < root->data) return search(root->left, key);
    return search(root->right, key);
}</pre><div class="trace">O(log n) â€” ë§¤ë²ˆ ì ˆë°˜ ì œê±°!<br>(í¸í–¥ íŠ¸ë¦¬ë©´ O(n))</div>`},

            {
                n: 8, t: "íŠ¸ë¦¬ ìˆœíšŒ (ì „ìœ„Â·ì¤‘ìœ„Â·í›„ìœ„)", d: 2,
                q: `ì„¸ ê°€ì§€ íŠ¸ë¦¬ ìˆœíšŒë¥¼ ì‘ì„±í•˜ì„¸ìš”.
<pre class="code-c">void preorder(TNode *r)  { <span class="cm">/* ì „ìœ„: ë£¨íŠ¸â†’ì¢Œâ†’ìš° */</span> }
void inorder(TNode *r)   { <span class="cm">/* ì¤‘ìœ„: ì¢Œâ†’ë£¨íŠ¸â†’ìš° */</span> }
void postorder(TNode *r) { <span class="cm">/* í›„ìœ„: ì¢Œâ†’ìš°â†’ë£¨íŠ¸ */</span> }</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">void preorder(TNode *r) {
    if (!r) return;
    printf("%d ",r->data);
    preorder(r->left); preorder(r->right);
}
void inorder(TNode *r) {
    if (!r) return;
    inorder(r->left);
    printf("%d ",r->data);
    inorder(r->right);
}
void postorder(TNode *r) {
    if (!r) return;
    postorder(r->left); postorder(r->right);
    printf("%d ",r->data);
}</pre><div class="trace">BSTì˜ ì¤‘ìœ„ìˆœíšŒ = ì˜¤ë¦„ì°¨ìˆœ ì¶œë ¥!<br>ì „ìœ„: ë³µì‚¬ì— ìœ ìš©<br>í›„ìœ„: ì‚­ì œì— ìœ ìš©</div>`},

            {
                n: 9, t: "[ì¶œë ¥ì˜ˆì¸¡] íŠ¸ë¦¬ ìˆœíšŒ", d: 2,
                q: `ì•„ë˜ BSTì˜ ìˆœíšŒ ê²°ê³¼ë¥¼ ì“°ì„¸ìš”.
<pre class="code-c"><span class="cm">        5</span>
<span class="cm">       / \\</span>
<span class="cm">      3   7</span>
<span class="cm">     / \\   \\</span>
<span class="cm">    2   4   8</span>

<span class="cm">ì „ìœ„(preorder):  ?</span>
<span class="cm">ì¤‘ìœ„(inorder):   ?</span>
<span class="cm">í›„ìœ„(postorder): ?</span></pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">ì „ìœ„: 5 3 2 4 7 8
ì¤‘ìœ„: 2 3 4 5 7 8
í›„ìœ„: 2 4 3 8 7 5</pre><div class="trace">ì „ìœ„: ë£¨íŠ¸(5)â†’ì¢Œ(3â†’2â†’4)â†’ìš°(7â†’8)<br>ì¤‘ìœ„: ì¢Œ(2â†’3â†’4)â†’ë£¨íŠ¸(5)â†’ìš°(7â†’8) <span class="val">= ì •ë ¬!</span><br>í›„ìœ„: ì¢Œ(2â†’4â†’3)â†’ìš°(8â†’7)â†’ë£¨íŠ¸(5)</div>`},

            {
                n: 10, t: "íŠ¸ë¦¬ ë†’ì´", d: 2,
                q: `íŠ¸ë¦¬ì˜ ë†’ì´(ê¹Šì´)ë¥¼ êµ¬í•˜ì„¸ìš”.
<pre class="code-c">int height(TNode *root) {
    <span class="cm">// ë¹ˆ íŠ¸ë¦¬: 0, ë¦¬í”„: 1</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">int height(TNode *root) {
    if (!root) return 0;
    int lh = height(root->left);
    int rh = height(root->right);
    return (lh > rh ? lh : rh) + 1;
}</pre>`},

            {
                n: 11, t: "íŠ¸ë¦¬ ë…¸ë“œ ìˆ˜ ì„¸ê¸°", d: 1,
                q: `íŠ¸ë¦¬ì˜ ì „ì²´ ë…¸ë“œ ìˆ˜ë¥¼ ì„¸ì„¸ìš”.
<pre class="code-c">int countNodes(TNode *root) { <span class="cm">/* ? */</span> }</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">int countNodes(TNode *root) {
    if (!root) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}</pre>`},

            {
                n: 12, t: "DFS ê·¸ë˜í”„ íƒìƒ‰ (ì¬ê·€)", d: 3,
                q: `ì¸ì ‘ í–‰ë ¬ ê·¸ë˜í”„ì—ì„œ DFSë¥¼ êµ¬í˜„í•˜ì„¸ìš”.
<pre class="code-c">int visited[100] = {0};
void dfs(int graph[][100], int n, int v) {
    <span class="cm">// ì •ì  vì—ì„œ DFS</span>
}</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">void dfs(int graph[][100], int n, int v) {
    visited[v] = 1;
    printf("%d ", v);
    for (int i = 0; i < n; i++)
        if (graph[v][i] && !visited[i])
            dfs(graph, n, i);
}</pre>`},

            {
                n: 13, t: "í•´ì‹œ í…Œì´ë¸” (ì²´ì´ë‹)", d: 3,
                q: `í•´ì‹œ í…Œì´ë¸”ì„ ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì²´ì´ë‹ìœ¼ë¡œ êµ¬í˜„í•˜ì„¸ìš”.
<pre class="code-c">#define TABLE_SIZE 10
typedef struct Entry { int key; int val; struct Entry *next; } Entry;
Entry *table[TABLE_SIZE];
void put(int key, int val) { <span class="cm">/* ? */</span> }
int get(int key) { <span class="cm">/* ? */</span> }</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">int hash(int key) { return key % TABLE_SIZE; }
void put(int key, int val) {
    int h = hash(key);
    Entry *e = (Entry*)malloc(sizeof(Entry));
    e->key=key; e->val=val;
    e->next = table[h];
    table[h] = e;
}
int get(int key) {
    int h = hash(key);
    Entry *e = table[h];
    while (e) {
        if (e->key == key) return e->val;
        e = e->next;
    }
    return -1; <span class="cm">// ëª» ì°¾ìŒ</span>
}</pre>`},

            {
                n: 14, t: "ìš°ì„ ìˆœìœ„ í (í™)", d: 3,
                q: `ìµœì†Œ í™ì„ ë°°ì—´ë¡œ êµ¬í˜„í•˜ì„¸ìš”.
<pre class="code-c">int heap[101], heapSize = 0;
void insert(int val) { <span class="cm">/* ? */</span> }
int extractMin() { <span class="cm">/* ? */</span> }</pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">void insert(int val) {
    heap[++heapSize] = val;
    int i = heapSize;
    while (i>1 && heap[i]<heap[i/2]) {
        int t=heap[i]; heap[i]=heap[i/2]; heap[i/2]=t;
        i /= 2;
    }
}
int extractMin() {
    int min = heap[1];
    heap[1] = heap[heapSize--];
    int i = 1;
    while (2*i <= heapSize) {
        int child = 2*i;
        if (child+1<=heapSize && heap[child+1]<heap[child])
            child++;
        if (heap[i]<=heap[child]) break;
        int t=heap[i]; heap[i]=heap[child]; heap[child]=t;
        i = child;
    }
    return min;
}</pre><div class="trace">ë¶€ëª¨: i/2, ìì‹: 2i, 2i+1<br>ì‚½ì…: ë§¨ ëì— ë„£ê³  ìœ„ë¡œ ì˜¬ë¦¬ê¸°<br>ì‚­ì œ: ë£¨íŠ¸â†”ë§ˆì§€ë§‰, ì•„ë˜ë¡œ ë‚´ë¦¬ê¸°</div>`},

            {
                n: 15, t: "ğŸ† ìë£Œêµ¬ì¡° ì„ íƒ ë¬¸ì œ", d: 2,
                q: `ê° ìƒí™©ì— ê°€ì¥ ì í•©í•œ ìë£Œêµ¬ì¡°ë¥¼ ê³ ë¥´ì„¸ìš”.
<pre class="code-c"><span class="cm">(A) í•¨ìˆ˜ í˜¸ì¶œ ì¶”ì  â†’ ?</span>
<span class="cm">(B) í”„ë¦°í„° ì‘ì—… ëŒ€ê¸° â†’ ?</span>
<span class="cm">(C) ì‚¬ì „ ë‹¨ì–´ ê²€ìƒ‰ â†’ ?</span>
<span class="cm">(D) ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ â†’ ?</span>
<span class="cm">(E) í•­ìƒ ìµœì†Ÿê°’ ë¹ ë¥´ê²Œ â†’ ?</span>
<span class="cm">(F) keyâ†’value ë§¤í•‘, O(1) ì¡°íšŒ â†’ ?</span></pre>`,
                a: `<span class="key">ì •ë‹µ</span><pre class="code-c">(A) ìŠ¤íƒ â€” LIFO, ì¬ê·€/ë˜ëŒë¦¬ê¸°
(B) í â€” FIFO, ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬
(C) BST/í•´ì‹œ â€” O(log n) ë˜ëŠ” O(1) ê²€ìƒ‰
(D) ê·¸ë˜í”„ + BFS â€” ìµœë‹¨ ê²½ë¡œëŠ” BFS!
(E) ìµœì†Œ í™ â€” O(1) ìµœì†Ÿê°’, O(log n) ì‚½ì…ì‚­ì œ
(F) í•´ì‹œ í…Œì´ë¸” â€” O(1) í‰ê·  ì¡°íšŒ</pre>`}
        ];
        const c = document.getElementById('problems'); P.forEach(p => { const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}>â€‹</span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="âœï¸ ë‹µì„ ì‘ì„±í•˜ì„¸ìš”" rows="8"></textarea><details class="ans"><summary>ì •ë‹µ ë° í•´ì„¤ ë³´ê¸°</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="../submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>