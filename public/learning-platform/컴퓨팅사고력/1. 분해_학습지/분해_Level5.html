<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🧩 분해 학습지 Level 5 — 영재원·정보올림피아드 도전</title>
    <link rel="stylesheet" href="decomp.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>🧩 분해(Decomposition) 완전정복</h1>
            <div class="sub">Level 5 · 영재원·정보올림피아드 도전 — 그래프·DP·분할정복·암호</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span><span class="on"></span></div>
            <div class="meta"><span class="tag pri">📘 Level 5/5</span><span class="tag"
                    style="background:#fef2f2;color:#dc2626;border-color:#fca5a5">🔥 난이도 ★★★★★</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 150~180분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fef2f2">🏆</span> 영재원·정올 도전!</h2>
            <p>최고 난이도! <strong>그래프·분할정복·동적 프로그래밍(DP)·암호학</strong>을 활용한 문제입니다.</p>
            <ul>
                <li><strong>그래프</strong> — 정점과 간선, BFS/DFS, 최단경로</li>
                <li><strong>분할 정복</strong> — 문제를 반으로 나눠 풀고 합치기</li>
                <li><strong>DP</strong> — 작은 문제의 답을 저장해가며 큰 문제 풀기</li>
                <li><strong>암호학</strong> — 수학으로 비밀 지키기</li>
            </ul>
            <div class="warn">각 문제에 충분한 시간(5~15분)을 들여 깊이 사고하세요. 정답보다 <strong>풀이 과정</strong>이 중요합니다!</div>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="분해_Level4.html">← Level 4</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 5</span>
        </div>
        <div class="ft">🧩 분해(Decomposition) 완전정복 · Level 5/5 · 영재원·정올 도전 60문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "이진 탐색 분해", d: 5, q: "1~100 중 숫자 찾기를 <strong>이진 탐색</strong>으로 분해하세요. 정답이 73일 때 과정은?", a: "50→<strong>UP</strong>→75→<strong>DOWN</strong>→62→<strong>UP</strong>→68→<strong>UP</strong>→71→<strong>UP</strong>→73→<strong>정답!</strong><br>6번 만에 찾음! 순차는 최대 100번<br><span class='key'>핵심</span> 매번 반으로 = O(log n) = 분할 정복!" },
            { n: 2, t: "BFS vs DFS", d: 5, q: "아래 그래프에서 A부터 탐색 순서를 <strong>BFS와 DFS</strong> 각각 구하세요.<br>A-B, A-C, B-D, B-E, C-F", a: "<strong>BFS(너비우선):</strong> A→B,C→D,E,F (가까운 것부터)<br><strong>DFS(깊이우선):</strong> A→B→D→(돌아와)E→(돌아와)C→F (끝까지 가고 돌아옴)<br><span class='key'>핵심</span> BFS=큐(줄 서기), DFS=스택(쌓기)!" },
            { n: 3, t: "최단 경로", d: 5, q: "가중 그래프에서 A→E 최단 경로를 구하세요.<br>A-B:3, A-C:1, B-D:1, C-D:5, C-E:8, D-E:2", a: "경로1: A→B→D→E = 3+1+2 = <strong>6</strong><br>경로2: A→C→D→E = 1+5+2 = 8<br>경로3: A→C→E = 1+8 = 9<br>최단: <strong>A→B→D→E (6)</strong><br><span class='key'>핵심</span> 다익스트라 알고리즘!" },
            { n: 4, t: "병합 정렬 분해", d: 5, q: "[8,3,7,1,5,2,6,4]를 <strong>병합 정렬</strong>로 정렬하세요. 각 단계를 보이세요.", a: "[8,3,7,1,5,2,6,4]<br>→[8,3,7,1] [5,2,6,4] (반으로)<br>→[8,3] [7,1] [5,2] [6,4]<br>→[8] [3] [7] [1] [5] [2] [6] [4]<br>→[3,8] [1,7] [2,5] [4,6] (합치며 정렬)<br>→[1,3,7,8] [2,4,5,6]<br>→<strong>[1,2,3,4,5,6,7,8]</strong>" },
            { n: 5, t: "재귀 분해", d: 5, q: "팩토리얼 5!을 <strong>재귀</strong>로 분해하세요. 호출 스택을 그리세요.", a: "5! = 5×4! = 5×4×3! = 5×4×3×2! = 5×4×3×2×1! = 5×4×3×2×1<br>스택: [5!]→[5!,4!]→[5!,4!,3!]→[5!,4!,3!,2!]→[5!,4!,3!,2!,1!]<br>1!=1 반환→2!=2→3!=6→4!=24→5!=<strong>120</strong>" },
            { n: 6, t: "피보나치 DP", d: 6, q: "피보나치 수열의 8번째 항을 <strong>DP 테이블</strong>을 채워서 구하세요.", a: "F(0)=0, F(1)=1<br>F(2)=1, F(3)=2, F(4)=3, F(5)=5, F(6)=8, F(7)=13, F(8)=<strong>21</strong><br>재귀: 중복 호출 엄청남! DP: 테이블에 저장→O(n)" },
            { n: 7, t: "그래프 연결 요소", d: 6, q: "아래 그래프의 <strong>연결 요소</strong>를 모두 구하세요.<br>1-2, 2-3, 4-5, 6-7, 7-8, 8-6", a: "연결요소1: {1,2,3} (1-2-3 연결)<br>연결요소2: {4,5} (4-5 연결)<br>연결요소3: {6,7,8} (6-7-8-6 사이클)<br>총 <strong>3개</strong> 연결 요소<br><span class='key'>핵심</span> DFS/BFS로 구간별 탐색!" },
            { n: 8, t: "하노이 탑", d: 6, q: "하노이 탑 3개 원판을 A→C로 옮기세요. <strong>최소 이동 횟수와 과정</strong>을 분해하세요.", a: "1.A→C 2.A→B 3.C→B 4.A→C 5.B→A 6.B→C 7.A→C<br>총 <strong>7회</strong> = 2³-1<br>n개: <strong>2ⁿ-1회</strong><br><span class='key'>핵심</span> 재귀! n-1개를 임시로 옮기고→큰것 이동→n-1개 다시 옮기기" },
            { n: 9, t: "DP: 계단 오르기", d: 6, q: "한 번에 1칸 또는 2칸 올라갈 수 있습니다. <strong>10칸 계단</strong>을 올라가는 방법의 수를 DP로 구하세요.", a: "dp[1]=1, dp[2]=2<br>dp[3]=3, dp[4]=5, dp[5]=8, dp[6]=13, dp[7]=21, dp[8]=34, dp[9]=55, dp[10]=<strong>89</strong><br>dp[n]=dp[n-1]+dp[n-2] (피보나치와 같음!)" },
            { n: 10, t: "그래프: 사이클 검출", d: 6, q: "아래 방향 그래프에서 <strong>사이클이 존재</strong>하는지 판별하세요.<br>A→B, B→C, C→D, D→B, A→E", a: "경로 추적: A→B→C→D→<strong>B</strong>(이미 방문!) <br>사이클: <strong>B→C→D→B</strong> (길이 3 사이클)<br>A→E는 사이클 없음<br><span class='key'>핵심</span> DFS에서 '방문 중' 노드를 다시 만나면 = 사이클!" },
            { n: 11, t: "시저 암호", d: 6, q: "시저 암호(키=3)로 'HELLO'를 암호화하고, 'DWWDFN'을 복호화하세요.", a: "암호화: H→K, E→H, L→O, L→O, O→R = <strong>KHOOR</strong><br>복호화: D→A, W→T, W→T, D→A, F→C, N→K = <strong>ATTACK</strong><br><span class='key'>핵심</span> 알파벳 shift = 가장 간단한 치환 암호!" },
            { n: 12, t: "배낭 문제 (0/1)", d: 6, q: "배낭 용량 7kg. 물건: A(3kg,4만), B(4kg,5만), C(2kg,3만), D(5kg,7만). <strong>최대 가치</strong>를 DP로 구하세요.", a: "가능 조합: A+B=7kg, 9만 / A+C=5kg, 7만 / C+D=7kg, <strong>10만</strong> / A+C+남음=5kg, 7만<br>최적: <strong>C+D = 10만원</strong> (2+5=7kg 꽉 참)<br><span class='key'>핵심</span> 0/1 배낭 = DP의 대표 문제!" },
            { n: 13, t: "그래프 색칠", d: 7, q: "아래 그래프를 <strong>최소 색 수</strong>로 칠하세요. 인접 정점은 다른 색.<br>A-B, A-C, B-C, B-D, C-D, D-E", a: "A=빨강, B=파랑, C=초록, D=빨강, E=파랑<br>최소 <strong>3색</strong> 필요 (A-B-C 삼각형 때문)<br><span class='key'>핵심</span> 그래프 색칠 수 = 최대 클리크 크기 이상! 4색 정리: 모든 평면 그래프는 4색이면 충분" },
            { n: 14, t: "분할 정복: 가장 가까운 점", d: 7, q: "점 6개: (1,3), (2,1), (4,4), (5,2), (7,3), (8,1)에서 <strong>가장 가까운 점 쌍</strong>을 분할 정복으로 찾으세요.", a: "x좌표 정렬 → 반으로: 왼 {(1,3),(2,1),(4,4)} / 오른 {(5,2),(7,3),(8,1)}<br>왼쪽 최소: (1,3)-(2,1)=√5≈2.24<br>오른쪽 최소: (7,3)-(8,1)=√5≈2.24<br>경계: (4,4)-(5,2)=√5≈2.24<br>최소=<strong>√5≈2.24</strong> (여러 쌍)" },
            { n: 15, t: "DP: 최대 부분 배열", d: 7, q: "배열 [-2,1,-3,4,-1,2,1,-5,4]에서 <strong>연속 부분 배열의 최대 합</strong>을 카데인 알고리즘으로 구하세요.", a: "current: -2→1→-2→4→3→5→6→1→5<br>max: -2→1→1→4→4→5→<strong>6</strong>→6→6<br>최대 합: <strong>6</strong> (부분배열: [4,-1,2,1])<br><span class='key'>핵심</span> 각 위치에서 '이어갈까 새로 시작할까' = DP!" },
            { n: 16, t: "오일러/해밀턴 경로", d: 7, q: "아래 그래프에서 <strong>오일러 경로</strong>와 <strong>해밀턴 경로</strong>를 각각 구하세요.<br>A-B, A-C, A-D, B-C, B-D, C-D", a: "차수: A=3, B=3, C=3, D=3 (모두 홀수)<br>오일러 경로: 홀수 차수 정점 2개여야 → <strong>존재하지 않음!</strong> (4개가 홀수)<br>해밀턴 경로: A→B→C→D (모든 정점 1번씩) → <strong>존재!</strong>" },
            { n: 17, t: "비트 연산 마스킹", d: 7, q: "8비트 숫자 10110100에서 <strong>비트 연산</strong>으로 하위 4비트만 추출하세요.", a: "10110100 AND 00001111 = <strong>00000100</strong> (마스킹)<br>상위 4비트: 10110100 >> 4 = <strong>00001011</strong> (시프트)<br>특정 비트 설정: 10110100 OR 00001000 = <strong>10111100</strong><br><span class='key'>핵심</span> AND=추출, OR=설정, XOR=토글, NOT=반전!" },
            { n: 18, t: "위상 정렬", d: 7, q: "작업 의존 관계:<br>A→C, A→D, B→D, C→E, D→E, D→F, E→G, F→G<br><strong>가능한 실행 순서</strong>를 모두 구하세요.", a: "차수0: A,B → A 또는 B 먼저<br>가능: A→B→C→D→E→F→G<br>가능: B→A→C→D→E→F→G<br>가능: A→B→D→C→F→E→G<br>가능: B→A→D→C→E→F→G<br>(등등 여러 가능)" },
            { n: 19, t: "해시 충돌 해결", d: 7, q: "해시 함수 h(x)=x%5로 [12,22,32,7,17]을 저장하세요. <strong>선형 탐사와 체이닝</strong> 두 방법으로.", a: "h(12)=2, h(22)=2(충돌), h(32)=2(충돌), h(7)=2(충돌), h(17)=2(충돌)<br><strong>체이닝:</strong> 인덱스2→[12,22,32,7,17]\n<br><strong>선형탐사:</strong> 12→[2], 22→[3], 32→[4], 7→[0], 17→[1]" },
            { n: 20, t: "종합: 알고리즘 비교", d: 7, q: "같은 정렬 문제를 <strong>버블/선택/삽입/병합/퀵</strong> 정렬로 풀고, 시간복잡도를 비교하세요.<br>데이터: [5,3,8,1,9,2]", h: "각 정렬의 과정을 최소 3단계 보이세요", a: "공통 결과: [1,2,3,5,8,9]<br><strong>버블:</strong> O(n²) 인접 교환 반복<br><strong>선택:</strong> O(n²) 최소값 선택<br><strong>삽입:</strong> O(n²) 적절한 위치 삽입<br><strong>병합:</strong> O(n log n) 분할+합병 ✅<br><strong>퀵:</strong> O(n log n) 피벗 분할 ✅" },
            { n: 31, t: "[Bebras] 저울 문제", d: 6, q: "9개의 공 중 1개만 더 무겁습니다. <strong>양팔저울 2번</strong>만 사용해서 무거운 공을 찾으세요.", a: "① 3/3/3으로 나눔 → 3 vs 3 측정<br>② 무거운 쪽 3개 중 1 vs 1 측정<br>→ 기울면 무거운 쪽이 정답, 같으면 안 올린 것이 정답!<br><span class='key'>핵심</span> 3분할 전략! 3²=9개까지 2번이면 충분" },
            { n: 32, t: "[Bebras] 색칠 규칙", d: 6, q: "4×4 격자에 빨/파 2색으로 칠하는데, <strong>같은 행/열에 같은 색이 3개 이상 연속</strong>하면 안 됩니다. 가능한 칠하기를 분해하세요.", h: "왼쪽 위부터 한 줄씩 채워보세요", a: "행별로 분해: 가능한 행 패턴 나열<br>RRBB, RBRB, RBBR, BRRB, BRBR, BBRR (RRRB같은건 X)<br>각 행 선택 후 열 조건 체크 → 백트래킹!<br><span class='key'>핵심</span> 제약 만족 문제 = 분해+필터링" },
            { n: 33, t: "[정올] 거스름돈 DP", d: 6, q: "동전 [1,5,10,50,100]원으로 <strong>163원</strong>을 만드는 최소 동전 수를 구하세요.", a: "탐욕법: 100×1=100, 남은63 → 50×1=50, 남은13 → 10×1=10, 남은3 → 1×3=3<br>총 <strong>6개</strong> (100+50+10+1+1+1)<br><span class='key'>핵심</span> 이 경우 탐욕이 최적! 하지만 동전이 [1,3,4]면 탐욕≠최적 → DP 필요" },
            { n: 34, t: "[Bebras] 최소 컷", d: 6, q: "6개 도시(A~F)가 도로로 연결: A-B, A-C, B-D, C-D, C-E, D-F, E-F<br>A와 F 사이의 통행을 차단하려면 <strong>최소 몇 개 도로</strong>를 없애야 하나요?", a: "경로 분석: A→B→D→F / A→C→D→F / A→C→E→F<br>D-F와 E-F를 끊으면 → 모든 경로 차단!<br>최소 컷 = <strong>2개</strong> (D-F, E-F)<br><span class='key'>핵심</span> 최대유량=최소컷 (맥스플로-민컷 정리)" },
            { n: 35, t: "분할 정복: 멱승", d: 6, q: "2¹⁰을 분할 정복으로 계산하세요. 최소 곱셈 횟수는?", a: "2¹⁰ = (2⁵)² → 2⁵ = (2²)²×2 → 2² = 2×2<br>계산: 2×2=4 → 4×4=16 → 16×2=32 → 32×32=<strong>1024</strong><br>곱셈 <strong>4번</strong>! (순차적이면 9번 필요)<br><span class='key'>핵심</span> 빠른 거듭제곱 = O(log n) 분해!" },
            { n: 36, t: "[정올] LIS 분해", d: 7, q: "수열 [3,1,4,1,5,9,2,6]에서 <strong>가장 긴 오름차순 부분 수열(LIS)</strong>을 찾으세요.", a: "가능한 LIS: [1,4,5,9], [1,4,5,6], [1,2,6], [3,4,5,9]...<br>최장: [1,4,5,9] 또는 [1,4,5,6] → 길이=<strong>4</strong><br><span class='key'>핵심</span> 각 위치에서의 최장 → DP로 분해!" },
            { n: 37, t: "[Bebras] 토너먼트", d: 7, q: "16팀 토너먼트에서 우승팀을 결정하려면 <strong>총 몇 경기</strong>가 필요한가요? 왜 그런지 분해하세요.", a: "16→8→4→2→1 (각 라운드에서 절반 탈락)<br>경기 수: 8+4+2+1 = <strong>15경기</strong><br>일반화: N팀이면 <strong>N-1경기</strong> (매 경기 1팀 탈락, 15팀 탈락해야 하므로)<br><span class='key'>핵심</span> 분할 정복 구조 = 이진 트리!" },
            { n: 38, t: "[정올] 문자열 매칭", d: 7, q: "텍스트 'ABCABABCAB'에서 패턴 'ABCAB'을 찾으세요. <strong>단순 비교와 KMP</strong> 각각의 비교 횟수를 분해하세요.", a: "<strong>단순:</strong> 위치0→ABCAB=일치! 위치1→B≠A... 최대 6×5=30회<br><strong>KMP:</strong> 실패함수 [0,0,0,1,2] 활용→불필요한 비교 건너뛰기<br>실제 비교: 약 10회로 축소<br>결과: 위치 0과 위치 5에서 일치" },
            { n: 39, t: "확률 분해", d: 7, q: "주사위 2개를 던져 합이 7이 될 확률을 <strong>경우의 수 분해</strong>로 구하세요.", a: "전체 경우: 6×6=36가지<br>합이 7: (1,6)(2,5)(3,4)(4,3)(5,2)(6,1) = <strong>6가지</strong><br>확률 = 6/36 = <strong>1/6 ≈ 16.7%</strong><br><span class='key'>핵심</span> 전체를 분해→조건 필터 = 확률 계산의 기본!" },
            { n: 40, t: "게임 이론: 님 게임", d: 7, q: "돌이 [3,4,5]개 있는 3더미에서 번갈아 1더미에서 원하는 만큼 가져갑니다. 마지막 돌을 가져가면 승리. <strong>선공이 이기는 전략</strong>을 분해하세요.", h: "XOR 연산을 사용", a: "3 XOR 4 XOR 5 = 011 XOR 100 XOR 101 = <strong>010 = 2 ≠ 0</strong><br>→ 선공 승리 가능!<br>전략: XOR=0으로 만드는 수를 가져가기<br><span class='key'>핵심</span> 님 게임 = XOR 분해!" },
            { n: 41, t: "[Bebras] 채널 코딩", d: 7, q: "메시지 '101'을 전송할 때 1비트 오류를 <strong>검출하는 패리티 비트</strong>를 추가하세요. 그리고 <strong>해밍 코드</strong>로 오류 정정까지.", a: "<strong>패리티:</strong> 101 → 1의 개수=2(짝수) → 패리티비트=0 → 전송: 1010<br>수신: 1110 → 1의 개수=3(홀수) → 오류 감지!<br><strong>해밍(7,4):</strong> 더 복잡한 분해로 오류 위치까지 특정 가능<br><span class='key'>핵심</span> 중복(리던던시) 추가 = 오류에 강한 시스템!" },
            { n: 42, t: "그래프: 위상 정렬", d: 8, q: "과목 선수과목 관계:<br>A→C, B→C, B→D, C→E, D→E, E→F<br><strong>수강 가능한 순서</strong>를 모두 구하세요.", a: "입력 차수 0인 것부터: A,B 선택 가능<br>경우1: A→B→C→D→E→F<br>경우2: B→A→C→D→E→F<br>경우3: A→B→D→C→E→F<br>경우4: B→A→D→C→E→F<br>경우5: B→D→A→C→E→F<br><span class='key'>핵심</span> 위상 정렬 = 의존 관계 분해의 가장 강력한 도구!" },
            { n: 43, t: "DP: 최장 공통 부분 수열", d: 8, q: "문자열 ABCBDAB와 BDCAB의 <strong>LCS(최장 공통 부분 수열)</strong>을 DP 표로 구하세요.", a: "DP 표를 채워나가면:<br>B-D-C-A-B에서 ABCBDAB와의 LCS<br>공통 부분 수열: BCAB (길이 <strong>4</strong>)<br>B→C→A→B가 양쪽에 같은 순서로 나타남<br><span class='key'>핵심</span> 2차원 분해(행=문자열1, 열=문자열2)!" },
            { n: 44, t: "그래프: 이분 그래프", d: 8, q: "아래 그래프가 이분 그래프인지 판별하세요.<br>1-2, 2-3, 3-4, 4-5, 5-6, 6-1, 2-5", a: "2색 칠하기: 1=R→2=B→3=R→4=B→5=R→6=B<br>체크: 6-1(B-R)✓, 2-5(B-R)✓<br><strong>이분 그래프 맞음!</strong> (모든 변이 다른 색끼리)<br>만약 1-3 변 추가하면? 1=R, 3=R → 같은 색! → 이분 그래프 아님" },
            { n: 45, t: "해시 함수 분해", d: 8, q: "해시 함수 h(x) = x mod 7을 사용하여 [15, 22, 8, 30, 11, 3]을 <strong>해시 테이블에 저장</strong>하세요. 충돌 처리 포함.", a: "h(15)=1, h(22)=1(충돌!), h(8)=1(충돌!), h(30)=2, h(11)=4, h(3)=3<br><strong>체이닝:</strong> 인덱스1→[15,22,8], 인덱스2→[30], 인덱스3→[3], 인덱스4→[11]<br><span class='key'>핵심</span> 해시 = 분류의 핵심 자료구조! 충돌 처리가 핵심" },
            { n: 46, t: "암호: RSA 원리", d: 8, q: "RSA 암호의 기본 원리를 분해하세요. p=3, q=11을 사용. 평문 M=4를 암호화하세요.", h: "n=p×q, φ=(p-1)(q-1), e: gcd(e,φ)=1", a: "n=3×11=33, φ=(3-1)(11-1)=20<br>e=3 (gcd(3,20)=1)✓<br>d=7 (3×7=21, 21 mod 20=1)✓<br>암호화: C=M^e mod n = 4³ mod 33 = 64 mod 33 = <strong>31</strong><br>복호화: M=C^d mod n = 31⁷ mod 33 = <strong>4</strong> ✓" },
            { n: 47, t: "정렬: 퀵소트 분해", d: 8, q: "[7,2,1,6,8,5,3,4]를 <strong>퀵소트</strong>로 정렬하세요. 피벗=마지막 원소.", a: "피벗=4: [2,1,3] [4] [7,6,8,5]<br>왼쪽 피벗=3: [2,1] [3] → 피벗=1: [] [1] [2]<br>오른쪽 피벗=5: [] [5] [7,6,8] → 피벗=8: [7,6] [8] → 피벗=6: [] [6] [7]<br>결과: <strong>[1,2,3,4,5,6,7,8]</strong>" },
            { n: 48, t: "그래프: 최소 신장 트리", d: 8, q: "가중 그래프에서 MST를 구하세요:<br>A-B:4, A-C:2, B-C:1, B-D:5, C-D:8, C-E:10, D-E:2, D-F:6, E-F:3", a: "<strong>크루스칼:</strong> 가중치 오름차순으로 선택(사이클 없이)<br>B-C:1 ✓ → A-C:2 ✓ → D-E:2 ✓ → E-F:3 ✓ → A-B:4 ✗(사이클!) → B-D:5 ✓<br>MST 가중치 합: 1+2+2+3+5 = <strong>13</strong><br>간선 5개로 6개 정점 연결!" },
            { n: 49, t: "오토마타: 정규 표현식", d: 8, q: "정규 표현식 <strong>(a|b)*abb</strong>를 인식하는 유한 오토마타를 설계하세요. 입력 'aababb'는 인식되나요?", a: "상태: S0→(a)→S1→(b)→S2→(b)→S3(수락)<br>S0→(b)→S0, S1→(a)→S1, S2→(a)→S1, S3→(a)→S1, S3→(b)→S0<br>aababb 추적: S0→a→S1→a→S1→b→S2→a→S1→b→S2→b→S3<br><strong>수락!</strong> (abb로 끝남)" },
            { n: 50, t: "DP: 동전 교환 (확장)", d: 9, q: "동전 [1,3,4]원으로 6원을 만드는 <strong>최소 동전 수</strong>를 DP로 구하세요. 탐욕법과 비교.", a: "<strong>탐욕:</strong> 4+1+1 = 3개<br><strong>DP:</strong> dp[0]=0<br>dp[1]=1(1), dp[2]=2(1+1), dp[3]=1(3), dp[4]=1(4)<br>dp[5]=2(1+4), dp[6]=min(dp[5]+1, dp[3]+1)=<strong>2(3+3)</strong><br>DP가 최적! 탐욕(3개) > DP(2개)" },
            { n: 51, t: "네트워크: 라우팅", d: 9, q: "5개 라우터(R1~R5)의 라우팅 테이블을 완성하세요.<br>R1-R2:1, R1-R3:3, R2-R3:1, R2-R4:4, R3-R4:1, R3-R5:5, R4-R5:2", a: "R1의 최단 경로:<br>R1→R2: 1 (직접)<br>R1→R3: 2 (R1→R2→R3)<br>R1→R4: 3 (R1→R2→R3→R4)<br>R1→R5: 5 (R1→R2→R3→R4→R5)<br><span class='key'>핵심</span> 다익스트라 알고리즘 적용!" },
            { n: 52, t: "행렬 곱셈 순서", d: 9, q: "행렬 A(10×30), B(30×5), C(5×60)을 곱하는 순서에 따른 연산 수를 비교하세요.", a: "<strong>(AB)C:</strong> AB=10×30×5=1500 → (AB)C=10×5×60=3000 → 총 <strong>4500</strong><br><strong>A(BC):</strong> BC=30×5×60=9000 → A(BC)=10×30×60=18000 → 총 <strong>27000</strong><br>(AB)C가 6배 효율적!<br><span class='key'>핵심</span> 분해 순서가 성능을 결정 = 행렬 체인 곱셈 DP" },
            { n: 53, t: "정보 이론: 압축", d: 9, q: "텍스트 'AABABCAAB'에서 각 문자의 <strong>빈도를 세고 허프만 코딩</strong>으로 압축하세요.", a: "빈도: A=5, B=3, C=1<br>허프만 트리: C(1)+B(3)→CB(4), A(5)+CB(4)→루트(9)<br>코드: A=0, B=10, C=11<br>원본: 9문자×8bit=72bit<br>압축: 5×1+3×2+1×2=13bit<br>압축률: 13/72 = <strong>18%</strong>!" },
            { n: 54, t: "백트래킹: N-Queen", d: 9, q: "4×4 체스판에 퀸 4개를 서로 공격 못하게 배치하세요. <strong>백트래킹 과정</strong>을 분해하세요.", a: "(행,열): (1,1)→(2,3)→(3,?)모두 불가→돌아가기→(2,4)→(3,2)→(4,?)모두 불가→돌아가기...<br>해: <strong>(1,2)(2,4)(3,1)(4,3)</strong> 또는 <strong>(1,3)(2,1)(3,4)(4,2)</strong><br><span class='key'>핵심</span> 백트래킹 = 시도→실패→되돌아가서 다른 시도 = 가지치기!" },
            { n: 55, t: "그래프: 강연결 요소", d: 9, q: "방향 그래프에서 강연결 요소를 찾으세요:<br>A→B, B→C, C→A, B→D, D→E, E→D", a: "경로 분석:<br>A→B→C→A: 서로 도달 가능 → <strong>{A,B,C}</strong> = SCC1<br>D→E→D: 서로 도달 가능 → <strong>{D,E}</strong> = SCC2<br>SCC1→SCC2 (B→D) 가능, 역방향 불가<br><span class='key'>핵심</span> SCC = 그래프 분해의 핵심 단위!" },
            { n: 56, t: "확률: 몬테카를로", d: 9, q: "원의 넓이를 <strong>난수(랜덤)</strong>로 추정하는 과정을 분해하세요. 반지름=1인 원.", a: "① 1×1 정사각형에 점 N개 랜덤 생성(x,y: 0~1)<br>② 각 점: <strong>IF</strong> x²+y²≤1? → 원 안! → 카운트++<br>③ π/4 ≈ 원 안 점 수/전체 점 수<br>④ π ≈ 4 × (원 안 점/전체)<br>N=10000이면 π≈3.14...<br><span class='key'>핵심</span> 분해+시뮬레이션 = 몬테카를로 방법!" },
            { n: 57, t: "이산 수학: 비둘기집", d: 9, q: "13명이 12달 중 태어난 달이 있습니다. <strong>같은 달에 태어난 사람이 반드시 2명 이상</strong>임을 분해하여 증명하세요.", a: "상자(달)=12개, 비둘기(사람)=13마리<br>최선의 경우: 각 달에 1명씩 → 12명 배치<br>13번째 사람은 반드시 이미 있는 달에!<br>∴ <strong>최소 2명 이상 같은 달</strong><br><span class='key'>핵심</span> 비둘기집 원리 = 분류+반증 분해!" },
            { n: 58, t: "병렬 처리 분해", d: 9, q: "작업 8개(각 1초)를 프로세서 3개로 나누어 처리합니다. <strong>최소 완료 시간</strong>은? 의존관계: T1→T4, T2→T5, T3→T6, T4→T7, T5→T7, T6→T8", a: "P1: T1(1초)→T4(2초)→T7(3초, T5완료 대기 필요)<br>P2: T2(1초)→T5(2초)→대기→T7 가능?아님 T8<br>P3: T3(1초)→T6(2초)→T8(3초)<br>최적 스케줄: T7은 T4,T5 후 = 3초째 시작→4초 완료<br>최소 완료 = <strong>4초</strong>" },
            { n: 59, t: "복잡도 분석", d: 10, q: "다음 각 알고리즘의 <strong>시간 복잡도</strong>를 분해하여 구하세요.<br>① 이중 for문(n×n) ② 반씩 나누는 재귀 ③ for문 안에 반씩 나누기", a: "① for i(n) × for j(n) = <strong>O(n²)</strong><br>② T(n)=T(n/2)+O(1) → 매번 절반 → <strong>O(log n)</strong><br>③ for i(n) × 이진탐색(log n) = <strong>O(n log n)</strong><br><span class='key'>핵심</span> 분해 구조가 알고리즘 효율을 결정!" },
            { n: 60, t: "종합: 알고리즘 설계", d: 10, q: "친구 8명의 선물 교환 게임: 각자 1명에게 선물을 주되, <strong>자기 자신에게 주면 안 되고</strong>, 모든 사람이 정확히 1개를 받아야 합니다.<br>① 가능한 배치 방법의 수를 구하세요 ② 랜덤 배정 알고리즘을 분해하세요", h: "이것은 '교란(Derangement)' 문제입니다", a: "① D(n) = (n-1)(D(n-1)+D(n-2))<br>D(1)=0, D(2)=1, D(3)=2, D(4)=9, D(5)=44, D(6)=265, D(7)=1854, D(8)=<strong>14833</strong><br>② 알고리즘: 1~8 무작위 섞기→자기에게 가는 것 있으면 다시 섞기(반복)<br><span class='key'>🏆</span> 교란+피셔-예이츠 셔플 = 수학+알고리즘의 만남!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 6 ? 'hd' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < Math.min(p.d, 5) ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write tall" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>