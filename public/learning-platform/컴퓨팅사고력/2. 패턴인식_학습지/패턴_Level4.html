<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🔍 패턴 인식 학습지 Level 4 — 알고리즘·시스템 패턴</title>
    <link rel="stylesheet" href="pattern.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>🔍 패턴 인식(Pattern Recognition) 완전정복</h1>
            <div class="sub">Level 4 · 알고리즘·시스템 패턴 — 코드 패턴·디자인 패턴·시스템 규칙</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span><span></span></div>
            <div class="meta"><span class="tag pri">📘 Level 4/5</span><span class="tag ok">🔴 난이도 ★★★★☆</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 120~140분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fef2f2">📖</span> 알고리즘·시스템 패턴</h2>
            <p>컴퓨터 과학의 핵심! <strong>코드 속 반복 패턴, 알고리즘 설계 패턴, 시스템 동작 패턴</strong>을 인식합니다.</p>
            <ul>
                <li><strong>반복 구조 패턴</strong> — for/while 루프의 규칙성</li>
                <li><strong>재귀 패턴</strong> — 자기 자신을 호출하는 구조</li>
                <li><strong>디자인 패턴</strong> — 문제 해결의 재사용 가능한 템플릿</li>
                <li><strong>시스템 패턴</strong> — 입력→처리→출력의 반복 구조</li>
            </ul>
            <div class="warn">같은 패턴을 여러 문제에서 인식하면 → 한 번 배운 해법을 재활용할 수 있습니다!</div>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="패턴_Level3.html">← Level 3</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 4</span>
            <a href="패턴_Level5.html">Level 5 →</a>
        </div>
        <div class="ft">🔍 패턴 인식 완전정복 · Level 4/5 · 알고리즘·시스템 패턴 60문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "for 루프 패턴", d: 4, q: "아래 코드의 출력을 예측하세요.<br><code>for i in range(1,6): print(i*i)</code>", a: "출력: <strong>1, 4, 9, 16, 25</strong><br>패턴: i² (제곱수)<br>range(1,6) = 1,2,3,4,5<br><span class='key'>핵심</span> for 루프 = 반복 패턴의 코드 표현!" },
            { n: 2, t: "중첩 루프 패턴", d: 4, q: "<code>for i in range(1,4):<br>&nbsp;&nbsp;for j in range(1,i+1): print('*',end='')<br>&nbsp;&nbsp;print()</code><br>출력은?", a: "<strong>*</strong><br><strong>**</strong><br><strong>***</strong><br>패턴: i행에 i개의 별 (직각삼각형)<br>총 별 수: 1+2+3 = 6 = 3(3+1)/2" },
            { n: 3, t: "누적합 패턴", d: 4, q: "<code>s=0<br>for i in range(1,11): s+=i<br>print(s)</code><br>결과는? 이 패턴의 이름은?", a: "s = 1+2+3+...+10 = <strong>55</strong><br>패턴: <strong>누적합(Accumulator)</strong><br>공식: n(n+1)/2 = 10×11/2 = 55" },
            { n: 4, t: "카운터 패턴", d: 4, q: "<code>count=0<br>for c in 'hello world':<br>&nbsp;&nbsp;if c=='l': count+=1<br>print(count)</code>", a: "'hello world'에서 'l' 개수: he<strong>l</strong><strong>l</strong>o wor<strong>l</strong>d<br>count = <strong>3</strong><br>패턴: <strong>카운터(Counter)</strong> — 조건 만족 횟수 세기" },
            { n: 5, t: "스왑 패턴", d: 4, q: "a=3, b=5일 때 a와 b를 교환하는 코드를 <strong>3가지 방법</strong>으로 쓰세요.", a: "① 임시변수: <strong>t=a; a=b; b=t</strong><br>② 파이썬: <strong>a,b = b,a</strong><br>③ 산술: a=a+b; b=a-b; a=a-b<br>패턴: <strong>교환(Swap)</strong> — 정렬의 기본 연산!" },
            { n: 6, t: "최대값 찾기 패턴", d: 4, q: "리스트 [3,7,2,9,4]에서 최대값을 찾는 <strong>알고리즘 패턴</strong>을 설명하세요.", a: "<strong>max=첫 원소(3)</strong><br>7>3 → max=7, 2<7 유지, 9>7 → max=9, 4<9 유지<br>결과: <strong>9</strong><br>패턴: <strong>보초(Sentinel)</strong> — 현재 최선을 기억하고 갱신" },
            { n: 7, t: "이진 탐색 패턴", d: 4, q: "정렬된 [1,3,5,7,9,11,13]에서 9를 찾을 때 <strong>이진 탐색 과정</strong>은?", a: "mid=7 → 9>7 → 오른쪽 [9,11,13]<br>mid=11 → 9<11 → 왼쪽 [9]<br>mid=9 → <strong>찾음!</strong> (3번 만에)<br>패턴: <strong>분할 정복(Divide & Conquer)</strong>" },
            { n: 8, t: "버블 정렬 패턴", d: 4, q: "[5,3,8,1]을 <strong>버블 정렬</strong>로 정렬하세요. 각 패스의 교환 패턴은?", a: "Pass1: [3,5,1,8] (5↔3, 8↔1교환)<br>Pass2: [3,1,5,8]<br>Pass3: [1,3,5,8] ✓<br>패턴: 매 패스마다 최대값이 뒤로 '떠오름(bubble)'" },
            { n: 9, t: "스택 패턴", d: 4, q: "스택에 A,B,C를 push하고, 2번 pop. 남은 것은?<br><strong>스택과 큐</strong>의 패턴 차이는?", a: "Push: [A] → [A,B] → [A,B,C]<br>Pop: C 나옴 → [A,B], B 나옴 → [A]<br>스택: <strong>LIFO</strong>(후입선출) — 접시 쌓기<br>큐: <strong>FIFO</strong>(선입선출) — 줄 서기" },
            { n: 10, t: "재귀 패턴 기초", d: 4, q: "<code>def f(n):<br>&nbsp;&nbsp;if n==0: return 1<br>&nbsp;&nbsp;return n*f(n-1)</code><br>f(5)는? 이 패턴의 이름은?", a: "f(5)=5×f(4)=5×4×f(3)=...=5×4×3×2×1×1=<strong>120</strong><br>패턴: <strong>재귀(Recursion)</strong> — 팩토리얼 계산<br>기저 조건: n==0일 때 1 반환 (탈출구!)" },
            { n: 11, t: "맵/필터/리듀스", d: 4, q: "[1,2,3,4,5]에 <strong>map(×2), filter(짝수), reduce(+)</strong>를 순서대로 적용하면?", a: "map(×2): [2,4,6,8,10]<br>filter(짝수): [2,4,6,8,10] (모두 짝수!)<br>reduce(+): 2+4+6+8+10 = <strong>30</strong><br>패턴: <strong>파이프라인</strong> — 데이터가 단계를 거쳐 변환" },
            { n: 12, t: "검색 패턴", d: 4, q: "텍스트에서 단어 찾기는 <strong>어떤 패턴</strong>으로 동작할까요? Ctrl+F의 알고리즘을 설명하세요.", a: "단순: <strong>슬라이딩 윈도우</strong> — 한 글자씩 이동하며 비교<br>효율: <strong>KMP/보이어-무어</strong> — 불일치 패턴으로 건너뜀<br>패턴: <strong>문자열 매칭</strong> = 패턴 일치 확인의 반복" },
            { n: 13, t: "해시맵 패턴", d: 4, q: "전화번호부를 <strong>배열 vs 해시맵</strong>으로 구현할 때 검색 시간의 패턴 차이는?", a: "배열: 순차 검색 <strong>O(n)</strong> → 1000명이면 평균 500번<br>해시맵: 해시 함수 → <strong>O(1)</strong> → 상수 시간!<br>패턴: <strong>직접 접근 vs 순차 접근</strong><br>해시맵 = 키→값 매핑 패턴" },
            { n: 14, t: "이벤트 핸들러 패턴", d: 4, q: "버튼 클릭 → 함수 실행. 이 패턴의 이름과 <strong>유사한 실생활 예시</strong> 3가지는?", a: "패턴: <strong>이벤트 드리븐(Event-Driven)</strong><br>실생활:<br>1. 초인종 → 문 열기<br>2. 화재 경보 → 대피<br>3. 알람 → 기상<br>= 트리거 → 반응 패턴" },
            { n: 15, t: "캐시 패턴", d: 5, q: "웹 브라우저가 방문했던 페이지를 빠르게 보여주는 <strong>캐싱 패턴</strong>을 설명하세요.", a: "<strong>IF</strong> 캐시에 있음 → 캐시에서 로드 (빠름!)<br><strong>ELSE</strong> → 서버에서 다운로드 → 캐시에 저장<br>패턴: <strong>룩어사이드 캐시</strong><br>CPU L1/L2 캐시, DNS 캐시도 같은 패턴!" },
            { n: 16, t: "MVC 패턴", d: 5, q: "<strong>MVC(Model-View-Controller)</strong> 패턴을 설명하고, 실생활 비유를 만드세요.", a: "<strong>Model:</strong> 데이터 (재료/레시피)<br><strong>View:</strong> 화면 (접시에 담긴 음식)<br><strong>Controller:</strong> 입력 처리 (요리사)<br>패턴: 역할 분리 → 독립적 변경 가능<br>레스토랑: 주방(M) / 홀(V) / 주문(C)" },
            { n: 17, t: "옵서버 패턴", d: 5, q: "유튜브 <strong>구독+알림</strong>은 어떤 디자인 패턴인가요?", a: "패턴: <strong>옵서버(Observer)</strong> = 발행-구독<br>유튜버(Subject): 영상 업로드<br>구독자(Observer): 알림 수신<br>같은 패턴: 뉴스 구독/주식 알림/SNS 팔로우<br>= 1:N 알림 패턴" },
            { n: 18, t: "싱글톤 패턴", d: 5, q: "프린터 관리 프로그램은 왜 <strong>1개만</strong> 실행되어야 할까요? 어떤 패턴?", a: "패턴: <strong>싱글톤(Singleton)</strong> — 인스턴스 1개만 보장<br>이유: 프린터 작업 충돌 방지<br>같은 패턴: 설정 파일 관리, DB 연결 풀, 로그 시스템<br>= 공유 자원 관리 패턴" },
            { n: 19, t: "프로듀서-컨슈머", d: 5, q: "유튜버가 영상을 올리고, 시청자가 시청. <strong>프로듀서-컨슈머 패턴</strong>을 설명하세요.", a: "프로듀서: 데이터 생성 (영상 업로드)<br>컨슈머: 데이터 소비 (영상 시청)<br>버퍼: 업로드 대기열/재생목록<br>패턴: <strong>생산 속도 ≠ 소비 속도</strong> → 버퍼로 조절<br>공장 생산라인, 메시지큐도 같은 패턴!" },
            { n: 20, t: "종합: 코드 리팩토링", d: 5, q: "아래 코드에서 <strong>반복 패턴</strong>을 찾고 함수로 추출하세요.<br><code>print('===== 성적표 =====')<br>// 100줄의 처리 코드<br>print('===== 출석부 =====')<br>// 100줄의 처리 코드<br>print('===== 시간표 =====')</code>", a: "반복 패턴: <strong>print('===== X =====')</strong><br>함수 추출: <code>def header(title): print(f'===== {title} =====')</code><br>사용: header('성적표'), header('출석부'), header('시간표')<br><span class='key'>핵심</span> DRY 원칙 — Don't Repeat Yourself!" },
            { n: 21, t: "정렬 알고리즘 비교", d: 4, q: "버블/선택/삽입 정렬의 <strong>공통 패턴과 차이점</strong>을 비교하세요.", a: "공통: 모두 O(n²), 비교 기반, 안정성 다름<br><strong>버블:</strong> 인접 교환 반복 (뒤에서부터 정렬)<br><strong>선택:</strong> 최소값 선택 후 앞에 배치<br><strong>삽입:</strong> 올바른 위치에 삽입<br>패턴: 3가지 모두 '부분 정렬 영역을 확장'" },
            { n: 22, t: "그리디 패턴", d: 4, q: "500원, 100원, 50원, 10원으로 760원 거스름돈. <strong>그리디(탐욕) 알고리즘</strong>으로 풀면?", a: "500×1=500, 남은260<br>100×2=200, 남은60<br>50×1=50, 남은10<br>10×1=10, 남은0<br>총 <strong>5개</strong><br>패턴: <strong>가장 큰 것부터 선택</strong> = 그리디" },
            { n: 23, t: "분할 정복 패턴", d: 4, q: "퀵소트/병합정렬/이진탐색의 <strong>공통 패턴</strong>은?", a: "공통: <strong>분할 정복(Divide & Conquer)</strong><br>1. <strong>분할</strong>: 문제를 작은 문제로 나눔<br>2. <strong>정복</strong>: 작은 문제를 해결<br>3. <strong>결합</strong>: 결과를 합침<br>시간복잡도: O(n²)→O(n log n)으로 개선!" },
            { n: 24, t: "DP 패턴", d: 5, q: "피보나치를 재귀로 vs DP로 풀 때 <strong>호출 횟수 패턴</strong>을 비교하세요. f(6)기준.", a: "재귀: f(6)→f(5)+f(4)→... = <strong>25번 호출</strong> (중복 많음!)<br>DP: 0,1,1,2,3,5,8 순서로 <strong>7번 계산</strong><br>패턴: <strong>DP = 중복 부분 문제를 한 번만 계산</strong><br>메모이제이션으로 O(2ⁿ)→O(n) 개선!" },
            { n: 25, t: "투 포인터 패턴", d: 5, q: "정렬된 [1,3,5,7,9]에서 합이 12인 쌍을 찾으세요. <strong>투 포인터 방법</strong>으로.", a: "left=0(값1), right=4(값9) → 합10<12 → left++<br>left=1(값3), right=4(값9) → 합12=12 → <strong>찾았다! (3,9)</strong><br>패턴: 양쪽에서 좁혀오기 → O(n)!<br>일반 이중루프 O(n²)보다 훨씬 빠름" },
            { n: 26, t: "슬라이딩 윈도우", d: 5, q: "배열 [2,1,5,1,3,2]에서 <strong>연속 3개의 최대 합</strong>은? 슬라이딩 윈도우로 풀어보세요.", a: "[2,1,5]=8, [1,5,1]=7, [5,1,3]=9, [1,3,2]=6<br>최대: <strong>9</strong> ([5,1,3])<br>패턴: 창문을 한 칸씩 밀면서 합 갱신<br>매번 첫 원소 빼고 새 원소 더하기 → O(n)" },
            { n: 27, t: "백트래킹 패턴", d: 5, q: "미로 찾기에서 <strong>막다른 골목</strong>에 도달하면 어떻게 할까요? 이 전략의 이름은?", a: "전략: <strong>백트래킹(Backtracking)</strong><br>1. 앞으로 전진<br>2. 막힘 → 되돌아가기<br>3. 다른 경로 시도<br>4. 모든 경로 탐색할 때까지 반복<br>패턴: DFS + 가지치기 = 체계적 탐색" },
            { n: 28, t: "빅오 패턴 비교", d: 5, q: "O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)을 <strong>n=1000일 때</strong> 비교하세요.", a: "O(1)=<strong>1</strong><br>O(log n)=<strong>10</strong><br>O(n)=<strong>1,000</strong><br>O(n log n)=<strong>10,000</strong><br>O(n²)=<strong>1,000,000</strong><br>O(2ⁿ)=<strong>10³⁰⁰</strong> (우주 원자보다 많음!)<br>패턴: 알고리즘 선택이 성능을 결정!" },
            { n: 29, t: "입출력 버퍼 패턴", d: 5, q: "키보드 타이핑→화면 출력이 즉각적이지 않을 때가 있습니다. <strong>버퍼링 패턴</strong>을 설명하세요.", a: "패턴: <strong>수집→일괄처리→출력</strong><br>유형:<br>1. 라인 버퍼: Enter까지 모아서 전송<br>2. 블록 버퍼: 일정 크기까지 모아서 전송<br>3. 버퍼 없음: 즉시 전송<br>유튜브 버퍼링, 프린터 스풀도 같은 패턴!" },
            { n: 30, t: "종합: 패턴 라이브러리", d: 5, q: "프로그래밍에서 자주 쓰이는 <strong>패턴 5가지</strong>를 정리하세요. 각각 이름/목적/예시 포함.", a: "(자유 응답) 평가 기준:<br>✅ 5가지 패턴?<br>✅ 이름+목적+예시?<br>예시: 반복자/누적기/보초/분할정복/캐시<br><span class='key'>핵심</span> 패턴 라이브러리 = 재사용 가능한 지식!" },
            { n: 31, t: "API 호출 패턴", d: 4, q: "날씨 앱이 기상청 API를 호출하는 <strong>요청-응답(Request-Response)</strong> 패턴을 설명하세요.", a: "요청: GET /weather?city=서울<br>응답: {temp:5, humidity:40, sky:맑음}<br>패턴: <strong>클라이언트→요청→서버→처리→응답→클라이언트</strong><br>= 동기식 요청-응답 패턴" },
            { n: 32, t: "폴링 vs 푸시", d: 4, q: "새 메시지를 확인하는 2가지 방식: <strong>폴링 vs 푸시</strong>의 패턴 차이는?", a: "<strong>폴링:</strong> 5초마다 '새 메시지 있어?' 질문 (택배→5분마다 현관 확인)<br><strong>푸시:</strong> 서버가 알림 전송 (택배→초인종이 울림)<br>폴링: 자원 낭비 / 푸시: 효율적이지만 연결 유지 필요" },
            { n: 33, t: "파이프라인 패턴", d: 4, q: "영상 편집: 촬영→보정→자막→BGM→출력. 이 <strong>파이프라인 패턴</strong>을 프로그래밍에서 찾으세요.", a: "컴파일러: 소스코드→토큰화→파싱→최적화→코드 생성<br>데이터: 수집→정제→변환→분석→시각화<br>패턴: <strong>입력→단계1→단계2→...→출력</strong><br>각 단계가 독립적 → 병렬 처리 가능!" },
            { n: 34, t: "로드밸런서 패턴", d: 5, q: "서버 3대에 요청을 분산하는 <strong>로드밸런싱 패턴</strong> 3가지를 비교하세요.", a: "<strong>라운드로빈:</strong> 1→2→3→1→2→3... (순환)<br><strong>최소연결:</strong> 가장 일이 적은 서버에 배정<br><strong>가중치:</strong> 성능 좋은 서버에 더 많이 배정<br>패턴: <strong>분산 처리</strong> = 병렬화의 핵심" },
            { n: 35, t: "retry 패턴", d: 5, q: "네트워크 오류 시 <strong>재시도(Retry) 패턴</strong>을 설계하세요. 무한 재시도의 문제점은?", a: "단순: 실패→즉시 재시도 (서버에 부담!)<br>지수 백오프: 1초→2초→4초→8초 대기<br>최대 횟수: 5회 후 포기 → 에러 알림<br>패턴: <strong>지수적 대기 + 최대 횟수 제한</strong>" },
            { n: 36, t: "상태 머신 패턴", d: 4, q: "자판기를 <strong>상태 머신</strong>으로 표현하세요. 상태와 전환 조건은?", a: "[대기]→동전투입→[금액표시]→추가투입→[금액증가]→버튼선택→<strong>IF</strong>금액충분?→[배출]→[거스름돈]→[대기]<br>금액부족→[부족 표시]→추가투입<br>패턴: <strong>유한 상태 기계(FSM)</strong>" },
            { n: 37, t: "데코레이터 패턴", d: 5, q: "커피에 우유 추가, 시럽 추가, 크림 추가... <strong>데코레이터 패턴</strong>을 설명하세요.", a: "기본커피(3000원) + 우유(+500) + 시럽(+300) + 크림(+500) = 4300원<br>패턴: <strong>기본 객체에 기능을 동적으로 추가</strong><br>코드: 로그 추가, 인증 추가, 캐시 추가도 같은 패턴!" },
            { n: 38, t: "팩토리 패턴", d: 5, q: "게임에서 '전사', '마법사', '궁수' 캐릭터를 생성할 때 <strong>팩토리 패턴</strong>은?", a: "<code>createCharacter('전사') → Warrior 객체</code><br><code>createCharacter('마법사') → Mage 객체</code><br>패턴: <strong>생성 로직을 한 곳에 모아두기</strong><br>새 클래스 추가할 때 팩토리만 수정" },
            { n: 39, t: "미들웨어 패턴", d: 5, q: "웹 서버의 <strong>미들웨어 체인</strong>: 요청→로깅→인증→검증→핸들러→응답. 이 패턴은?", a: "패턴: <strong>책임 사슬(Chain of Responsibility)</strong><br>각 미들웨어가 다음에게 전달(pass) 또는 차단(block)<br>인증 실패 → 여기서 응답 반환, 이후 실행 안함<br>택배: 검수→분류→포장→배송도 같은 패턴!" },
            { n: 40, t: "CQRS 패턴", d: 5, q: "읽기(조회)와 쓰기(수정)를 분리하는 <strong>CQRS 패턴</strong>은 왜 필요한가요?", a: "<strong>Command(쓰기):</strong> 데이터 변경 → 정확성 중요<br><strong>Query(읽기):</strong> 데이터 조회 → 속도 중요<br>패턴: 읽기와 쓰기의 <strong>최적화 방향이 다름</strong><br>조회 100배 ← 쓰기 1번일 때 매우 효과적" },
            { n: 41, t: "트리 순회 패턴", d: 4, q: "이진 트리 순회 3가지 패턴을 비교하세요. 루트=A, 왼=B, 오=C.", a: "<strong>전위(Pre):</strong> A→B→C (루트 먼저)<br><strong>중위(In):</strong> B→A→C (루트 가운데)<br><strong>후위(Post):</strong> B→C→A (루트 마지막)<br>패턴: 루트 방문 시점만 다름!" },
            { n: 42, t: "해시 패턴 활용", d: 4, q: "문서에서 <strong>단어 빈도</strong>를 세는 알고리즘을 해시맵 패턴으로 설계하세요.", a: "<code>freq = {}<br>for word in text.split():<br>&nbsp;&nbsp;freq[word] = freq.get(word,0)+1</code><br>패턴: <strong>빈도 카운팅 = 해시맵 + 카운터</strong><br>단어 구름, 추천 시스템의 기본!" },
            { n: 43, t: "커넥션 풀 패턴", d: 5, q: "DB 연결을 매번 만들지 않고 <strong>풀(Pool)에서 빌려쓰는</strong> 이유와 패턴은?", a: "연결 생성: 느림 (수백ms)<br>풀에서 가져오기: 빠름 (수ms)<br>패턴: <strong>오브젝트 풀(Object Pool)</strong><br>= 비싼 자원을 재활용<br>스레드 풀, 메모리 풀도 같은 패턴!" },
            { n: 44, t: "서킷 브레이커", d: 5, q: "서버 과부하 시 <strong>서킷 브레이커 패턴</strong>은 어떻게 동작하나요?", a: "<strong>닫힘(정상):</strong> 요청 통과<br><strong>열림(차단):</strong> 실패 임계값 초과 → 즉시 에러 반환 (서버 보호)<br><strong>반열림:</strong> 일정 시간 후 소량 테스트 → 성공 시 닫힘으로<br>패턴: 전기 차단기와 같은 원리!" },
            { n: 45, t: "이벤트 소싱", d: 6, q: "은행 거래를 <strong>이벤트 소싱</strong>으로 기록하면? 일반 방식과 비교하세요.", a: "일반: 잔액=50000원 (현재 상태만)<br>이벤트 소싱: [입금10만,출금3만,이체2만] (모든 이벤트 기록)<br>패턴: <strong>상태 대신 변화를 기록</strong><br>장점: 이력 추적/실행취소 가능!" },
            { n: 46, t: "게임 루프 패턴", d: 4, q: "게임이 매 프레임 반복하는 <strong>게임 루프 패턴</strong>을 설명하세요.", a: "<code>while(게임 실행):<br>&nbsp;&nbsp;입력 처리(키보드/마우스)<br>&nbsp;&nbsp;물리 업데이트(이동/충돌)<br>&nbsp;&nbsp;렌더링(화면 그리기)<br>&nbsp;&nbsp;다음 프레임 대기</code><br>패턴: <strong>무한 루프 + 고정 간격</strong> (60fps = 16.7ms/프레임)" },
            { n: 47, t: "마이크로서비스", d: 5, q: "모놀리식 vs 마이크로서비스 <strong>아키텍처 패턴</strong>을 비교하세요.", a: "<strong>모놀리식:</strong> 하나의 큰 프로그램 (모든 기능 포함)<br><strong>마이크로서비스:</strong> 작은 서비스로 분리 (결제/회원/상품 각각)<br>패턴: 큰 시스템 → 독립 모듈로 분리<br>장점: 개별 배포/확장/기술 스택 자유" },
            { n: 48, t: "배치 vs 스트림", d: 5, q: "데이터 처리의 <strong>배치(Batch) vs 스트리밍(Stream)</strong> 패턴을 비교하세요.", a: "<strong>배치:</strong> 데이터 모아서 한번에 처리 (월급 계산, 일일 보고서)<br><strong>스트리밍:</strong> 실시간으로 처리 (주식 가격, 채팅)<br>패턴: 지연 허용 여부 → 방식 결정<br>배치: 효율적 / 스트리밍: 즉각적" },
            { n: 49, t: "A/B 테스트 패턴", d: 5, q: "웹사이트의 유저가 <strong>초록 버튼 vs 빨간 버튼</strong> 중 어느 것을 더 클릭하는지 어떻게 알 수 있나요?", a: "<strong>A/B 테스트:</strong><br>그룹A(50%): 초록 버튼 보임<br>그룹B(50%): 빨간 버튼 보임<br>클릭률 비교 → 통계적 유의성 검증<br>패턴: <strong>대조 실험</strong> = 과학적 의사결정" },
            { n: 50, t: "종합: 시스템 패턴 지도", d: 5, q: "지금까지 배운 시스템 패턴을 <strong>목적별로 분류</strong>하세요. 최소 4가지 목적.", a: "(자유 응답) 평가 기준:<br>✅ 4가지 이상 목적?<br>✅ 각 2개 이상 패턴?<br>예시 분류:<br>성능: 캐시/풀링/로드밸런싱<br>안정성: 서킷브레이커/retry/백오프<br>구조: MVC/마이크로서비스/파이프라인<br>데이터: 이벤트소싱/CQRS/배치" },
            { n: 51, t: "정규표현식 패턴", d: 4, q: "이메일 주소의 <strong>패턴</strong>을 정규표현식으로 표현하세요.", a: "패턴: <strong>[문자]@[문자].[문자]</strong><br>정규식: <code>[a-zA-Z0-9.]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}</code><br>유효: user@gmail.com ✓<br>무효: user@. ✗, @gmail.com ✗" },
            { n: 52, t: "비트 플래그 패턴", d: 5, q: "파일 권한 rwx(읽기/쓰기/실행)를 <strong>비트 플래그</strong>로 표현하세요.", a: "r=4(100), w=2(010), x=1(001)<br>rwx=7(111), rw-=6(110), r-x=5(101), r--=4(100)<br>패턴: <strong>각 비트=하나의 플래그</strong><br>chmod 755: 소유자(7=rwx), 그룹(5=r-x), 기타(5=r-x)" },
            { n: 53, t: "재시도 지수 백오프", d: 5, q: "API 호출 실패 시 재시도를 <strong>1초→2초→4초→8초</strong> 간격으로 하는 이유는?", a: "패턴: <strong>지수 백오프(Exponential Backoff)</strong><br>이유: 서버 부하 분산 (동시 재시도 방지)<br>+랜덤 지터: 1±0.5초, 2±1초... (충돌 회피)<br>AWS/Google API 모두 이 패턴 사용" },
            { n: 54, t: "캐시 교체 정책", d: 5, q: "캐시가 가득 찼을 때 <strong>어떤 데이터를 삭제</strong>할까? 3가지 정책 패턴을 비교하세요.", a: "<strong>LRU:</strong> 가장 오래 안 쓴 것 삭제 (Least Recently Used)<br><strong>LFU:</strong> 가장 적게 쓴 것 삭제 (Least Frequently Used)<br><strong>FIFO:</strong> 가장 먼저 들어온 것 삭제<br>패턴: '어떤 것이 다시 사용될 가능성이 높은가?'" },
            { n: 55, t: "락 패턴", d: 6, q: "두 사람이 동시에 같은 좌석을 예매하려 합니다. <strong>동시성 문제</strong>를 어떤 패턴으로 해결할까요?", a: "<strong>비관적 락:</strong> 좌석 선택 즉시 잠금 → 다른 사람 차단<br><strong>낙관적 락:</strong> 결제 시 확인 → 이미 예매됐으면 실패<br>패턴: <strong>상호 배제(Mutex)</strong><br>화장실 잠금장치와 같은 원리!" },
            { n: 56, t: "플러그인 패턴", d: 5, q: "크롬 확장 프로그램, VSCode 플러그인의 <strong>공통 설계 패턴</strong>은?", a: "패턴: <strong>플러그인 아키텍처</strong><br>핵심 프로그램은 변경 없이, 기능을 외부에서 추가<br>인터페이스 약속: '이 규칙을 따르면 연결해줌'<br>USB도 같은 패턴! (표준 규격 → 어떤 기기든 연결)" },
            { n: 57, t: "워크플로우 패턴", d: 5, q: "회사 결재 과정: 작성→팀장→부장→사장. <strong>워크플로우 패턴</strong>을 설명하세요.", a: "패턴: <strong>순차 승인(Sequential Approval)</strong><br>변형1: 병렬 승인 (팀장+부장 동시)<br>변형2: 조건 승인 (100만원 이하→팀장만)<br>패턴: 비즈니스 규칙에 따른 분기 흐름" },
            { n: 58, t: "사가 패턴", d: 6, q: "여행 예약: 항공+호텔+렌터카를 동시에 예약. 호텔 예약 실패 시 <strong>보상 처리</strong>는?", a: "<strong>사가(Saga) 패턴:</strong><br>1. 항공 예약 ✓<br>2. 호텔 예약 ✗ (실패!)<br>3. 보상: 항공 예약 <strong>취소</strong><br>패턴: 각 단계에 <strong>보상 동작</strong>을 정의<br>= 분산 트랜잭션의 핵심 패턴" },
            { n: 59, t: "헬스체크 패턴", d: 5, q: "서버가 살아있는지 확인하는 <strong>헬스체크 패턴</strong>은?", a: "패턴: /health 엔드포인트에 주기적 요청<br>응답 200 → 정상, 응답 없음 → 이상<br>3회 연속 실패 → <strong>서버 재시작</strong> 또는 트래픽 차단<br>심장 박동(Heartbeat) 패턴과 동일!" },
            { n: 60, t: "종합: 나만의 패턴 북", d: 6, q: "이 레벨에서 가장 유용하다고 생각하는 <strong>알고리즘·시스템 패턴 TOP 10</strong>을 골라 정리하세요.", h: "패턴명/목적/실생활비유/코드예시를 각각 포함", a: "(자유 응답) 평가 기준:<br>✅ 10가지 패턴?<br>✅ 목적 설명?<br>✅ 실생활 비유?<br>✅ 간단한 코드나 의사코드?<br><span class='key'>핵심</span> 자기만의 패턴 북 = 프로그래머의 무기!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 4 ? 'hd' : p.d <= 5 ? 'ex' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < Math.min(p.d, 5) ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write tall" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>