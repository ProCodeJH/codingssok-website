<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🧊 추상화 학습지 Level 3 — 절차 추상화</title>
    <link rel="stylesheet" href="abstraction.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>🧊 추상화(Abstraction) 완전정복</h1>
            <div class="sub">Level 3 · 절차 추상화 — 함수·모듈·인터페이스·계층화</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span
                    class="on"></span><span></span><span></span></div>
            <div class="meta"><span class="tag pri">📘 Level 3/5</span><span class="tag ok">🟠 난이도 ★★★☆☆</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 90~110분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fff7ed">📖</span> 절차 추상화란?</h2>
            <p>복잡한 <strong>과정(절차)</strong>을 간단한 이름으로 감싸서 숨기는 것이 절차 추상화입니다.</p>
            <ul>
                <li><strong>함수</strong> — 여러 줄의 코드를 하나의 이름으로 호출</li>
                <li><strong>모듈</strong> — 관련 기능들을 하나의 파일로 묶기</li>
                <li><strong>인터페이스</strong> — '어떻게'는 숨기고 '무엇을'만 공개</li>
                <li><strong>계층화</strong> — 복잡한 시스템을 단계별로 나누기</li>
            </ul>
            <div class="tip">자동차 운전: 핸들·브레이크·엑셀만 알면 됨! 엔진 내부 구조는 몰라도 OK = 절차 추상화</div>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="추상화_Level2.html">← Level 2</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 3</span>
            <a href="추상화_Level4.html">Level 4 →</a>
            <a href="추상화_Level5.html">Level 5</a>
        </div>
        <div class="ft">🧊 추상화 완전정복 · Level 3/5 · 절차 추상화 60문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "함수의 기본", d: 3, q: "<code>def greet(name): print(f'안녕 {name}!')</code> 이 함수는 <strong>어떤 절차를 추상화</strong>했나요?", a: "인사하는 절차 → <strong>greet(이름)</strong> 한 줄로!<br>내부: 문자열 조합 + 출력 → 숨겨짐<br>사용: greet('철수') 만 호출하면 됨<br><span class='key'>핵심</span> 함수 = 절차를 이름으로 감싸는 추상화" },
            { n: 2, t: "블랙박스", d: 3, q: "함수를 <strong>블랙박스</strong>라고 부르는 이유는? 입구와 출구만 있는 상자를 그리세요.", a: "입구(입력/매개변수) → [???비밀???] → 출구(출력/반환값)<br>사용자: <strong>내부를 몰라도</strong> 입출력만 알면 사용 가능!<br>예: len('hello') → 5 (내부 구현 모름)<br><span class='key'>핵심</span> 블랙박스 = 내부를 숨기는 추상화의 핵심 개념" },
            { n: 3, t: "매개변수와 일반화", d: 3, q: "greet_chulsu(), greet_younghee() 2개 vs <strong>greet(name)</strong> 1개. 어느 것이 더 좋은 추상화?", a: "전자: 사람마다 함수 1개씩 → 100명이면 100개!<br>후자: <strong>매개변수</strong>로 일반화 → 함수 1개면 충분!<br>greet('철수'), greet('영희') 모두 가능<br><span class='key'>핵심</span> 매개변수 = 구체적→일반적 변환 = 추상화 핵심!" },
            { n: 4, t: "반환값", d: 3, q: "<code>def add(a, b): return a+b</code>에서 <strong>return</strong>의 역할은?", a: "함수 블랙박스에서 <strong>결과를 밖으로 전달</strong><br>result = add(3, 5) → result에 8 저장<br>return이 없으면: 결과를 받을 수 없음!<br><span class='key'>핵심</span> return = 블랙박스의 출구 (결과 전달)" },
            { n: 5, t: "함수 분해", d: 3, q: "'아침에 학교 가기'를 <strong>5개의 함수</strong>로 분해하세요.", a: "① wake_up() — 일어나기<br>② wash() — 세수/양치<br>③ eat_breakfast() — 아침 식사<br>④ prepare_bag() — 가방 챙기기<br>⑤ go_to_school() — 등교<br><span class='key'>핵심</span> 큰 절차 → 작은 함수들의 조합 = 분해 + 추상화" },
            { n: 6, t: "print() 함수", d: 3, q: "print('hello')를 실행하면 화면에 글자가 나옵니다. <strong>내부에서 일어나는 일</strong>은?", a: "내부: 문자열→바이트 변환→OS에 출력 요청→버퍼링→화면 렌더링<br>사용자: <strong>print() 한 줄</strong>만!<br>5단계 과정 → 함수 1개로 추상화<br><span class='key'>핵심</span> 내장 함수도 복잡한 절차를 숨긴 추상화" },
            { n: 7, t: "라이브러리", d: 3, q: "import math 후 <strong>math.sqrt(16)</strong>을 쓸 수 있습니다. 라이브러리는 어떤 추상화?", a: "제곱근 계산 알고리즘(수십 줄) → <strong>sqrt() 1줄</strong>로!<br>구현을 모르고도 사용 가능<br>수학자가 만든 정확한 알고리즘 재사용!<br><span class='key'>핵심</span> 라이브러리 = 전문가의 구현을 패키징한 추상화" },
            { n: 8, t: "API 추상화", d: 3, q: "날씨 API: <strong>get_weather('서울')</strong> → {temp:5, sky:'맑음'}. 어떤 복잡성이 숨겨져 있나요?", a: "숨겨진 것: HTTP 요청→DNS 조회→서버 연결→DB 쿼리→데이터 포맷...<br>사용자: <strong>함수 1개</strong> 호출!<br>수천 줄 네트워크 코드 → 1줄<br><span class='key'>핵심</span> API = 서비스 전체를 함수 호출로 추상화" },
            { n: 9, t: "콜백 함수", d: 4, q: "버튼 클릭 시 함수 실행: <strong>button.onClick(doSomething)</strong>. 이 패턴의 추상화는?", a: "복잡한 이벤트 시스템 → <strong>'언제' + '무엇을'</strong> 만 지정<br>언제: 클릭 시 (onClick)<br>무엇을: doSomething 함수<br>이벤트 감지+처리 구조 → 숨겨짐<br><span class='key'>핵심</span> 콜백 = '언제 실행할지'를 추상화" },
            { n: 10, t: "재귀 함수", d: 4, q: "<code>def factorial(n):<br>&nbsp;&nbsp;if n==0: return 1<br>&nbsp;&nbsp;return n*factorial(n-1)</code> 재귀의 추상화 관점은?", a: "복잡한 반복 → <strong>자기 자신 호출</strong>로 단순하게!<br>factorial(5) = 5 × factorial(4) = ... = 120<br>하나의 함수가 모든 경우를 처리!<br><span class='key'>핵심</span> 재귀 = 큰 문제를 작은 문제로 추상화하는 패턴" },
            { n: 11, t: "getter/setter", d: 4, q: "왜 변수에 <strong>직접 접근</strong>하지 않고 get_age(), set_age()를 쓸까요?", a: "직접: student.age = -5 (잘못된 값도 됨!)<br>setter: set_age(-5) → <strong>거부!</strong> (유효성 검사)<br>getter: get_age() → <strong>가공된 값</strong> 반환 가능<br><span class='key'>핵심</span> getter/setter = 데이터 접근을 통제하는 절차 추상화" },
            { n: 12, t: "정렬 함수", d: 3, q: "sorted([5,3,8,1])을 호출하면 [1,3,5,8]이 됩니다. <strong>내부 알고리즘</strong>을 몰라도 되는 이유는?", a: "내부: 팀소트(TimSort) — 병합+삽입 정렬 조합 (매우 복잡!)<br>사용자: <strong>sorted(리스트)</strong> 한 줄!<br>'입력→정렬된 출력'만 알면 사용 가능<br><span class='key'>핵심</span> 알고리즘을 함수로 감싸면 → 누구나 사용 가능" },
            { n: 13, t: "에러 처리 추상화", d: 4, q: "try-except로 에러를 처리하는 것은 <strong>어떤 절차를 추상화</strong>한 것인가요?", a: "try: 정상 흐름 코드<br>except: 에러 시 대응 코드<br>'무엇이 잘못될 수 있는지' → <strong>분류된 예외</strong> (FileNotFoundError 등)<br><span class='key'>핵심</span> 예외 처리 = 에러 상황을 체계적으로 추상화" },
            { n: 14, t: "이벤트 루프", d: 4, q: "GUI 프로그램이 <strong>사용자 입력을 계속 기다리는 구조</strong>는 어떤 추상화인가요?", a: "무한루프 + 이벤트 큐 + 핸들러 분배 → 복잡!<br>개발자에게: <strong>onClick, onKey</strong> 등으로 단순화<br>이벤트 루프 자체는 숨겨짐<br><span class='key'>핵심</span> 이벤트 루프 = 비동기 처리의 절차 추상화" },
            { n: 15, t: "미들웨어", d: 4, q: "웹 서버의 <strong>로깅→인증→검증→처리</strong> 파이프라인은 어떤 추상화인가요?", a: "복잡한 요청 처리 → <strong>단계별로 분리</strong><br>각 미들웨어: 하나의 관심사만 처리<br>순서대로 실행 = 파이프라인<br><span class='key'>핵심</span> 미들웨어 = 처리 절차를 단계별로 분리하는 추상화" },
            { n: 16, t: "추상 클래스", d: 4, q: "'동물' 추상 클래스에서 speak()를 선언하고, Dog와 Cat이 각각 구현. 이 <strong>패턴의 의미</strong>는?", a: "Animal: speak() → <strong>'무엇을 할지'만 선언</strong> (HOW는 없음)<br>Dog: speak() → '멍!'<br>Cat: speak() → '야옹!'<br>'모든 동물은 소리를 냄' = 공통 인터페이스<br><span class='key'>핵심</span> 추상 클래스 = '공통 행동'의 추상화 (구현은 각자)" },
            { n: 17, t: "인터페이스", d: 4, q: "USB-C 포트는 <strong>인터페이스</strong>입니다. 프로그래밍의 인터페이스와 어떻게 비슷한가요?", a: "USB-C: 모양+핀 배치 규격 → 내부 기기 무관하게 연결!<br>프로그래밍 인터페이스: 함수 이름+매개변수 규격 → 내부 구현 무관!<br>공통점: <strong>'어떻게 연결할지'만 정의</strong>, 내부는 자유<br><span class='key'>핵심</span> 인터페이스 = 연결 규약의 추상화" },
            { n: 18, t: "캡슐화", d: 4, q: "캡슐 약처럼 <strong>내부를 감싸는 것</strong>이 왜 좋은 추상화인가요?", a: "캡슐 약: 맛 숨김 + 정확한 양 + 위장에서 녹음<br>캡슐화: <strong>데이터+함수를 클래스로</strong> 감싸기<br>외부에서: 공개된 메서드만 사용, 내부 데이터 직접 접근 불가<br><span class='key'>핵심</span> 캡슐화 = 정보 은닉 + 기능 묶음 = 객체지향의 핵심" },
            { n: 19, t: "OSI 7계층", d: 4, q: "네트워크의 <strong>OSI 7계층</strong> 중 우리가 직접 다루는 층과 숨겨진 층은?", a: "사용자 접촉: <strong>7.응용계층</strong> (웹브라우저, 이메일)<br>숨겨짐: 6.표현→5.세션→4.전송(TCP)→3.네트워크(IP)→2.데이터링크→1.물리<br>각 층: 바로 아래 층만 사용!<br><span class='key'>핵심</span> 계층화 = 복잡한 시스템을 층으로 나누는 추상화" },
            { n: 20, t: "종합: 자판기 함수", d: 3, q: "<strong>자판기</strong>를 함수들의 조합으로 설계하세요. 최소 5개 함수.", a: "(자유 응답) 평가 기준:<br>✅ 5개 이상 함수?<br>✅ 각 함수의 입출력 정의?<br>✅ 호출 순서?<br>예: insert_coin(amount), select_drink(num), check_stock(num), dispense(num), return_change()" },
            { n: 21, t: "map 함수", d: 3, q: "list(map(str, [1,2,3])) → ['1','2','3']. <strong>map의 추상화</strong>는?", a: "반복문: for i in [1,2,3]: result.append(str(i))<br>map: <strong>반복+적용을 한 줄</strong>로!<br>'리스트의 각 원소에 함수를 적용' = 패턴 추상화<br><span class='key'>핵심</span> map = 반복 적용 패턴의 추상화 (고차 함수)" },
            { n: 22, t: "filter 함수", d: 3, q: "list(filter(lambda x: x>3, [1,2,3,4,5])) → [4,5]. <strong>filter의 추상화</strong>는?", a: "반복문: for x in list: if x>3: result.append(x)<br>filter: <strong>조건 필터링을 한 줄</strong>로!<br>'조건을 만족하는 것만 걸러냄' = 패턴 추상화<br><span class='key'>핵심</span> filter = 조건 선별 패턴의 추상화" },
            { n: 23, t: "reduce 함수", d: 4, q: "reduce(lambda a,b: a+b, [1,2,3,4,5]) → 15. <strong>reduce의 추상화</strong>는?", a: "1+2=3 → 3+3=6 → 6+4=10 → 10+5=15<br>'리스트를 하나의 값으로 축약' = 패턴 추상화<br>합계/곱/최대값 모두 reduce로 가능!<br><span class='key'>핵심</span> reduce = 축약(집계) 패턴의 추상화" },
            { n: 24, t: "데코레이터", d: 4, q: "파이썬 <strong>@login_required</strong> 데코레이터는 어떤 절차를 추상화한 것인가요?", a: "없이: 모든 함수 안에 로그인 확인 코드 복붙<br>있으면: <strong>@login_required 한 줄!</strong><br>→ 자동으로 로그인 확인 후 원래 함수 실행<br><span class='key'>핵심</span> 데코레이터 = 공통 전처리/후처리의 추상화" },
            { n: 25, t: "제너레이터", d: 4, q: "def count(): yield 1; yield 2; yield 3. <strong>제너레이터</strong>는 어떤 추상화인가요?", a: "일반 함수: 모든 값을 한번에 반환<br>제너레이터: <strong>하나씩 필요할 때</strong> 생성!<br>무한 수열도 표현 가능 (메모리 절약)<br><span class='key'>핵심</span> 제너레이터 = 지연 평가(lazy)의 추상화" },
            { n: 26, t: "컨텍스트 매니저", d: 4, q: "<code>with open('file.txt') as f:</code>에서 <strong>with</strong>가 숨기는 절차는?", a: "숨겨진 절차: ①파일 열기 ②(사용) ③<strong>자동 닫기</strong> ④에러 시에도 닫기!<br>without: f=open(); try: ... finally: f.close()<br>with: <strong>자원 관리를 자동화</strong><br><span class='key'>핵심</span> with = 자원 획득+해제 절차의 추상화" },
            { n: 27, t: "Promise/async", d: 4, q: "데이터 다운로드를 <strong>async/await</strong>로 하는 것은 어떤 추상화인가요?", a: "실제: 콜백 지옥(callback hell) — 중첩된 복잡한 코드<br>async/await: <strong>순차적으로 읽히게!</strong><br>data = await fetch(url) → 동기처럼 보이지만 비동기!<br><span class='key'>핵심</span> async/await = 비동기 처리를 동기처럼 보이게 하는 추상화" },
            { n: 28, t: "ORM", d: 4, q: "Student.objects.filter(age=12) vs SQL 'SELECT * FROM student WHERE age=12'. <strong>ORM의 추상화</strong>는?", a: "SQL: 데이터베이스 언어로 직접 쿼리<br>ORM: <strong>프로그래밍 언어로</strong> DB 조작!<br>SQL 몰라도 DB 사용 가능<br><span class='key'>핵심</span> ORM = 데이터베이스 작업을 객체 메서드로 추상화" },
            { n: 29, t: "라우터", d: 4, q: "웹 프레임워크에서 <strong>@app.route('/users')</strong>는 어떤 추상화인가요?", a: "URL 경로 → <strong>해당 함수</strong>로 연결<br>내부: URL 파싱, HTTP 메서드 확인, 매개변수 추출...<br>개발자: <strong>경로+함수만</strong> 지정!<br><span class='key'>핵심</span> 라우터 = URL→함수 매핑의 추상화" },
            { n: 30, t: "종합: 계산기 설계", d: 3, q: "<strong>계산기 프로그램</strong>을 함수로 설계하세요. 사칙연산+기록+취소 기능 포함.", a: "(자유 응답) 평가 기준:<br>✅ 기본 함수(add, sub, mul, div)?<br>✅ 히스토리(log, undo)?<br>✅ 입출력 설계?<br>✅ 에러 처리(0으로 나누기)?<br>각 함수의 매개변수와 반환값 정의!" },
            { n: 31, t: "컴포넌트", d: 3, q: "웹 개발에서 <strong>버튼 컴포넌트</strong>를 만들면 어떤 추상화 이점이 있나요?", a: "HTML+CSS+JS를 매번 작성 → <strong>&lt;Button text='클릭'/&gt;</strong> 한 줄!<br>색상, 크기, 이벤트 → 속성으로 지정<br>100곳에서 사용 → 수정은 1곳만!<br><span class='key'>핵심</span> 컴포넌트 = UI의 재사용 가능한 추상화" },
            { n: 32, t: "파이프라인", d: 4, q: "데이터 처리: <strong>읽기→정제→변환→분석→출력</strong>. 이 파이프라인의 추상화 장점은?", a: "각 단계: <strong>독립적 함수</strong><br>변경: 정제 방법만 바꾸면 나머지 영향 없음!<br>재사용: 같은 '정제' 함수를 다른 파이프라인에서도<br><span class='key'>핵심</span> 파이프라인 = 처리 절차를 단계별로 분리하는 추상화" },
            { n: 33, t: "이터레이터", d: 4, q: "for x in collection: 에서 <strong>for문이 숨기는 것</strong>은?", a: "숨겨진 것: ①이터레이터 생성 ②next() 호출 ③StopIteration 검사<br>리스트, 튜플, 딕셔너리, 파일 <strong>모두 같은 for문!</strong><br>내부 구조가 달라도 동일한 인터페이스<br><span class='key'>핵심</span> 이터레이터 = 순회 방법의 추상화 (다형성)" },
            { n: 34, t: "팩토리 함수", d: 4, q: "<strong>create_shape('원', 5)</strong> 하나로 원/사각형/삼각형을 만들 수 있습니다. 이 패턴은?", a: "원: Circle(5), 사각형: Rectangle(5), 삼각형: Triangle(5)<br>각각 호출 → 복잡! / 팩토리 → <strong>하나의 함수</strong>로 통일<br>create_shape('원',5) → 내부에서 적절한 객체 생성<br><span class='key'>핵심</span> 팩토리 = 객체 생성 절차를 하나로 추상화" },
            { n: 35, t: "전략 패턴", d: 4, q: "정렬 방법을 <strong>실행 중에 바꿀 수</strong> 있다면? 전략 패턴의 추상화를 설명하세요.", a: "sort(data, strategy='빠른정렬') → sort(data, strategy='병합정렬')<br>알고리즘을 <strong>함수로 전달</strong>!<br>sort 함수: 어떤 전략이든 같은 방식으로 호출<br><span class='key'>핵심</span> 전략 패턴 = 알고리즘을 매개변수로 추상화" },
            { n: 36, t: "모듈 분리", d: 3, q: "1000줄짜리 프로그램을 <strong>5개 파일</strong>로 나누는 기준은 무엇인가요?", a: "기준: <strong>기능별 분리</strong><br>예: auth.py(인증), db.py(데이터), ui.py(화면), utils.py(유틸), main.py(메인)<br>각 모듈: 관련 함수+데이터 묶음<br><span class='key'>핵심</span> 모듈 = 관련 기능을 파일로 묶는 추상화 (관심사 분리)" },
            { n: 37, t: "패키지 매니저", d: 3, q: "pip install requests 한 줄로 <strong>수천 줄의 코드</strong>를 사용할 수 있습니다. 어떤 추상화?", a: "숨겨진 절차: 다운로드→의존성 확인→설치→경로 등록<br>설치 후: <strong>import requests</strong> 한 줄!<br>request.get(url) → 수천 줄의 HTTP 처리를 1줄로<br><span class='key'>핵심</span> 패키지 = 남의 코드를 내 것처럼 쓰는 추상화" },
            { n: 38, t: "SQL과 추상화", d: 4, q: "SELECT name FROM students WHERE age > 10. SQL이 <strong>어떤 절차를 추상화</strong>했나요?", a: "실제: 파일 열기→테이블 스캔→조건 비교→결과 수집→반환<br>SQL: <strong>'무엇을 원하는지'만</strong> 선언!<br>'어떻게' 찾을지는 DB 엔진이 결정<br><span class='key'>핵심</span> SQL = 선언적 프로그래밍 = '방법'을 숨기는 최고의 추상화" },
            { n: 39, t: "테스트 추상화", d: 4, q: "assert add(2,3) == 5 한 줄로 <strong>함수 테스트</strong>를 할 수 있습니다. 어떤 추상화?", a: "절차: ①함수 호출 ②결과 저장 ③기대값 비교 ④결과 출력<br>assert: <strong>이 모든 절차를 한 줄</strong>로!<br>실패 시 자동으로 에러 메시지<br><span class='key'>핵심</span> assert = 검증 절차의 추상화" },
            { n: 40, t: "종합: 도서관 시스템", d: 4, q: "<strong>도서관 관리 시스템</strong>을 모듈과 함수로 설계하세요. 책관리/회원관리/대출관리 포함.", a: "(자유 응답) 평가 기준:<br>✅ 3개 이상 모듈?<br>✅ 각 모듈에 3개 이상 함수?<br>✅ 함수 간 호출 관계?<br>✅ 데이터 흐름?" },
            { n: 41, t: "CLI vs GUI", d: 3, q: "같은 기능을 <strong>명령어(CLI) vs 버튼(GUI)</strong>으로 제공할 때의 <strong>추상화 수준 차이</strong>는?", a: "CLI: <code>rm -rf folder</code> (직접 명령)<br>GUI: 폴더 우클릭 → 삭제 (시각적 인터페이스)<br>GUI = CLI보다 <strong>더 높은 추상화</strong> (내부 명령을 숨김)<br><span class='key'>핵심</span> GUI = CLI 위의 추상화 계층" },
            { n: 42, t: "프레임워크", d: 4, q: "라이브러리 vs <strong>프레임워크</strong>의 추상화 차이는?", a: "라이브러리: <strong>내가 호출</strong> (requests.get())<br>프레임워크: <strong>프레임워크가 나를 호출</strong> (Django가 view 함수 호출!)<br>= 제어의 역전(IoC)<br><span class='key'>핵심</span> 프레임워크 = 프로그램 구조 자체를 추상화" },
            { n: 43, t: "DSL", d: 4, q: "CSS는 <strong>도메인 특화 언어(DSL)</strong>입니다. 범용 언어(JS)와 비교하여 추상화 관점을 설명하세요.", a: "JS로 스타일: element.style.color = 'red' (절차적)<br>CSS: <strong>color: red;</strong> (선언적!)<br>CSS = '어떻게 보여야 하는지'만 선언<br><span class='key'>핵심</span> DSL = 특정 분야에 최적화된 추상화 언어" },
            { n: 44, t: "가비지 컬렉터", d: 4, q: "파이썬에서 <strong>메모리를 직접 관리하지 않아도 되는</strong> 이유는?", a: "C: malloc()으로 메모리 할당, free()로 해제 → 실수하면 메모리 누수!<br>파이썬: <strong>가비지 컬렉터</strong>가 자동 정리<br>안 쓰는 메모리 → 자동 회수<br><span class='key'>핵심</span> GC = 메모리 관리 절차의 완전 자동 추상화" },
            { n: 45, t: "트랜잭션", d: 4, q: "은행 이체: 출금+입금이 <strong>반드시 함께</strong> 성공하거나 실패해야 합니다. 어떤 추상화?", a: "트랜잭션: begin→출금→입금→commit (또는 rollback)<br>중간에 오류 → <strong>모두 취소</strong>!<br>복잡한 무결성 보장 → <strong>begin/commit</strong> 두 줄로<br><span class='key'>핵심</span> 트랜잭션 = 일관성 보장 절차의 추상화" },
            { n: 46, t: "설정 파일", d: 3, q: "하드코딩된 값(port=8080)을 <strong>설정 파일(config.yml)</strong>로 분리하는 이유는?", a: "하드코딩: 값 변경 = 코드 수정 + 재배포<br>설정 파일: <strong>값만 변경</strong> → 코드 수정 불필요!<br>환경별 다른 설정 가능 (개발/운영)<br><span class='key'>핵심</span> 설정 분리 = 고정값과 변경값을 추상화로 분리" },
            { n: 47, t: "로깅 추상화", d: 4, q: "logger.info('서버 시작')로 <strong>로그를 남기는 것</strong>의 추상화를 설명하세요.", a: "내부: 타임스탬프 추가→포맷팅→파일/콘솔/서버에 출력→레벨 필터링<br>사용자: <strong>logger.info() 한 줄!</strong><br>출력 대상 변경 = 코드 수정 없이 설정만<br><span class='key'>핵심</span> 로거 = '기록하는 절차' 전체를 추상화" },
            { n: 48, t: "의존성 주입", d: 5, q: "함수에 <strong>구현체를 직접 생성</strong>하지 않고 <strong>외부에서 넣어주는</strong> 패턴은?", a: "나쁜: def process(): db = MySQL() ← 직접 생성 (MySQL에 종속!)<br>좋은: def process(db): ← <strong>외부에서 주입</strong> (어떤 DB든 가능)<br><span class='key'>핵심</span> DI = 구현체 생성을 외부에 위임하는 추상화" },
            { n: 49, t: "가상화", d: 5, q: "Docker 컨테이너 안에서 프로그램이 실행되면 <strong>OS를 추상화</strong>한 것입니다. 설명하세요.", a: "프로그램: '리눅스에서 실행 중'이라고 생각<br>실제: 윈도우/맥/리눅스 <strong>어디서든</strong> 같은 환경!<br>가상화 = OS의 추상화 → 환경 차이 제거<br><span class='key'>핵심</span> 컨테이너 = 실행 환경의 추상화" },
            { n: 50, t: "종합: 챗봇 설계", d: 4, q: "<strong>간단한 챗봇</strong>의 처리 과정을 함수들로 설계하세요. 입력→분석→응답 포함.", a: "(자유 응답) 평가 기준:<br>✅ 입력 처리 함수?<br>✅ 의도 분석 함수?<br>✅ 응답 생성 함수?<br>✅ 대화 기록 관리?<br>예: receive_input()→parse_intent()→generate_response()→send_output()" },
            { n: 51, t: "함수 합성", d: 4, q: "f(x)=x+1, g(x)=x*2일 때, <strong>h = f∘g</strong>와 <strong>k = g∘f</strong>의 결과를 비교하세요.", a: "h(3) = f(g(3)) = f(6) = <strong>7</strong><br>k(3) = g(f(3)) = g(4) = <strong>8</strong><br>순서가 다르면 결과도 다름!<br><span class='key'>핵심</span> 함수 합성 = 작은 함수를 조합해 새 함수를 만드는 추상화" },
            { n: 52, t: "커링", d: 5, q: "add(a,b) → add(a)(b)로 바꾸는 <strong>커링</strong>은 어떤 추상화인가요?", a: "add(3,5) → add(3)(5)<br><strong>add_3 = add(3)</strong> → 3을 더하는 전용 함수 생성!<br>add_3(5) = 8, add_3(10) = 13<br><span class='key'>핵심</span> 커링 = 인수 부분 적용으로 특수 함수를 만드는 추상화" },
            { n: 53, t: "DSL 작성", d: 5, q: "학교 시간표를 표현하는 <strong>나만의 미니 언어(DSL)</strong>를 설계하세요.", a: "(자유 응답) 예:<br>MON[1:수학, 2:영어, 3:과학, 4:국어, 5:체육]<br>TUE[1:영어, 2:수학, ...]<br>간결+읽기 쉬움+목적에 특화<br><span class='key'>핵심</span> DSL 설계 = 도메인 지식의 언어적 추상화" },
            { n: 54, t: "플러그인", d: 4, q: "크롬 확장 프로그램처럼 <strong>본체 수정 없이 기능을 추가</strong>하는 구조는 어떤 추상화?", a: "본체: 플러그인 '슬롯'(인터페이스) 제공<br>플러그인: 슬롯에 맞게 기능 구현<br>추가/삭제가 자유! 본체 코드 변경 없음!<br><span class='key'>핵심</span> 플러그인 아키텍처 = 확장 지점의 추상화" },
            { n: 55, t: "옵서버", d: 4, q: "유튜브 구독처럼 <strong>새 영상 알림</strong>을 받는 구조의 추상화를 설명하세요.", a: "채널(Subject): 영상 업로드 시 구독자에게 알림<br>구독자(Observer): 알림 받으면 반응<br>구독/해지 자유!<br><span class='key'>핵심</span> 옵서버 패턴 = '알림 받기'를 추상화 (1:N 관계)" },
            { n: 56, t: "미들웨어 체인", d: 4, q: "Express.js에서 <strong>app.use(logger, auth, handler)</strong>의 실행 흐름을 설명하세요.", a: "요청 → logger(기록) → auth(인증) → handler(처리) → 응답<br>각 미들웨어는 <strong>next()</strong>로 다음에게 전달<br>auth 실패 시 → 여기서 반환 (handler 실행 안 됨)<br><span class='key'>핵심</span> 미들웨어 체인 = 처리 절차를 독립 단계로 추상화" },
            { n: 57, t: "데이터바인딩", d: 4, q: "React에서 <strong>state 변경 → 화면 자동 업데이트</strong>되는 것은 어떤 추상화?", a: "수동: 데이터 변경 → DOM 수동 업데이트 (복잡!)<br>React: <strong>setState() 한 번 → 화면 자동 반영!</strong><br>DOM 조작 절차를 완전히 숨김<br><span class='key'>핵심</span> 데이터바인딩 = 데이터↔UI 동기화의 자동 추상화" },
            { n: 58, t: "캐싱 전략", d: 4, q: "함수 결과를 <strong>캐싱</strong>하는 것은 어떤 절차 추상화인가요?", a: "1차: 캐시에 있나? → 있으면 바로 반환!<br>2차: 없으면 계산 → 캐시에 저장 → 반환<br>사용자: <strong>같은 함수 호출!</strong> 캐시 존재 모름<br><span class='key'>핵심</span> 캐싱 = 계산 비용을 숨기는 투명한 추상화" },
            { n: 59, t: "스케줄러", d: 4, q: "OS가 <strong>여러 프로그램을 동시에</strong> 실행하는 것처럼 보이게 하는 추상화는?", a: "실제: CPU 1개가 초고속으로 <strong>번갈아 실행</strong><br>사용자: <strong>동시 실행</strong>처럼 보임!<br>시분할(Time-sharing): 각 프로그램에 시간 조각 할당<br><span class='key'>핵심</span> 멀티태스킹 = '동시성'의 추상화 (실제로는 순차!)" },
            { n: 60, t: "종합: 좋은 절차 추상화", d: 4, q: "<strong>좋은 절차 추상화의 원칙</strong> 5가지를 만들고, 각각 예시를 드세요.", a: "(자유 응답) 평가 기준:<br>✅ 5가지 원칙?<br>✅ 각 예시?<br>예: ①단일 책임(함수=1가지 일) ②적절한 이름 ③최소 매개변수 ④부작용 없음 ⑤적절한 추상화 수준<br><span class='key'>핵심</span> 좋은 추상화 = 사용자가 내부를 몰라도 안심하고 쓸 수 있음!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 3 ? 'md' : p.d <= 4 ? 'hd' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < Math.min(p.d, 5) ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write tall" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>