<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🧊 추상화 학습지 Level 4 — 모델링·설계 추상화</title>
    <link rel="stylesheet" href="abstraction.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>🧊 추상화(Abstraction) 완전정복</h1>
            <div class="sub">Level 4 · 모델링·설계 추상화 — 객체지향·디자인패턴·아키텍처·시스템 설계</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span><span></span></div>
            <div class="meta"><span class="tag pri">📘 Level 4/5</span><span class="tag ok">🔴 난이도 ★★★★☆</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 120~140분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fef2f2">📖</span> 모델링·설계 추상화</h2>
            <p>현실 세계를 <strong>소프트웨어 모델로 변환</strong>하고, 복잡한 시스템을 설계하는 고급 추상화입니다.</p>
            <ul>
                <li><strong>객체지향</strong> — 현실의 사물을 객체(데이터+행동)로 모델링</li>
                <li><strong>디자인 패턴</strong> — 반복되는 설계 문제의 재사용 가능한 해법</li>
                <li><strong>아키텍처</strong> — 시스템 전체 구조의 설계 청사진</li>
                <li><strong>추상화 계층</strong> — 하위 복잡성을 숨기는 다단계 설계</li>
            </ul>
            <div class="warn">이 레벨부터는 '코딩'보다 '설계적 사고'가 핵심입니다. 정답보다 논리적 사고 과정이 중요!</div>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="추상화_Level3.html">← Level 3</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 4</span>
            <a href="추상화_Level5.html">Level 5 →</a>
        </div>
        <div class="ft">🧊 추상화 완전정복 · Level 4/5 · 모델링·설계 추상화 60문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "클래스와 객체", d: 4, q: "'자동차 설계도(클래스)'와 '실제 자동차(객체)'의 관계를 <strong>추상화 관점</strong>에서 설명하세요.", a: "클래스: <strong>추상적 설계도</strong> (속성: 색상, 속도 / 행동: 달리다, 멈추다)<br>객체: <strong>구체적 실체</strong> (빨간 소나타, 파란 아반떼)<br>클래스 1개 → 객체 무한개 생성 가능<br><span class='key'>핵심</span> 클래스 = 현실 사물의 추상적 틀 (붕어빵 틀!)" },
            { n: 2, t: "상속의 추상화", d: 4, q: "동물 → 포유류 → 개 → 진돗개의 <strong>상속 계층</strong>에서 추상화 수준 변화를 설명하세요.", a: "동물: 가장 추상적 (숨쉬다, 먹다)<br>포유류: 좀 더 구체적 (+젖을 먹이다)<br>개: 더 구체적 (+짖다, 꼬리 흔들다)<br>진돗개: 가장 구체적 (+특정 외모, 성격)<br><span class='key'>핵심</span> 상속 = 추상화 수준의 계층적 구조" },
            { n: 3, t: "다형성", d: 4, q: "dog.speak() → '멍!', cat.speak() → '야옹!'. 둘 다 <strong>animal.speak()</strong>로 호출 가능한 이유는?", a: "다형성: <strong>같은 이름, 다른 행동</strong><br>animal = Dog()이든 Cat()이든 → speak() 호출 가능!<br>호출하는 쪽: 어떤 동물인지 몰라도 됨<br><span class='key'>핵심</span> 다형성 = '종류에 무관하게' 같은 인터페이스 사용 = 추상화" },
            { n: 4, t: "SOLID: SRP", d: 4, q: "한 클래스가 '사용자 관리'와 '이메일 발송'을 모두 하면 <strong>왜 나쁜 추상화</strong>인가요?", a: "<strong>단일 책임 원칙(SRP) 위반!</strong><br>UserManager: 사용자 CRUD + 이메일 발송 = 2가지 이유로 변경<br>분리: UserManager + EmailService<br><span class='key'>핵심</span> SRP = 한 클래스는 하나의 책임만 = 좋은 추상화의 기본" },
            { n: 5, t: "SOLID: OCP", d: 4, q: "새 결제 수단을 추가할 때 <strong>기존 코드를 수정하지 않는</strong> 설계는 어떤 원칙?", a: "나쁜: if(카드) ... elif(계좌) ... elif(새방법) ... ← <strong>기존 코드 수정!</strong><br>좋은: Payment 인터페이스 → 각 결제 수단이 구현 → 추가만!<br><span class='key'>핵심</span> OCP(개방-폐쇄 원칙) = 확장에 열리고, 수정에 닫힌 추상화" },
            { n: 6, t: "SOLID: DIP", d: 5, q: "고수준 모듈이 저수준 모듈에 <strong>직접 의존하면 안 되는</strong> 이유는?", a: "나쁜: OrderService가 MySQLDB에 직접 의존<br>→ DB를 MongoDB로 바꾸면 OrderService도 수정!<br>좋은: OrderService → <strong>DB 인터페이스</strong> → MySQL/MongoDB<br><span class='key'>핵심</span> DIP = 구체적인 것이 아닌 추상적인 것에 의존하라!" },
            { n: 7, t: "MVC 모델링", d: 4, q: "쇼핑몰을 <strong>MVC</strong>로 설계하세요. Model/View/Controller 각각의 역할은?", a: "<strong>Model:</strong> 상품 데이터, 장바구니, 주문 정보<br><strong>View:</strong> 상품 목록 화면, 장바구니 화면, 결제 화면<br><strong>Controller:</strong> 장바구니 담기, 수량 변경, 결제 처리<br><span class='key'>핵심</span> MVC = 데이터/표현/로직을 분리하는 아키텍처 추상화" },
            { n: 8, t: "어댑터 패턴", d: 4, q: "한국 플러그를 미국 콘센트에 끼우려면 <strong>어댑터</strong>가 필요합니다. 소프트웨어에서도?", a: "기존 API: old_api.get_data() → 새 시스템 기대: new_format.fetch()<br>어댑터: fetch() 호출 → 내부에서 get_data() 실행 → 결과 변환<br><span class='key'>핵심</span> 어댑터 패턴 = 호환되지 않는 인터페이스를 연결하는 추상화" },
            { n: 9, t: "파사드 패턴", d: 4, q: "호텔 프론트 데스크 직원이 <strong>복잡한 내부 시스템</strong>을 대신 처리해줍니다. 어떤 패턴?", a: "내부: 객실 관리 + 수납 + 청소 + 식사 + 주차 시스템<br>고객: <strong>프론트에게 말하기만!</strong> 한 곳만 접촉<br>파사드: check_in() 한 번에 → 5개 시스템 자동 처리<br><span class='key'>핵심</span> 파사드 = 복잡한 서브시스템을 하나의 창구로 추상화" },
            { n: 10, t: "프록시 패턴", d: 5, q: "이미지를 <strong>실제로 로딩하기 전에 썸네일</strong>만 보여주는 것은 어떤 패턴?", a: "프록시(대리인): 원본 이미지 대신 <strong>작은 썸네일 제공</strong><br>스크롤해서 보이면 → 그때서야 원본 로딩!<br>프록시 = 원본과 <strong>같은 인터페이스</strong>지만 내부 동작이 다름<br><span class='key'>핵심</span> 프록시 = 대리자를 통해 접근을 제어하는 추상화" },
            { n: 11, t: "상태 패턴", d: 5, q: "MP3 플레이어: 재생/일시정지/정지 상태에서 <strong>같은 버튼이 다른 동작</strong>. 어떤 패턴?", a: "재생 중 → 버튼 누르면: 일시정지<br>일시정지 → 버튼 누르면: 재생<br>정지 → 버튼 누르면: 처음부터 재생<br>상태에 따라 <strong>행동이 바뀜!</strong><br><span class='key'>핵심</span> 상태 패턴 = 객체의 상태를 객체로 추상화" },
            { n: 12, t: "빌더 패턴", d: 5, q: "피자 주문: 크기→도우→소스→토핑→치즈를 <strong>단계별로 선택</strong>하는 패턴은?", a: "Pizza.builder().size('L').dough('씬').sauce('토마토').topping('페퍼로니').build()<br>매개변수 20개 생성자 → <strong>단계별 빌더</strong>로!<br>필수/선택 속성 분리<br><span class='key'>핵심</span> 빌더 = 복잡한 객체 생성을 단계별로 추상화" },
            { n: 13, t: "UML 클래스 다이어그램", d: 4, q: "학교 시스템의 <strong>UML 클래스 다이어그램</strong>을 설계하세요. 학생/선생님/수업 포함.", a: "학생 ◇—— 수업 (수강 관계)<br>선생님 ◇—— 수업 (강의 관계)<br>학생: {이름, 학번, 학년} + 수강신청()<br>선생님: {이름, 과목} + 수업하다()<br><span class='key'>핵심</span> UML = 소프트웨어 구조의 시각적 추상화" },
            { n: 14, t: "ER 다이어그램", d: 4, q: "<strong>온라인 서점</strong>의 ER(Entity-Relationship) 다이어그램을 설계하세요.", a: "엔티티: 사용자, 책, 주문, 리뷰<br>관계: 사용자 -[주문하다]→ 주문, 주문 -[포함하다]→ 책<br>사용자 -[작성하다]→ 리뷰, 리뷰 -[대상]→ 책<br><span class='key'>핵심</span> ER 다이어그램 = 데이터 관계의 추상적 설계도" },
            { n: 15, t: "마이크로서비스", d: 5, q: "모놀리식 쇼핑몰을 <strong>마이크로서비스</strong>로 분리하세요. 어떤 기준으로 나누나요?", a: "사용자 서비스 / 상품 서비스 / 주문 서비스 / 결제 서비스 / 배송 서비스<br>기준: <strong>비즈니스 도메인</strong>별 분리<br>각각 독립 배포/확장 가능!<br><span class='key'>핵심</span> 마이크로서비스 = 시스템을 도메인 단위로 추상화" },
            { n: 16, t: "이벤트 드리븐", d: 5, q: "주문 완료 → 재고 감소 + 결제 처리 + 이메일 발송을 <strong>이벤트 기반</strong>으로 설계하세요.", a: "OrderService: '주문완료' 이벤트 발행<br>InventoryService: 이벤트 수신 → 재고 감소<br>PaymentService: 이벤트 수신 → 결제<br>EmailService: 이벤트 수신 → 메일 발송<br><span class='key'>핵심</span> 이벤트 드리븐 = 서비스 간 직접 호출 없이 연결" },
            { n: 17, t: "RESTful API", d: 4, q: "학생 CRUD API를 <strong>REST 원칙</strong>으로 설계하세요.", a: "GET /students → 학생 목록<br>GET /students/1 → 1번 학생 조회<br>POST /students → 학생 생성<br>PUT /students/1 → 1번 학생 수정<br>DELETE /students/1 → 1번 학생 삭제<br><span class='key'>핵심</span> REST = 자원+행동을 URL+HTTP메서드로 추상화" },
            { n: 18, t: "계층형 아키텍처", d: 4, q: "프레젠테이션→비즈니스→데이터 <strong>3계층 아키텍처</strong>의 각 역할과 추상화 의미는?", a: "프레젠테이션: 사용자 인터페이스 (화면)<br>비즈니스: 핵심 로직 (규칙, 계산)<br>데이터: 저장소 접근 (DB, 파일)<br>각 층: 바로 아래 층에만 의존!<br><span class='key'>핵심</span> 계층화 = 관심사 분리의 구조적 추상화" },
            { n: 19, t: "도메인 모델링", d: 5, q: "<strong>병원 예약 시스템</strong>의 도메인 모델을 설계하세요. 핵심 엔티티와 관계를 정의.", a: "(자유 응답) 평가 기준:<br>✅ 핵심 엔티티 5개+ (환자, 의사, 예약, 진료, 처방)?<br>✅ 관계 정의?<br>✅ 속성 정의?<br>✅ 행동(메서드) 정의?<br><span class='key'>핵심</span> 도메인 모델 = 비즈니스 현실의 소프트웨어 추상화" },
            { n: 20, t: "종합: 패턴 비교", d: 4, q: "어댑터/파사드/프록시 패턴의 <strong>공통점과 차이점</strong>을 비교표로 정리하세요.", a: "(자유 응답)<br>공통: 모두 <strong>간접 접근</strong> (중간에 객체가 끼임)<br>차이:<br>어댑터: 인터페이스 <strong>변환</strong><br>파사드: 복잡함 <strong>단순화</strong><br>프록시: 접근 <strong>제어</strong>" },
            { n: 21, t: "비지터 패턴", d: 5, q: "트리 구조를 순회하면서 <strong>다른 작업</strong>(출력/합계/검색)을 하고싶을 때 어떤 패턴?", a: "나쁜: 트리 클래스에 print(), sum(), search() 모두 추가<br>비지터: <strong>작업을 외부 객체</strong>로 분리!<br>PrintVisitor, SumVisitor, SearchVisitor<br><span class='key'>핵심</span> 비지터 = 자료구조와 알고리즘을 분리하는 추상화" },
            { n: 22, t: "커맨드 패턴", d: 5, q: "ctrl+Z(실행취소)를 구현하려면? <strong>커맨드 패턴</strong>을 설명하세요.", a: "각 행동을 <strong>객체로 만듦!</strong><br>DeleteCommand: execute() → 삭제, undo() → 복원<br>히스토리 스택: [cmd1, cmd2, cmd3] → undo() = cmd3.undo()<br><span class='key'>핵심</span> 커맨드 = 행동 자체를 객체로 추상화 → 기록/취소 가능" },
            { n: 23, t: "체인 오브 리스폰서빌리티", d: 5, q: "고객 문의: FAQ봇→상담원→팀장→매니저 순서로 처리. <strong>어떤 패턴</strong>인가요?", a: "FAQ봇: 해결 가능? → Yes: 응답 / No: 상담원에게 전달<br>상담원: 해결 가능? → Yes: 응답 / No: 팀장에게 전달<br>...<br><span class='key'>핵심</span> CoR = 요청을 처리할 수 있는 객체를 체인으로 연결하는 추상화" },
            { n: 24, t: "스트래티지 패턴 심화", d: 5, q: "네비게이션 앱에서 <strong>최단거리/최소시간/최소비용</strong> 경로를 바꿀 수 있는 설계는?", a: "RouteStrategy 인터페이스: calculate(start, end)<br>ShortestRoute: 거리 기준 계산<br>FastestRoute: 시간 기준 계산<br>CheapestRoute: 비용 기준 계산<br>Navigator.setStrategy(new FastestRoute())<br><span class='key'>핵심</span> 전략 = 알고리즘을 교체 가능한 객체로 추상화" },
            { n: 25, t: "컴포지트 패턴", d: 5, q: "파일 시스템에서 <strong>파일과 폴더를 같은 방식</strong>으로 다루려면?", a: "FileSystemItem: getSize(), getName()<br>File: getSize() → 파일 크기<br>Folder: getSize() → <strong>내부 모든 항목 크기 합</strong>!<br>폴더 안에 폴더 가능 (재귀적 구조)<br><span class='key'>핵심</span> 컴포지트 = 단일/복합을 같은 인터페이스로 추상화" },
            { n: 26, t: "추상 팩토리", d: 5, q: "윈도우/맥/리눅스에서 <strong>다른 UI를 생성</strong>하지만 코드는 같게 하려면?", a: "UIFactory: createButton(), createMenu()<br>WindowsFactory → WindowsButton, WindowsMenu<br>MacFactory → MacButton, MacMenu<br>app = UIFactory.create() → <strong>OS에 따라 적절한 것 생성</strong><br><span class='key'>핵심</span> 추상 팩토리 = 관련 객체 그룹 생성의 추상화" },
            { n: 27, t: "CQRS", d: 5, q: "<strong>읽기와 쓰기를 분리</strong>하는 CQRS 아키텍처를 학급 성적 관리로 설명하세요.", a: "쓰기(Command): 성적 입력/수정 → <strong>정확성</strong> 중시, 검증 多<br>읽기(Query): 성적 조회/통계 → <strong>속도</strong> 중시, 캐시 사용<br>분리 이유: 최적화 방향이 반대!<br><span class='key'>핵심</span> CQRS = 읽기/쓰기 경로를 분리하는 아키텍처 추상화" },
            { n: 28, t: "헥사고날 아키텍처", d: 6, q: "비즈니스 로직을 <strong>외부 기술(DB, UI, API)에서 독립</strong>시키는 설계는?", a: "중심: <strong>도메인 로직</strong> (비즈니스 규칙)<br>포트: 입출력 인터페이스 (어댑터 연결점)<br>어댑터: DB/웹/CLI 등 구체적 기술<br>DB가 MySQL→MongoDB로 바뀌어도 <strong>도메인 코드 무변경!</strong><br><span class='key'>핵심</span> 헥사고날 = 기술 독립적 비즈니스 로직 추상화" },
            { n: 29, t: "DDD 바운디드 컨텍스트", d: 6, q: "쇼핑몰에서 '상품'이 <strong>상품팀과 배송팀에서 다른 의미</strong>를 가질 때의 해결 방법은?", a: "상품팀: 상품 = 이름, 가격, 설명, 카테고리<br>배송팀: 상품 = 무게, 크기, 배송방법<br>해결: <strong>바운디드 컨텍스트</strong> — 같은 이름이어도 팀별로 다른 모델!<br><span class='key'>핵심</span> 바운디드 컨텍스트 = 맥락별 독립 추상화" },
            { n: 30, t: "종합: 음식배달 앱", d: 5, q: "<strong>음식배달 앱</strong>의 전체 아키텍처를 설계하세요. 서비스, 모델, API, DB 포함.", a: "(자유 응답) 평가 기준:<br>✅ 서비스 분리? (사용자/가게/주문/배달/결제)<br>✅ 데이터 모델?<br>✅ API 설계?<br>✅ 서비스 간 통신?<br>✅ 확장성 고려?" },
            { n: 31, t: "인터페이스 분리", d: 4, q: "프린터/스캐너/팩스 복합기를 <strong>인터페이스로 어떻게 분리</strong>해야 하나요?", a: "나쁜: IMultiFunction(print, scan, fax) ← 프린터만 필요해도 전부 구현!<br>좋은: IPrintable(print), IScannable(scan), IFaxable(fax)<br>프린터: IPrintable만 구현!<br><span class='key'>핵심</span> ISP = 클라이언트에 필요한 인터페이스만 제공하는 추상화" },
            { n: 32, t: "레이어드 보안", d: 5, q: "보안을 <strong>다중 계층</strong>으로 설계하는 이유를 추상화 관점에서 설명하세요.", a: "1.방화벽 2.인증 3.권한 4.암호화 5.로깅<br>각 층: <strong>한 가지 보안 관심사</strong>만 처리<br>하나가 뚫려도 다른 층이 방어!<br><span class='key'>핵심</span> 심층 방어 = 보안 관심사를 계층으로 추상화" },
            { n: 33, t: "SDK 설계", d: 5, q: "결제 SDK를 만든다면 <strong>어떤 인터페이스</strong>를 제공해야 할까요? 사용자 관점에서 설계하세요.", a: "Payment.init(apiKey) → 초기화<br>Payment.pay(amount, method) → 결제<br>Payment.refund(txId) → 환불<br>Payment.getHistory() → 내역 조회<br><span class='key'>핵심</span> SDK = 복잡한 서비스를 개발자-친화적 인터페이스로 추상화" },
            { n: 34, t: "DSL 설계", d: 5, q: "테스트 코드를 <strong>자연어처럼 읽히게</strong> 만드는 DSL 설계 예시를 보여주세요.", a: "expect(calculator.add(2,3)).toBe(5)<br>→ '계산기가 2+3을 더하면 5가 되어야 한다'처럼 읽힘!<br>when(user.login()).then(redirectTo('/home'))<br><span class='key'>핵심</span> 읽기 좋은 DSL = 의도를 코드로 직접 표현하는 고급 추상화" },
            { n: 35, t: "캐시 계층", d: 5, q: "L1 캐시 → L2 캐시 → RAM → SSD → HDD의 <strong>계층적 캐시 구조</strong>는 어떤 추상화?", a: "빠르고 작은 것 → 느리고 큰 것 계층<br>CPU: 가장 가까운 곳(L1)부터 탐색<br>사용자: <strong>'메모리'라는 하나의 개념</strong>으로 인식!<br><span class='key'>핵심</span> 메모리 계층 = 속도/용량 트레이드오프를 숨기는 추상화" },
            { n: 36, t: "가상 메모리", d: 5, q: "RAM이 8GB인데 <strong>16GB를 사용하는 것처럼</strong> 보이는 가상 메모리는 어떤 추상화?", a: "실제: RAM 8GB + SSD 일부를 메모리처럼 사용<br>프로그램: <strong>'연속된 넓은 메모리'</strong>를 가진 것처럼 인식<br>OS가 페이지 교체를 자동 관리<br><span class='key'>핵심</span> 가상 메모리 = 물리 메모리를 추상화하여 무한처럼 보이게" },
            { n: 37, t: "데이터베이스 뷰", d: 4, q: "DB 뷰(View)는 <strong>가상 테이블</strong>입니다. 어떤 추상화 이점이 있나요?", a: "복잡한 JOIN 쿼리 → <strong>단순 테이블처럼</strong> 접근!<br>보안: 민감 열은 숨기고 필요한 열만 노출<br>편의: 자주 쓰는 복잡 쿼리를 저장<br><span class='key'>핵심</span> 뷰 = 복잡 쿼리를 단순 테이블로 추상화" },
            { n: 38, t: "메시지 큐", d: 5, q: "서비스 간 직접 호출 대신 <strong>메시지 큐</strong>를 사용하는 추상화 이점은?", a: "직접: A→B 호출 (B가 죽으면 A도 실패!)<br>큐: A→큐→B (B가 죽어도 큐에 보관! B가 살아나면 처리)<br><strong>비동기 + 신뢰성 + 느슨한 결합</strong><br><span class='key'>핵심</span> 메시지 큐 = 서비스 간 통신을 비동기+안전하게 추상화" },
            { n: 39, t: "GraphQL", d: 5, q: "REST API vs <strong>GraphQL</strong>의 추상화 차이는?", a: "REST: 서버가 응답 형태 결정 (over-fetching/under-fetching 문제)<br>GraphQL: <strong>클라이언트가 필요한 데이터만</strong> 요청!<br>query { user(id:1) { name, email } }<br><span class='key'>핵심</span> GraphQL = 데이터 요청 자체를 추상화 (클라이언트 주도)" },
            { n: 40, t: "종합: 학교 시스템", d: 5, q: "<strong>학교 통합 관리 시스템</strong>을 설계하세요. 학생/교사/수업/성적/출석 모듈 포함.", a: "(자유 응답) 평가 기준:<br>✅ 5개 모듈 설계?<br>✅ 모듈 간 관계?<br>✅ 핵심 클래스/인터페이스?<br>✅ 데이터 모델?<br>✅ 확장성?" },
            { n: 41, t: "추상화 누출", d: 4, q: "'추상화 누출(Leaky Abstraction)'이란? <strong>예시 3가지</strong>를 드세요.", a: "SQL ORM에서 성능 문제 → SQL을 직접 써야 함<br>TCP '신뢰성' → 사실 패킷이 손실될 수 있음<br>가상 메모리 '무한' → 사실 느려질 수 있음<br><span class='key'>핵심</span> 추상화 누출 = 숨긴 복잡성이 밖으로 새어나오는 현상" },
            { n: 42, t: "과잉 추상화", d: 4, q: "2줄짜리 코드를 <strong>5개 클래스로 감싸는 것</strong>은 왜 나쁜 추상화인가요?", a: "YAGNI: You Aren't Gonna Need It!<br>2줄 → 5클래스 = 복잡성만 증가, 이점 없음<br>적절한 추상화 << 과잉 추상화 (오히려 해로움)<br><span class='key'>핵심</span> 좋은 추상화 = 적절한 수준. 너무 적거나 많으면 안 됨" },
            { n: 43, t: "지연 로딩", d: 5, q: "웹 페이지에서 <strong>스크롤할 때 이미지를 로딩</strong>하는 패턴은 어떤 추상화?", a: "처음: 이미지 영역에 <strong>플레이스홀더</strong> 표시<br>스크롤 → 해당 영역이 화면에 나타나면 → <strong>실제 로딩!</strong><br>사용자: '모든 이미지가 있다'고 느낌<br><span class='key'>핵심</span> 지연 로딩 = '있는 것처럼 보이게' 하면서 실제 로딩은 미루는 추상화" },
            { n: 44, t: "서비스 메시", d: 6, q: "마이크로서비스 간 통신을 관리하는 <strong>서비스 메시(Istio)</strong>의 추상화를 설명하세요.", a: "각 서비스 옆에 <strong>사이드카 프록시</strong> 배치<br>서비스: 옆의 프록시에게만 전송하면 됨!<br>프록시: 로드밸런싱, 인증, 모니터링 자동 처리<br><span class='key'>핵심</span> 서비스 메시 = 네트워크 통신을 인프라 수준에서 추상화" },
            { n: 45, t: "IaC", d: 6, q: "서버를 <strong>코드로 관리</strong>하는 Infrastructure as Code(Terraform)는 어떤 추상화?", a: "기존: 서버 한 대씩 수동 설정 (시간↑ 실수↑)<br>IaC: <strong>코드로 선언</strong> → 자동 구축!<br>resource 'server' { cpu=4, memory='16GB' }<br><span class='key'>핵심</span> IaC = 인프라를 코드로 추상화 (버전관리/재현 가능)" },
            { n: 46, t: "클린 아키텍처", d: 6, q: "<strong>의존성 규칙</strong>: 안쪽 원은 바깥쪽 원을 모른다. 이것의 추상화 의미는?", a: "가장 안쪽: <strong>엔티티</strong> (비즈니스 규칙)<br>중간: <strong>유스케이스</strong> (앱 로직)<br>바깥: <strong>컨트롤러/DB/UI</strong> (세부사항)<br>안쪽은 바깥 기술에 <strong>절대 의존하지 않음!</strong><br><span class='key'>핵심</span> 클린 아키텍처 = 비즈니스 로직 순도를 보장하는 추상화" },
            { n: 47, t: "API 게이트웨이", d: 5, q: "10개 마이크로서비스에 <strong>하나의 진입점</strong>을 제공하는 API 게이트웨이의 추상화는?", a: "클라이언트: <strong>게이트웨이 1곳</strong>에만 요청!<br>게이트웨이: 적절한 서비스로 라우팅<br>추가: 인증, 속도 제한, 로깅, 캐싱<br><span class='key'>핵심</span> API 게이트웨이 = 10개 서비스를 1개 진입점으로 추상화 (파사드!)" },
            { n: 48, t: "서킷 브레이커", d: 5, q: "외부 서비스가 응답하지 않을 때 <strong>자동으로 차단</strong>하는 패턴은?", a: "닫힘: 정상 요청 통과<br>실패 연속 → 열림: <strong>즉시 에러 반환</strong> (서비스 보호!)<br>일정 시간 후 → 반열림: 소량 테스트<br><span class='key'>핵심</span> 서킷 브레이커 = 장애 전파를 차단하는 안전장치 추상화" },
            { n: 49, t: "SAGA 패턴", d: 6, q: "분산 트랜잭션에서 <strong>보상 동작</strong>을 설계하는 SAGA 패턴을 여행 예약으로 설명하세요.", a: "1.항공 예약 ✓ → 2.호텔 예약 ✗ (실패!)<br>보상: 1번 항공 예약 <strong>취소!</strong><br>각 단계에 '되돌리기' 정의<br><span class='key'>핵심</span> SAGA = 분산 환경에서 일관성을 보장하는 추상화" },
            { n: 50, t: "종합: 추상화 원칙", d: 5, q: "<strong>좋은 소프트웨어 추상화의 원칙</strong> 7가지를 정리하고 각 예시를 드세요.", a: "(자유 응답) 평가 기준:<br>✅ 7가지 원칙?<br>✅ 각 예시?<br>예: ①단순성 ②최소 인터페이스 ③정보 은닉 ④단일 책임 ⑤적절한 수준 ⑥일관성 ⑦재사용성" },
            { n: 51, t: "템플릿 메서드", d: 5, q: "요리 과정: 재료준비→조리→담기. <strong>공통 흐름은 고정</strong>하고 세부만 바꾸는 패턴은?", a: "CookTemplate: prepare() → cook() → serve()<br>한식: prepare→쌀 씻기, cook→밥 짓기<br>양식: prepare→파스타 삶기, cook→소스 만들기<br><span class='key'>핵심</span> 템플릿 메서드 = 알고리즘 뼈대를 고정하고 세부를 추상화" },
            { n: 52, t: "이터레이터 패턴", d: 4, q: "배열/리스트/트리/해시맵을 <strong>모두 같은 방법</strong>으로 순회하려면?", a: "Iterator: hasNext(), next() 인터페이스<br>ArrayIterator, TreeIterator, HashMapIterator 각각 구현<br>for item in collection: → <strong>내부 구조 무관!</strong><br><span class='key'>핵심</span> 이터레이터 = 자료구조 순회를 통일 인터페이스로 추상화" },
            { n: 53, t: "플라이웨이트", d: 5, q: "게임에서 <strong>나무 10,000그루</strong>를 그릴 때 메모리를 절약하는 패턴은?", a: "공유: 나무 모델(메시, 텍스처) = <strong>1개만</strong> 로드<br>개별: 위치(x,y), 크기 = 나무마다 다름<br>10,000개 × 전체 데이터 → <strong>1개 공유 + 10,000개 좌표</strong><br><span class='key'>핵심</span> 플라이웨이트 = 공유 가능한 부분을 추상화하여 분리" },
            { n: 54, t: "브릿지 패턴", d: 5, q: "<strong>모양(원,사각형) × 색상(빨강,파랑)</strong> 조합이 늘어나는 문제의 해결 패턴은?", a: "나쁜: 빨간원, 파란원, 빨간사각형, 파란사각형... (n×m개!)<br>브릿지: Shape(color) → shape.draw() 내부에서 color.fill()<br>모양과 색상을 <strong>독립적으로</strong> 확장 가능<br><span class='key'>핵심</span> 브릿지 = 두 차원의 변화를 분리하는 추상화" },
            { n: 55, t: "메멘토 패턴", d: 5, q: "텍스트 에디터의 <strong>실행취소(Undo)</strong>를 위해 상태를 저장하는 패턴은?", a: "Memento: 특정 시점의 <strong>상태 스냅샷</strong><br>Editor: createMemento() → 현재 상태 저장<br>Editor: restore(memento) → 과거 상태 복원<br><span class='key'>핵심</span> 메멘토 = 객체 상태의 스냅샷 추상화" },
            { n: 56, t: "중재자 패턴", d: 5, q: "채팅방에서 <strong>모든 사용자가 서로 직접 연결</strong>하면 복잡합니다. 해결 방법은?", a: "직접: N명 → N×(N-1)/2개 연결 (복잡!)<br>중재자(채팅방): 모든 메시지가 <strong>채팅방 서버를 경유</strong><br>N명 → N개 연결만!<br><span class='key'>핵심</span> 중재자 = N:N 관계를 N:1 관계로 추상화" },
            { n: 57, t: "추상화와 테스트", d: 5, q: "추상화가 잘 되어있으면 <strong>테스트가 쉬운</strong> 이유를 설명하세요.", a: "잘된 추상화: 인터페이스로 분리 → <strong>Mock 객체 교체!</strong><br>DB 없이 테스트: MockDB로 교체<br>네트워크 없이 테스트: MockHTTP로 교체<br><span class='key'>핵심</span> 추상화 = 테스트 용이성의 핵심 (의존성 교체 가능)" },
            { n: 58, t: "도메인 이벤트", d: 6, q: "주문 완료 시 '주문완료됨' <strong>이벤트를 발행</strong>하는 패턴의 설계적 의미는?", a: "직접: OrderService가 EmailService.send() 호출 → 강결합!<br>이벤트: OrderService → '주문완료' 이벤트 → 누가 듣든 상관없음<br>EmailService, PointService 등이 <strong>독립적으로 구독!</strong><br><span class='key'>핵심</span> 도메인 이벤트 = 서비스간 결합을 이벤트로 추상화" },
            { n: 59, t: "사이드카 패턴", d: 6, q: "메인 서비스 옆에 <strong>보조 기능(로깅, 모니터링)</strong>을 붙이는 사이드카 패턴은?", a: "메인 앱: 비즈니스 로직에만 집중!<br>사이드카: 로깅, 프록시, 모니터링 등 <strong>공통 인프라 기능</strong> 담당<br>메인 앱 코드 수정 없이 기능 추가!<br><span class='key'>핵심</span> 사이드카 = 횡단 관심사를 분리하는 인프라 추상화" },
            { n: 60, t: "종합: 나만의 패턴북", d: 5, q: "이 레벨에서 <strong>가장 유용한 설계 패턴 TOP 10</strong>을 골라 정리하세요.", h: "패턴명/목적/적용 상황/장단점을 각각 포함", a: "(자유 응답) 평가 기준:<br>✅ 10가지 패턴?<br>✅ 각 목적 설명?<br>✅ 적용 상황?<br>✅ 장단점?<br><span class='key'>핵심</span> 패턴을 아는 것 = 설계 어휘(vocabulary)를 갖는 것!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 4 ? 'hd' : p.d <= 5 ? 'ex' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < Math.min(p.d, 5) ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write tall" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>