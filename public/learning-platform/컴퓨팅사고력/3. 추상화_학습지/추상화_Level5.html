<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🧊 추상화 학습지 Level 5 — 수학·컴퓨터과학 고급 추상화</title>
    <link rel="stylesheet" href="abstraction.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>🧊 추상화(Abstraction) 완전정복</h1>
            <div class="sub">Level 5 · 수학·CS 고급 추상화 — 타입이론·범주론·계산이론·형식화·메타추상화</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span><span
                    class="on"></span><span class="on"></span></div>
            <div class="meta"><span class="tag pri">📘 Level 5/5</span><span class="tag"
                    style="background:#fef2f2;color:#dc2626;border-color:#fca5a5">🔥 난이도 ★★★★★</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 150분+</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fef2f2">🏆</span> 수학·CS 고급 추상화</h2>
            <p>컴퓨터 과학과 수학의 가장 깊은 수준의 추상화를 탐구합니다. <strong>영재/심화 과정</strong> 수준입니다.</p>
            <ul>
                <li><strong>타입 시스템</strong> — 값의 종류를 수학적으로 분류하고 제약</li>
                <li><strong>범주론</strong> — 수학 구조들의 공통 패턴을 추상화</li>
                <li><strong>계산 이론</strong> — 계산 가능성과 한계의 추상화</li>
                <li><strong>형식 검증</strong> — 수학적으로 프로그램의 정확성을 증명</li>
                <li><strong>메타 추상화</strong> — 추상화 자체를 추상화하는 고차 사고</li>
            </ul>
            <div class="warn">이 레벨은 대학 전공 수준의 개념을 포함합니다. 모든 문제를 완벽히 풀지 못해도 괜찮습니다. 사고 과정을 중시하세요!</div>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="추상화_Level4.html">← Level 4</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 5</span>
        </div>
        <div class="ft">🧊 추상화 완전정복 · Level 5/5 · 수학·CS 고급 추상화 60문제 · 🏆 COMPLETE</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "타입 시스템 기초", d: 4, q: "파이썬(동적)과 자바(정적) 타입 시스템의 <strong>추상화 수준 차이</strong>를 설명하세요.", a: "파이썬: 실행 시점에 타입 확인 → <strong>유연하지만</strong> 런타임 에러<br>자바: 컴파일 시점에 타입 확인 → <strong>안전하지만</strong> 코드 장황<br>정적 = 더 많은 것을 컴파일러에 추상화<br><span class='key'>핵심</span> 타입 시스템 = 값의 종류에 대한 수학적 추상화" },
            { n: 2, t: "제네릭", d: 4, q: "List&lt;int&gt;와 List&lt;string&gt;이 <strong>같은 코드</strong>를 공유하는 제네릭은 어떤 추상화?", a: "IntList, StringList, FloatList... 따로 만들기 → <strong>List&lt;T&gt;</strong> 하나!<br>T = 타입 매개변수 → 어떤 타입이든 사용 가능<br>'리스트'라는 구조를 타입에서 추상화<br><span class='key'>핵심</span> 제네릭 = 타입을 매개변수로 추상화 → 코드 재사용!" },
            { n: 3, t: "대수적 타입", d: 5, q: "Result = Success(값) | Error(메시지)와 같은 <strong>합 타입(Sum Type)</strong>의 추상화를 설명하세요.", a: "Result는 둘 중 하나: Success <strong>또는</strong> Error<br>Option = Some(값) | None (값이 있거나 없거나)<br>모든 경우를 <strong>타입 수준에서</strong> 강제 처리!<br><span class='key'>핵심</span> 대수적 타입 = 가능한 상태 집합을 타입으로 추상화" },
            { n: 4, t: "타입 추론", d: 5, q: "x = 42에서 <strong>타입을 명시하지 않아도</strong> int로 추론되는 원리와 추상화는?", a: "컴파일러: 42 → 정수 리터럴 → <strong>자동으로 int 타입 추론!</strong><br>f(x) = x + 1 → x는 숫자 → f는 숫자→숫자 함수<br>Hindley-Milner 알고리즘으로 전체 프로그램 타입 추론 가능<br><span class='key'>핵심</span> 타입 추론 = 명시적 타입 선언을 자동화하는 추상화" },
            { n: 5, t: "모나드 개념", d: 6, q: "모나드를 <strong>상자(Box) 비유</strong>로 설명하세요. Optional/Promise가 왜 모나드인가요?", a: "모나드 = <strong>값을 감싸는 상자</strong> + 규칙<br>Optional: 값이 있거나 없는 상자<br>Promise: 미래의 값을 담는 상자<br>List: 여러 값을 담는 상자<br>규칙: 상자 안에서 함수 적용(flatMap)<br><span class='key'>핵심</span> 모나드 = 부수효과/맥락을 타입으로 추상화하는 패턴" },
            { n: 6, t: "펑터", d: 6, q: "map 함수를 사용할 수 있는 모든 것을 <strong>펑터(Functor)</strong>라 합니다. 설명하세요.", a: "리스트.map(f), Optional.map(f), Promise.then(f)...<br>공통: <strong>'상자 안의 값에 함수 적용'</strong> → 상자는 유지!<br>map: (A→B) → F(A)→F(B)<br><span class='key'>핵심</span> 펑터 = 'map 가능한 것'이라는 추상화 (구조 보존 변환)" },
            { n: 7, t: "타입클래스", d: 6, q: "하스켈의 <strong>타입클래스 Eq</strong>(동등 비교 가능한 타입)는 어떤 추상화인가요?", a: "class Eq a where (==) :: a → a → Bool<br>Int, String, 사용자 타입 모두 <strong>Eq를 구현</strong>하면 비교 가능!<br>장점: 기존 타입에 <strong>나중에</strong> 기능 추가 가능<br><span class='key'>핵심</span> 타입클래스 = '능력'을 타입에 부여하는 추상화 (ad-hoc 다형성)" },
            { n: 8, t: "의존 타입", d: 7, q: "Vector(n, Int) — <strong>길이가 타입에 포함</strong>된 벡터의 추상화 의미는?", a: "Vector(3, Int): 정확히 3개의 정수 벡터<br>append :: Vector(n) → Vector(m) → <strong>Vector(n+m)</strong><br>타입만으로 길이 오류 방지!<br><span class='key'>핵심</span> 의존 타입 = 값에 의존하는 타입 → 더 정밀한 추상화" },
            { n: 9, t: "카테고리 이론", d: 7, q: "범주론에서 대상(Object)과 <strong>사상(Morphism)</strong>이란? 프로그래밍과의 관계는?", a: "대상 = 타입 (Int, String, ...)<br>사상 = 함수 (Int → String, ...)<br>합성: f∘g = 두 함수를 연결<br>항등 사상: id(x) = x<br><span class='key'>핵심</span> 범주론 = 수학적 구조들의 가장 추상적인 추상화" },
            { n: 10, t: "동형사상", d: 7, q: "Bool ≅ {0,1}. 두 타입이 <strong>동형(isomorphic)</strong>이란 무슨 뜻인가요?", a: "f: Bool → {0,1} (True→1, False→0)<br>g: {0,1} → Bool (1→True, 0→False)<br>f∘g = id, g∘f = id → <strong>양방향 변환 가능!</strong><br>정보 손실 없이 변환 = 본질적으로 같은 구조<br><span class='key'>핵심</span> 동형 = '구조적으로 같음'의 수학적 정의" },
            { n: 11, t: "커리-하워드 대응", d: 7, q: "프로그램=증명, 타입=명제. <strong>커리-하워드 대응</strong>을 설명하세요.", a: "A→B 함수가 존재 = 'A이면 B'가 <strong>증명됨!</strong><br>A×B 타입값 존재 = 'A이고 B' 증명됨<br>A|B 타입값 존재 = 'A이거나 B' 증명됨<br><span class='key'>핵심</span> 프로그램 ≅ 수학적 증명 → 타입검사 = 증명검증!" },
            { n: 12, t: "튜링 완전성", d: 5, q: "파이썬이 <strong>튜링 완전(Turing Complete)</strong>하다는 것의 의미와 추상화 관점은?", a: "튜링 완전 = <strong>이론적으로 모든 계산</strong>을 할 수 있음<br>파이썬 ≡ C ≡ 자바 ≡ 튜링 머신 (계산 능력 동일!)<br>언어가 달라도 계산 가능한 것은 같음<br><span class='key'>핵심</span> 튜링 완전성 = 계산 능력의 보편적 추상화 (Church-Turing 논제)" },
            { n: 13, t: "정지 문제", d: 6, q: "'모든 프로그램이 멈추는지 판단하는 프로그램'은 <strong>왜 만들 수 없나요</strong>?", a: "가정: halt(P) = True면 P가 멈춤, False면 무한루프<br>paradox(P): if halt(P) then 무한루프 else 멈춤<br>paradox(paradox) → <strong>모순!</strong><br><span class='key'>핵심</span> 정지 문제 = 추상화의 근본적 한계 (결정 불가능 문제)" },
            { n: 14, t: "괴델 불완전성", d: 7, q: "괴델의 불완전성 정리가 <strong>추상화의 한계</strong>에 대해 말해주는 것은?", a: "충분히 강한 형식 체계에서는<br>참이지만 <strong>증명할 수 없는</strong> 명제가 반드시 존재!<br>= 어떤 추상화도 모든 진실을 포착할 수 없음<br><span class='key'>핵심</span> 불완전성 = 형식 체계(추상화)의 근본적 한계" },
            { n: 15, t: "람다 계산법", d: 6, q: "λx.x+1은 <strong>함수를 수학적으로 표현</strong>하는 방법입니다. 튜링 머신과의 관계는?", a: "λx.x+1 = '입력 x에 1을 더하는 함수'<br>λ 계산법 = 함수만으로 모든 계산 가능!<br>튜링 머신과 <strong>동치</strong> (같은 계산 능력)<br><span class='key'>핵심</span> 람다 계산법 = 계산을 '함수'로만 추상화한 수학 모델" },
            { n: 16, t: "오토마타", d: 5, q: "유한 오토마타(DFA)로 <strong>'짝수 개의 a'</strong>를 포함하는 문자열을 인식하는 추상화는?", a: "상태 2개: S0(짝수), S1(홀수)<br>S0→읽기'a'→S1, S1→읽기'a'→S0<br>시작: S0, 승인상태: S0<br><span class='key'>핵심</span> 오토마타 = 상태 전이를 그래프로 추상화한 계산 모델" },
            { n: 17, t: "정규식과 오토마타", d: 5, q: "정규식 (ab)+와 <strong>유한 오토마타</strong>는 같은 능력입니다. 이 동치의 의미는?", a: "정규식: 패턴을 <strong>기호</strong>로 표현<br>DFA: 패턴을 <strong>상태 그래프</strong>로 표현<br>같은 것을 다른 방식으로! = <strong>표현의 동치</strong><br><span class='key'>핵심</span> 같은 추상화도 여러 형태로 표현 가능" },
            { n: 18, t: "컴파일러 추상화", d: 5, q: "고급 언어→어셈블리→기계어 <strong>컴파일 과정</strong>의 각 단계별 추상화를 설명하세요.", a: "고급 언어: <strong>인간 친화적</strong> (x = a + b)<br>어셈블리: <strong>CPU 친화적</strong> (ADD R1 R2)<br>기계어: <strong>하드웨어</strong> (1010110011)<br>각 단계: 아래 단계의 복잡성을 숨김<br><span class='key'>핵심</span> 컴파일러 = 추상화 수준 간 자동 변환기" },
            { n: 19, t: "AST", d: 5, q: "코드 '2 + 3 * 4'의 <strong>추상 구문 트리(AST)</strong>를 그리고, 추상화 의미를 설명하세요.", a: "텍스트 표현: 2+3*4 (선형, 모호할 수 있음)<br>AST: (+, 2, (*, 3, 4)) (트리, <strong>구조가 명확!</strong>)<br>괄호, 공백, 세미콜론 등 <strong>문법적 장식 제거</strong><br><span class='key'>핵심</span> AST = 코드에서 의미만 남긴 구조적 추상화" },
            { n: 20, t: "종합: 추상화 계층도", d: 5, q: "프로그래밍의 <strong>추상화 계층</strong>을 가장 낮은 것(트랜지스터)부터 가장 높은 것(AI)까지 그리세요.", a: "(자유 응답)<br>예: 트랜지스터→게이트→CPU→기계어→어셈블리→C→Python→프레임워크→AI 서비스<br>각 층: 아래 층의 복잡성을 숨김<br><span class='key'>핵심</span> 컴퓨터 과학 전체 = 추상화의 탑!" },
            { n: 21, t: "모나드 법칙", d: 7, q: "모나드의 <strong>3가지 법칙</strong>(좌항등, 우항등, 결합)을 설명하세요.", a: "1. <strong>좌항등</strong>: return a >>= f ≡ f(a)<br>2. <strong>우항등</strong>: m >>= return ≡ m<br>3. <strong>결합</strong>: (m >>= f) >>= g ≡ m >>= (λx. f(x) >>= g)<br><span class='key'>핵심</span> 모나드 법칙 = 추상화가 올바르게 동작하기 위한 수학적 보장" },
            { n: 22, t: "하스켈 IO", d: 6, q: "하스켈에서 <strong>IO 모나드</strong>로 부수효과를 관리하는 방식의 추상화를 설명하세요.", a: "순수 함수: 같은 입력 → 항상 같은 출력<br>IO: 부수효과가 있는 작업을 <strong>'IO 상자'</strong> 안에 가둠!<br>main :: IO () → 실제 세계와의 인터페이스<br><span class='key'>핵심</span> IO 모나드 = 순수성을 유지하면서 부수효과를 타입으로 추상화" },
            { n: 23, t: "자연수 페아노", d: 6, q: "페아노 공리: 0은 자연수, S(n)은 자연수. <strong>자연수의 추상화</strong>를 설명하세요.", a: "0, S(0)=1, S(S(0))=2, S(S(S(0)))=3...<br>덧셈: a+0=a, a+S(b)=S(a+b)<br>오직 <strong>0과 후계함수 S</strong>만으로 모든 자연수!<br><span class='key'>핵심</span> 페아노 = 자연수를 2가지 규칙만으로 추상화한 수학적 정의" },
            { n: 24, t: "교회 수", d: 7, q: "λ계산법에서 <strong>수를 함수로</strong> 표현하는 교회 수(Church numerals)를 설명하세요.", a: "0 = λf.λx.x (함수 적용 0번)<br>1 = λf.λx.f(x) (1번)<br>2 = λf.λx.f(f(x)) (2번)<br>3 = λf.λx.f(f(f(x))) (3번)<br><span class='key'>핵심</span> 교회 수 = 숫자조차도 함수만으로 추상화 가능!" },
            { n: 25, t: "Y결합자", d: 7, q: "이름 없는 함수로 <strong>재귀</strong>를 구현하는 Y결합자는 어떤 추상화인가요?", a: "Y = λf.(λx.f(x x))(λx.f(x x))<br>이름 없이도 재귀 가능! (자기 참조의 추상화)<br>Y(F) = F(Y(F)) → 고정점!<br><span class='key'>핵심</span> Y결합자 = 재귀를 순수 λ계산법으로 추상화" },
            { n: 26, t: "형식 검증", d: 6, q: "프로그램의 <strong>정확성을 수학적으로 증명</strong>하는 Coq/Isabelle은 어떤 추상화?", a: "테스트: 일부 입력만 확인 (누락 가능)<br>형식 검증: <strong>모든 가능한 입력</strong>에 대해 증명!<br>예: '정렬 함수가 항상 정렬된 결과를 반환함'을 수학적으로 증명<br><span class='key'>핵심</span> 형식 검증 = 프로그램의 성질을 수학 정리로 추상화" },
            { n: 27, t: "호어 로직", d: 6, q: "{사전조건} 코드 {사후조건}으로 <strong>프로그램 정확성</strong>을 표현하는 호어 삼쌍은?", a: "{x>0} y=x*2 {y>0 ∧ y=2x}<br>사전: x > 0이면<br>실행 후: y > 0이고 y = 2x <strong>보장!</strong><br><span class='key'>핵심</span> 호어 로직 = 프로그램 행동을 논리식으로 추상화" },
            { n: 28, t: "불변 조건", d: 5, q: "루프 불변 조건(loop invariant)이 <strong>반복문의 정확성</strong>을 보장하는 방법은?", a: "루프 시작 전: 불변 조건 성립<br>매 반복: 불변 조건 <strong>유지</strong><br>루프 종료 후: 불변 조건 + 종료 조건 → <strong>원하는 결과!</strong><br>예: 합계 반복에서 'sum = a[0]+...+a[i-1]'<br><span class='key'>핵심</span> 불변 조건 = 반복의 정확성을 논리적으로 추상화" },
            { n: 29, t: "계산 복잡도", d: 5, q: "O(n), O(n²), O(log n)은 <strong>알고리즘의 어떤 측면</strong>을 추상화한 것인가요?", a: "실제 실행 시간: CPU 속도, 메모리, OS 등에 따라 천차만별<br>Big-O: <strong>입력 크기에 따른 성장 속도만!</strong><br>O(n²): 입력 2배 → 시간 4배<br>상수, 하드웨어 차이는 무시!<br><span class='key'>핵심</span> Big-O = 시간/공간 효율의 수학적 추상화" },
            { n: 30, t: "종합: NP 문제", d: 6, q: "P=NP 문제를 <strong>추상화 관점</strong>에서 설명하세요. 답을 구하는 것과 검증하는 것의 차이는?", a: "P: 다항 시간에 <strong>풀 수 있는</strong> 문제<br>NP: 다항 시간에 <strong>검증할 수 있는</strong> 문제<br>P=NP? → '검증만큼 빠르게 풀 수 있는가?' = <strong>미해결!</strong><br><span class='key'>핵심</span> 계산 복잡도 = 문제의 본질적 난이도를 추상화" },
            { n: 31, t: "공변/반변", d: 7, q: "List&lt;Cat&gt;을 List&lt;Animal&gt;로 <strong>대입할 수 있나요</strong>? 공변성을 설명하세요.", a: "Cat is Animal → List&lt;Cat&gt; is List&lt;Animal&gt;? = <strong>공변</strong><br>읽기만 하면 OK! (Cat을 Animal로 봄)<br>쓰기하면 위험! (Dog을 넣으면?)<br><span class='key'>핵심</span> 변성(Variance) = 타입 관계가 컨테이너에서 어떻게 유지되는지의 추상화" },
            { n: 32, t: "타입 소거", d: 5, q: "자바에서 <strong>제네릭 타입이 런타임에 사라지는</strong> 타입 소거의 장단점은?", a: "List&lt;Int&gt;와 List&lt;String&gt; → 런타임에 둘 다 <strong>List!</strong><br>장점: 바이트코드 하위 호환<br>단점: 런타임에 타입 정보 없음 (리플렉션 제한)<br><span class='key'>핵심</span> 타입 소거 = 컴파일타임 추상화가 런타임에서 사라지는 현상" },
            { n: 33, t: "팬텀 타입", d: 7, q: "<strong>값이 없지만 타입만 존재</strong>하는 팬텀 타입의 용도는?", a: "data Email = Verified | Unverified<br>send :: Message (Verified) → IO () ← <strong>검증된 이메일만!</strong><br>팬텀 타입: 런타임 비용 0이면서 컴파일타임 안전성!<br><span class='key'>핵심</span> 팬텀 타입 = 상태/제약을 타입 수준에서만 추상화" },
            { n: 34, t: "Effect 시스템", d: 7, q: "함수의 <strong>부수효과(IO, Exception, State)</strong>를 타입으로 추적하는 effect 시스템은?", a: "read :: {IO} Int → IO 효과 있음!<br>pure :: {} Int → 부수효과 없음!<br>타입만 보고 <strong>어떤 효과가 있는지</strong> 알 수 있음<br><span class='key'>핵심</span> Effect 시스템 = 부수효과를 타입 수준에서 추상화/추적" },
            { n: 35, t: "선형 타입", d: 7, q: "값을 <strong>정확히 1번만 사용</strong>할 수 있는 선형 타입의 추상화를 설명하세요.", a: "파일 핸들: open → use → <strong>반드시 close!</strong><br>선형 타입: 'close 안 하면 컴파일 에러!'<br>자원 누수를 <strong>타입 시스템이 방지</strong><br><span class='key'>핵심</span> 선형 타입 = 자원 생명주기를 타입으로 추상화" },
            { n: 36, t: "GADTs", d: 7, q: "일반화된 대수적 타입(GADTs)으로 <strong>안전한 수식 평가기</strong>를 만드는 방법은?", a: "Expr Int: 정수 수식<br>Expr Bool: 불리언 수식<br>Add :: Expr Int → Expr Int → Expr Int ← <strong>정수끼리만!</strong><br>If :: Expr Bool → Expr a → Expr a → Expr a<br><span class='key'>핵심</span> GADTs = 반환 타입을 생성자별로 제한하는 정밀한 추상화" },
            { n: 37, t: "통합 이론", d: 7, q: "프로그래밍 <strong>패러다임(OOP/FP/논리)의 통합</strong> 관점에서 추상화를 설명하세요.", a: "OOP: 데이터+행동 묶음 (<strong>객체</strong> 기반 추상화)<br>FP: 순수 함수 합성 (<strong>함수</strong> 기반 추상화)<br>논리: 규칙과 추론 (<strong>선언</strong> 기반 추상화)<br>현대 언어: 모두 혼합!<br><span class='key'>핵심</span> 각 패러다임 = 같은 문제를 다른 관점에서 추상화" },
            { n: 38, t: "반응형 프로그래밍", d: 6, q: "<strong>Observable/Stream</strong>으로 이벤트를 처리하는 반응형 프로그래밍의 추상화는?", a: "콜백: 이벤트마다 함수 등록 (복잡!)<br>Observable: <strong>이벤트 스트림</strong>으로 추상화!<br>clicks.filter(inArea).map(toCoord).subscribe(draw)<br>이벤트 처리 = 데이터 파이프라인처럼!<br><span class='key'>핵심</span> Rx = 시간에 따른 이벤트를 스트림으로 추상화" },
            { n: 39, t: "속성 기반 테스트", d: 6, q: "모든 입력에 대해 <strong>reverse(reverse(list)) == list</strong>를 테스트하는 방식은?", a: "기존: 특정 입력 3~4개 테스트<br>속성 기반: <strong>1000개 랜덤 입력</strong> 자동 생성 + 속성 검증!<br>속성: '모든 리스트에 대해 reverse∘reverse == id'<br><span class='key'>핵심</span> 속성 기반 테스트 = 개별 예시 대신 <strong>보편적 성질</strong>을 테스트하는 추상화" },
            { n: 40, t: "종합: 추상화 레벨 분석", d: 6, q: "git이 <strong>파일 관리에서 사용하는 추상화 5가지</strong>를 분석하세요.", a: "(자유 응답)<br>예: ①blob(파일 내용 해시) ②tree(디렉토리 구조) ③commit(스냅샷+메타) ④branch(커밋 포인터) ⑤remote(원격 저장소 참조)<br><span class='key'>핵심</span> git의 내부 = 추상화의 걸작!" },
            { n: 41, t: "정보 이론", d: 6, q: "Shannon의 <strong>정보 엔트로피</strong>는 정보를 어떻게 수학적으로 추상화하나요?", a: "H = -Σp(x)log₂p(x)<br>동전: H = 1비트 (2가지 결과)<br>주사위: H ≈ 2.58비트 (6가지 결과)<br>엔트로피↑ = 불확실성↑ = 정보량↑<br><span class='key'>핵심</span> 엔트로피 = '놀라움의 평균'으로 정보를 수치화하는 추상화" },
            { n: 42, t: "크립토 추상화", d: 5, q: "HTTPS에서 <strong>TLS 핸드셰이크</strong>가 숨기는 복잡한 과정을 설명하세요.", a: "사용자: URL에 https:// 입력 → <strong>끝!</strong><br>내부: 서버인증서 확인→공개키 교환→대칭키 생성→암호화 통신 시작<br>수학: RSA/ECDH 알고리즘, AES 대칭암호<br><span class='key'>핵심</span> HTTPS = 복잡한 암호학을 '🔒' 아이콘 하나로 추상화" },
            { n: 43, t: "벡터 공간", d: 6, q: "단어를 <strong>벡터(숫자 배열)</strong>로 표현하는 Word2Vec은 어떤 추상화?", a: "'왕' = [0.3, 0.8, ...], '여왕' = [0.32, 0.85, ...]<br>놀라운 성질: 왕-남자+여자 ≈ <strong>여왕!</strong><br>의미 관계가 벡터 연산으로 표현됨<br><span class='key'>핵심</span> 워드 임베딩 = 단어의 의미를 고차원 벡터 공간으로 추상화" },
            { n: 44, t: "신경망 추상화", d: 6, q: "딥러닝 신경망이 <strong>이미지의 특징을 자동 추출</strong>하는 것은 어떤 추상화인가요?", a: "1층: 엣지(선) 감지 (저수준)<br>2층: 텍스처(질감) 감지<br>3층: 부분(눈, 코) 감지<br>4층: 얼굴 전체 인식 (고수준)<br><span class='key'>핵심</span> 딥러닝 = <strong>추상화 계층을 자동으로 학습!</strong> (기존: 사람이 설계)" },
            { n: 45, t: "양자 컴퓨팅", d: 7, q: "큐비트가 <strong>0과 1을 동시에</strong> 가질 수 있는 중첩 상태는 어떤 추상화인가요?", a: "|ψ⟩ = α|0⟩ + β|1⟩ (0과 1의 확률적 중첩)<br>관측 전: 동시에 여러 상태!<br>관측 후: 하나로 확정 (확률적)<br><span class='key'>핵심</span> 큐비트 = 고전적 비트를 확률적 선형 결합으로 추상화" },
            { n: 46, t: "모듈러 산술", d: 5, q: "시계의 12+3=3(mod 12)은 <strong>어떤 수학적 추상화</strong>인가요?", a: "무한한 정수 → <strong>0~11만 사용하는 순환 구조</strong>!<br>14시 = 2시 (mod 12)<br>암호학, 해싱, 네트워크에서 핵심!<br><span class='key'>핵심</span> 모듈러 산술 = 무한을 유한 순환으로 추상화" },
            { n: 47, t: "라이프니츠의 꿈", d: 7, q: "라이프니츠가 꿈꾼 <strong>'보편 계산 기계'</strong>와 현대 컴퓨터의 관계를 추상화 역사에서 설명하세요.", a: "라이프니츠: '사고를 기호로, 추론을 계산으로'<br>부울: 논리를 0과 1로 추상화<br>튜링: 계산을 기계로 추상화<br>폰 노이만: 프로그램을 데이터로 추상화<br><span class='key'>핵심</span> 컴퓨터 과학 역사 = 추상화 수준의 진화!" },
            { n: 48, t: "표현 독립성", d: 6, q: "같은 알고리즘을 <strong>파이썬과 C로</strong> 구현했을 때 '같다'고 할 수 있는 근거는?", a: "비스무리해 보이는 코드가 <strong>같은 계산</strong>을 수행<br>Operational equivalence: 모든 입력에 대해 같은 출력<br>표현(언어)이 다르지만 <strong>의미(계산)가 같음!</strong><br><span class='key'>핵심</span> 표현 독립 = 구현 세부사항에서 벗어난 알고리즘 추상화" },
            { n: 49, t: "프로그램 변환", d: 6, q: "컴파일러 <strong>최적화(인라이닝, 상수 폴딩)</strong>는 의미를 바꾸지 않으면서 코드를 변환합니다. 어떤 추상화?", a: "인라이닝: 함수 호출 → 본문 복사 (속도↑)<br>상수 폴딩: 3×4 → 12 (컴파일 시 계산)<br>의미 동치: <strong>결과는 동일!</strong> 구현만 다름<br><span class='key'>핵심</span> 최적화 = 의미를 보존하는 프로그램 변환 (의미론적 추상화)" },
            { n: 50, t: "종합: 추상화의 역사", d: 6, q: "<strong>추상화 개념의 역사적 발전</strong>을 10단계로 정리하세요. (고대→현대)", a: "(자유 응답)<br>예: ①숫자발명 ②대수학(변수) ③해석기하학(좌표) ④부울논리 ⑤튜링머신 ⑥프로그래밍언어 ⑦OOP ⑧함수형 ⑨타입이론 ⑩AI/딥러닝<br><span class='key'>핵심</span> 인류 문명 = 추상화의 역사!" },
            { n: 51, t: "고정점 정리", d: 7, q: "f(x)=x인 값 x가 존재하는 <strong>고정점 정리</strong>의 프로그래밍 적용은?", a: "재귀 함수 = 자기 자신의 고정점!<br>factorial = fix(λf.λn.if n==0 then 1 else n*f(n-1))<br>fix(f) = f(fix(f)) → <strong>재귀의 수학적 기반!</strong><br><span class='key'>핵심</span> 고정점 = 재귀와 반복의 수학적 추상화" },
            { n: 52, t: "스콧 도메인", d: 7, q: "부분적 계산 결과를 포함하는 <strong>스콧 도메인</strong>이 프로그래밍 의미론에서 중요한 이유는?", a: "바닥(⊥) = 아직 결과 모름 / 값 = 계산 완료<br>⊥ ⊑ 3: 3은 ⊥보다 더 많은 정보<br>무한 루프 = ⊥ (결과 없음)<br><span class='key'>핵심</span> 도메인 이론 = 계산의 부분성과 근사를 수학적으로 추상화" },
            { n: 53, t: "프로토콜 추상화", d: 5, q: "TCP/IP가 <strong>불안정한 네트워크 위에서 안정적 통신</strong>을 제공하는 추상화를 설명하세요.", a: "물리: 패킷 손실, 순서 뒤바뀜, 중복 발생<br>TCP: <strong>순서 보장, 신뢰성 보장, 흐름 제어</strong>를 자동으로!<br>프로그래머: '안정적 연결'로만 인식<br><span class='key'>핵심</span> TCP = 불안정한 하위 계층을 안정적으로 보이게 하는 추상화" },
            { n: 54, t: "가상 파일 시스템", d: 5, q: "리눅스에서 /dev, /proc 등 <strong>'모든 것이 파일'</strong>이라는 추상화의 의미는?", a: "실제 파일, 디바이스, 프로세스 정보, 네트워크 소켓<br>→ 모두 <strong>파일 연산(open, read, write, close)</strong>으로!<br>통일된 인터페이스 = 강력한 조합 가능<br><span class='key'>핵심</span> 'Everything is a file' = 유닉스의 가장 중요한 추상화 원칙" },
            { n: 55, t: "동시성 모델", d: 6, q: "스레드, 액터, CSP 등 <strong>동시성을 추상화</strong>하는 방법들의 차이를 설명하세요.", a: "스레드: 공유 메모리 + 락 (위험!)<br>액터: <strong>메시지 전달</strong>만 (공유 없음!)<br>CSP: <strong>채널</strong>을 통한 통신 (Go 언어)<br><span class='key'>핵심</span> 동시성 모델 = 병렬 실행의 다양한 추상화 방식" },
            { n: 56, t: "시맨틱 웹", d: 6, q: "웹 데이터에 <strong>의미를 부여</strong>하는 시맨틱 웹(RDF, OWL)의 추상화를 설명하세요.", a: "기존 웹: 사람이 읽는 HTML (의미 없음)<br>시맨틱 웹: <strong>주어-술어-목적어</strong> 삼중으로 의미 표현!<br>(철수, 친구, 영희), (철수, 나이, 12)<br><span class='key'>핵심</span> 시맨틱 웹 = 웹 데이터에 수학적 의미를 부여하는 추상화" },
            { n: 57, t: "흑판 아키텍처", d: 6, q: "AI에서 여러 전문가 시스템이 <strong>공유 공간(흑판)</strong>에 결과를 쓰는 패턴은?", a: "음성 인식: 음향 분석기 + 언어 모델 + 문법 분석기<br>모두 <strong>흑판에 중간 결과</strong>를 씀<br>각 전문가는 서로를 모르지만 흑판을 통해 협력!<br><span class='key'>핵심</span> 흑판 = 다중 모듈 협력을 간접적으로 추상화" },
            { n: 58, t: "메타프로그래밍", d: 6, q: "코드가 <strong>코드를 생성</strong>하는 메타프로그래밍은 어떤 추상화인가요?", a: "일반: data에 대해 작동하는 코드<br>메타: <strong>코드에 대해 작동</strong>하는 코드!<br>예: 매크로, 리플렉션, 코드 생성기<br><span class='key'>핵심</span> 메타프로그래밍 = 프로그램 자체를 데이터로 추상화 (코드=데이터)" },
            { n: 59, t: "추상 해석", d: 7, q: "<strong>추상 해석(Abstract Interpretation)</strong>으로 프로그램을 분석하는 방법은?", a: "구체적 실행: 모든 값 추적 (비용 ∞)<br>추상 해석: 값을 <strong>범위/부호/타입</strong>으로 근사!<br>x ∈ [1,100] → x*2 ∈ [2,200]<br>정확하진 않지만 안전(sound)한 분석!<br><span class='key'>핵심</span> 추상 해석 = 프로그램 동작을 수학적으로 근사 추상화" },
            { n: 60, t: "종합: 추상화 선언문", d: 6, q: "지금까지 배운 모든 것을 종합하여 <strong>'추상화 선언문'</strong>을 작성하세요. 추상화란 무엇이고 왜 중요한지.", h: "개인적 경험, 학습 내용, 미래 비전 포함", a: "(자유 응답) 평가 기준:<br>✅ 추상화의 정의?<br>✅ 왜 중요한지?<br>✅ 컴퓨터과학에서의 역할?<br>✅ 일상에서의 역할?<br>✅ 한계와 주의점?<br>✅ 미래 전망?<br><span class='key'>핵심</span> 추상화 = 컴퓨터 과학의 영혼이자, 인간 사고의 가장 강력한 도구! 🏆" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 5 ? 'hd' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < Math.min(p.d, 5) ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write tall" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>