<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>⚙️ 알고리즘 설계 학습지 Level 3 — 정렬과 탐색</title>
    <link rel="stylesheet" href="algorithm.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>⚙️ 알고리즘 설계(Algorithm Design) 완전정복</h1>
            <div class="sub">Level 3 · 정렬과 탐색 — 버블/선택/삽입 정렬, 순차/이진 탐색</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span
                    class="on"></span><span></span><span></span></div>
            <div class="meta"><span class="tag pri">📘 Level 3/5</span><span class="tag ok">🟡 난이도 ★★★☆☆</span><span
                    class="tag acc">📝 60문제</span><span class="tag">⏱ 80~100분</span></div>
        </div>

        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름을 입력하세요"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>

        <div class="learn">
            <h2><span class="ico" style="background:#fff7ed">📖</span> 정렬과 탐색이란?</h2>
            <p><strong>정렬(Sorting)</strong>은 데이터를 순서대로 배열하는 것, <strong>탐색(Searching)</strong>은 원하는 데이터를 찾는 것입니다. 컴퓨터
                과학에서 가장 기본적이면서 중요한 알고리즘입니다!</p>
            <ul>
                <li><strong>버블 정렬</strong> — 이웃한 두 수를 비교하며 교환 (거품이 올라가듯)</li>
                <li><strong>선택 정렬</strong> — 가장 작은 수를 찾아 앞으로 보내기</li>
                <li><strong>삽입 정렬</strong> — 카드를 정리하듯, 올바른 자리에 삽입</li>
                <li><strong>순차 탐색</strong> — 처음부터 하나씩 비교</li>
                <li><strong>이진 탐색</strong> — 반씩 나눠서 빠르게 찾기 (정렬된 데이터 필요!)</li>
            </ul>
            <div class="tip">정렬된 데이터에서는 이진 탐색이 가능! 1000개에서 최대 10번 비교로 찾을 수 있어요. (2¹⁰=1024)</div>
        </div>

        <div class="ex">
            <h3>📌 예제: 버블 정렬 과정</h3>
            <div class="flow"><span class="s">[5,3,1]</span><span class="a">→</span><span class="s">5↔3 →
                    [3,5,1]</span><span class="a">→</span><span class="s">5↔1 → [3,1,5]</span><span
                    class="a">→</span><span class="s">3↔1 → [1,3,5] ✓</span></div>
            <p>→ 인접한 두 수를 비교하고, 큰 수를 뒤로 보내기를 반복!</p>
        </div>

        <div id="problems"></div>

        <div class="submit-section">
            <p>모든 문제를 풀었나요? 아래 버튼을 눌러 선생님께 제출하세요! 📨</p>
            <button class="btn-submit" id="btn-submit">📄 학습지 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.<br>다운로드된 파일을 선생님께 보내주세요!</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:0.78rem;color:#94a3b8">📁 파일: <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>

        <div class="pg">
            <a href="알고리즘_Level1.html">Level 1</a>
            <a href="알고리즘_Level2.html">← Level 2</a>
            <span class="tag active" style="background:var(--pri);color:#fff;border-color:var(--pri)">Level 3</span>
            <a href="알고리즘_Level4.html">Level 4 →</a>
            <a href="알고리즘_Level5.html">Level 5</a>
        </div>
        <div class="ft">⚙️ 알고리즘 설계 완전정복 · Level 3/5 · 정렬과 탐색 60문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "키 순서 줄 세우기", d: 1, q: "[160, 145, 170, 155, 150]cm 5명을 <strong>키가 작은 순</strong>으로 줄 세우세요. 과정을 보여주세요.", a: "가장 작은 145 → 맨 앞 [145, ...] → 150 → [145,150,...] → 155 → [145,150,155,...] → 160 → [145,150,155,160,170]<br><span class='key'>핵심</span> 선택 정렬의 원리! 매번 최솟값을 찾아 앞으로." },
            { n: 2, t: "카드 정렬 (삽입)", d: 1, q: "손에 [3]을 들고, [7,1,5,2]를 하나씩 받아 <strong>올바른 위치에 삽입</strong>하세요.", a: "[3] → 7 받음: [3,<strong>7</strong>] → 1 받음: [<strong>1</strong>,3,7] → 5 받음: [1,3,<strong>5</strong>,7] → 2 받음: [1,<strong>2</strong>,3,5,7]<br><span class='key'>핵심</span> 삽입 정렬! 새 카드를 받으면 맞는 자리에 끼워넣기." },
            { n: 3, t: "버블 정렬 1회전", d: 2, q: "[4,2,7,1,5]를 버블 정렬로 <strong>1회전(패스)</strong>만 실행하세요. 결과와 교환 횟수는?", a: "4↔2: [<strong>2,4</strong>,7,1,5] (교환) → 4,7: OK → 7↔1: [2,4,<strong>1,7</strong>,5] (교환) → 7↔5: [2,4,1,<strong>5,7</strong>] (교환)<br>1회전 결과: [2,4,1,5,7], 교환 3번<br><span class='key'>핵심</span> 1회전 후 가장 큰 수(7)가 맨 뒤로!" },
            { n: 4, t: "버블 정렬 완전", d: 2, q: "[5,3,4,1,2]를 버블 정렬로 <strong>완전히 정렬</strong>하세요. 모든 회전을 보여주세요.", a: "1회전: [3,4,1,2,<strong>5</strong>] → 2회전: [3,1,2,<strong>4</strong>,5] → 3회전: [1,2,<strong>3</strong>,4,5] → 4회전: [1,<strong>2</strong>,3,4,5](교환 없음)<br><span class='key'>핵심</span> N-1회전이면 완성! 교환 없으면 조기 종료 가능." },
            { n: 5, t: "선택 정렬 추적", d: 2, q: "[64,25,12,22,11]을 <strong>선택 정렬</strong>로 정렬하세요. 각 단계를 추적.", a: "①최소=11, 64↔11: [<strong>11</strong>,25,12,22,64] ②최소=12, 25↔12: [11,<strong>12</strong>,25,22,64] ③최소=22, 25↔22: [11,12,<strong>22</strong>,25,64] ④이미 정렬: [11,12,22,<strong>25</strong>,64]<br><span class='key'>핵심</span> 매 회전마다 '미정렬 구간의 최소'를 앞으로!" },
            { n: 6, t: "순차 탐색", d: 1, q: "[7,2,9,4,6,1,8]에서 <strong>6</strong>을 순차 탐색으로 찾으세요. 비교 횟수는?", a: "7=6? ❌ → 2=6? ❌ → 9=6? ❌ → 4=6? ❌ → 6=6? ✅ → 5번째에서 발견!<br>비교 횟수: <strong>5번</strong><br><span class='key'>핵심</span> 순차 탐색 = 처음부터 끝까지 하나씩. 최악=N번." },
            { n: 7, t: "이진 탐색 기초", d: 2, q: "정렬된 [1,3,5,7,9,11,13]에서 <strong>9</strong>를 이진 탐색으로 찾으세요.", h: "가운데를 보고, 큰지 작은지 비교하여 반씩 줄이세요", a: "①가운데=7, 9>7 → 오른쪽[9,11,13] ②가운데=11, 9<11 → 왼쪽[9] ③가운데=9 → 발견!<br>비교 <strong>3번</strong> (순차면 5번 필요)<br><span class='key'>핵심</span> 이진 탐색 = 매번 절반으로! O(log N)" },
            { n: 8, t: "이진 탐색: 없는 수", d: 2, q: "정렬된 [2,4,6,8,10,12]에서 <strong>7</strong>을 이진 탐색하세요. 결과는?", a: "①가운데=6, 7>6 → 오른쪽[8,10,12] ②가운데=10, 7<10 → 왼쪽[8] ③가운데=8, 7<8 → 왼쪽=빈 배열 ④탐색 실패: <strong>'없음'</strong><br><span class='key'>핵심</span> 범위가 비어지면 = 찾는 값 없음!" },
            { n: 9, t: "정렬 비교: 어떤 게 빠를까?", d: 2, q: "[8,3,6,1,5]를 <strong>버블 정렬과 선택 정렬</strong> 각각으로 정렬하고, <strong>비교 횟수와 교환 횟수</strong>를 세세요.", a: "<strong>버블:</strong> 비교 10번, 교환 약 6번<br><strong>선택:</strong> 비교 10번, 교환 <strong>4번</strong>만<br>비교 횟수는 같지만, 선택 정렬이 교환이 적음!<br><span class='key'>핵심</span> 같은 결과라도 알고리즘마다 효율이 다르다!" },
            { n: 10, t: "삽입 정렬 추적", d: 2, q: "[5,2,4,6,1,3]을 <strong>삽입 정렬</strong>로 정렬하세요.", a: "[<u>5</u>] → 2삽입: [<u>2,5</u>] → 4삽입: [<u>2,4,5</u>] → 6삽입: [<u>2,4,5,6</u>] → 1삽입: [<u>1,2,4,5,6</u>] → 3삽입: [<u>1,2,3,4,5,6</u>]<br><span class='key'>핵심</span> 정렬된 부분에 새 원소를 끼워넣기!" },
            { n: 11, t: "최대/최소 동시 찾기", d: 2, q: "[34,67,12,89,45,23,78,56]에서 <strong>최대와 최소를 동시에</strong> 찾으세요.", a: "① 최대=34, 최소=34(첫 값) ② 67: 최대→67 ③ 12: 최소→12 ④ 89: 최대→89 ⑤ 나머지: 변화 없음<br>결과: 최대=<strong>89</strong>, 최소=<strong>12</strong><br><span class='key'>핵심</span> 한 번의 순회로 둘 다 찾기 = 효율적!" },
            { n: 12, t: "정렬 후 중앙값", d: 2, q: "[7,2,9,4,6]을 정렬하고 <strong>중앙값(median)</strong>을 구하세요.", a: "정렬: [2,4,<strong>6</strong>,7,9]<br>중앙값 = 3번째 = <strong>6</strong><br>짝수 개일 때: [2,4,6,7] → 중앙값=(4+6)÷2=5<br><span class='key'>핵심</span> 중앙값 = 정렬 후 가운데 값!" },
            { n: 13, t: "내림차순 정렬", d: 2, q: "[3,1,4,1,5,9]를 <strong>큰 수부터</strong>(내림차순) 정렬하세요.", a: "오름차순: [1,1,3,4,5,9] → 뒤집기: [<strong>9,5,4,3,1,1</strong>]<br>또는: 비교 시 큰 수를 앞으로 보내면 됨!<br><span class='key'>핵심</span> 비교 방향만 바꾸면 내림차순!" },
            { n: 14, t: "이진 탐색 단계 수", d: 2, q: "1000개의 정렬된 데이터에서 이진 탐색으로 찾으려면 <strong>최대 몇 번</strong> 비교해야 하나요?", a: "1000→500→250→125→63→32→16→8→4→2→1<br>최대 <strong>10번</strong> (2¹⁰=1024>1000)<br>순차 탐색이면 최대 1000번!<br><span class='key'>핵심</span> log₂(1000)≈10 = 이진 탐색의 위력!" },
            { n: 15, t: "안정 정렬 이해", d: 3, q: "[(사과,3), (바나나,1), (체리,3)]을 값으로 정렬할 때, <strong>안정 정렬</strong>이면 사과와 체리의 순서가 어떻게 되나요?", a: "안정 정렬: [(바나나,1), (<strong>사과,3</strong>), (<strong>체리,3</strong>)] → 사과가 체리 앞(원래 순서 유지)<br>불안정 정렬: 사과↔체리 순서 보장 안 됨<br><span class='key'>핵심</span> 안정 정렬 = 같은 값일 때 원래 순서 유지!" },
            { n: 16, t: "두 번째로 큰 수", d: 2, q: "[34,67,12,89,45]에서 <strong>두 번째로 큰 수</strong>를 찾으세요. (정렬하지 말고!)", a: "① 최대=34, 2위=-∞ ② 67>최대 → 2위=34, 최대=67 ③ 12: 변화 없음 ④ 89>최대 → 2위=67, 최대=89 ⑤ 45<89, 45<67: 변화 없음<br>2위=<strong>67</strong><br><span class='key'>핵심</span> 1위가 바뀔 때 기존 1위가 2위로!" },
            { n: 17, t: "거품 찾기", d: 2, q: "버블 정렬에서 1회전 후 <strong>교환이 0번</strong>이면 무슨 뜻인가요?", a: "교환 0번 = <strong>이미 정렬 완료!</strong><br>더 이상 반복할 필요 없음 → 조기 종료(Early Termination)<br>최선의 경우: 이미 정렬된 배열 → O(N)<br><span class='key'>핵심</span> 조기 종료 = 불필요한 작업 줄이기 = 최적화!" },
            { n: 18, t: "이름 사전순 정렬", d: 2, q: "['다희', '가은', '나래', '라온']을 <strong>사전순(가나다순)</strong>으로 정렬하세요.", a: "첫 글자 비교: 가<나<다<라<br>결과: [<strong>가은, 나래, 다희, 라온</strong>]<br><span class='key'>핵심</span> 문자열도 비교 가능! 사전순=첫 글자→두번째→..." },
            { n: 19, t: "이진 탐색 추적표", d: 3, q: "[10,20,30,40,50,60,70,80,90,100]에서 <strong>75</strong>를 이진 탐색. 각 단계의 <strong>왼/오/가운데</strong> 인덱스를 표로.", a: "①왼=0,오=9,중=4(50): 75>50 → 오른쪽<br>②왼=5,오=9,중=7(80): 75<80 → 왼쪽<br>③왼=5,오=6,중=5(60): 75>60 → 오른쪽<br>④왼=6,오=6,중=6(70): 75>70 → 오른쪽<br>⑤왼=7,오=6: 왼>오 → <strong>없음!</strong><br><span class='key'>핵심</span> 왼쪽>오른쪽이 되면 탐색 실패!" },
            { n: 20, t: "정렬 알고리즘 비교", d: 2, q: "버블/선택/삽입 정렬의 <strong>장단점</strong>을 각각 한 줄로 쓰세요.", a: "<strong>버블:</strong> 이해 쉬움, 느림, 조기 종료 가능<br><strong>선택:</strong> 교환 적음(N-1번), 항상 같은 시간<br><strong>삽입:</strong> 거의 정렬된 데이터에 매우 빠름(최선 O(N))<br><span class='key'>핵심</span> 완벽한 알고리즘은 없다! 상황에 따라 선택." },
            { n: 21, t: "역방향 정렬 판별", d: 1, q: "[1,2,3,4,5]와 [5,4,3,2,1] 중 버블 정렬 시 <strong>더 많은 교환이 필요한 것</strong>은?", a: "[1,2,3,4,5]: 교환 <strong>0번</strong> (이미 정렬)<br>[5,4,3,2,1]: 교환 <strong>10번</strong> (모든 쌍 교환 필요)<br><span class='key'>핵심</span> 역순 = 최악의 경우! N(N-1)/2 = 10번" },
            { n: 22, t: "병합 과정", d: 3, q: "이미 정렬된 [1,3,5]와 [2,4,6]을 <strong>하나의 정렬된 배열로 합치세요</strong>.", h: "각 배열의 맨 앞을 비교하여 작은 것부터 넣기", a: "① 1 vs 2 → 1 넣기 [1] ② 3 vs 2 → 2 넣기 [1,2] ③ 3 vs 4 → 3 넣기 [1,2,3] ④ 5 vs 4 → 4 넣기 [1,2,3,4] ⑤ 5 vs 6 → 5 넣기 [1,2,3,4,5] ⑥ 6 넣기 [1,2,3,4,5,6]<br><span class='key'>핵심</span> 병합(Merge) = 병합 정렬의 핵심 연산!" },
            { n: 23, t: "K번째 작은 수", d: 2, q: "[8,3,6,1,5,9,2]에서 <strong>3번째로 작은 수</strong>를 찾으세요.", a: "정렬: [1,2,3,5,6,8,9]<br>3번째 = <strong>3</strong><br>부분 정렬만 해도 가능! 최소 3번 찾기: 1→2→3<br><span class='key'>핵심</span> 전체 정렬 vs 부분 찾기 = 효율 차이!" },
            { n: 24, t: "탐색 비교", d: 2, q: "100개의 데이터에서 값을 찾을 때, <strong>순차 vs 이진 탐색</strong>의 최대 비교 횟수를 비교하세요.", a: "순차: 최대 <strong>100번</strong><br>이진: 최대 <strong>7번</strong> (2⁷=128>100)<br>이진이 100÷7≈<strong>14배</strong> 빠름!<br><span class='key'>핵심</span> 데이터가 정렬되어 있으면 무조건 이진 탐색!" },
            { n: 25, t: "역순 사전 정렬", d: 2, q: "['cat','apple','dog','banana']를 <strong>알파벳 역순</strong>으로 정렬하세요.", a: "알파벳순: [apple, banana, cat, dog]<br>역순: [<strong>dog, cat, banana, apple</strong>]<br><span class='key'>핵심</span> 비교 방향 반대 = 역순!" },
            { n: 26, t: "삽입 정렬 최선/최악", d: 2, q: "삽입 정렬에서 <strong>최선의 입력</strong>과 <strong>최악의 입력</strong>은 어떤 배열인가요?", a: "최선: [1,2,3,4,5] → 이미 정렬! 비교만 4번, 교환 0번 → <strong>O(N)</strong><br>최악: [5,4,3,2,1] → 역순! 매번 전부 밀어야 → <strong>O(N²)</strong><br><span class='key'>핵심</span> 거의 정렬된 데이터 = 삽입 정렬의 최적 환경!" },
            { n: 27, t: "특정 값 개수 세기", d: 1, q: "[1,3,5,3,7,3,9]에서 <strong>3이 몇 개</strong>인지 세세요.", a: "① 카운트=0 ② 각 원소 확인: 1(X), 3(O), 5(X), 3(O), 7(X), 3(O), 9(X) ③ 카운트=<strong>3</strong><br><span class='key'>핵심</span> 순차 탐색+카운트 = 빈도 세기!" },
            { n: 28, t: "이진 탐색 삽입 위치", d: 3, q: "정렬된 [1,3,5,7,9]에 <strong>4를 삽입할 위치</strong>를 이진 탐색으로 찾으세요.", a: "①가운데=5, 4<5 → 왼쪽[1,3] ②가운데=1, 4>1 → 오른쪽[3] ③가운데=3, 4>3 → 오른쪽=빈 → 3 다음 위치=인덱스 <strong>2</strong><br>결과: [1,3,<strong>4</strong>,5,7,9]<br><span class='key'>핵심</span> 이진 탐색은 '찾기'뿐만 아니라 '삽입 위치'도 결정!" },
            { n: 29, t: "정렬 안정성 테스트", d: 3, q: "[(A,2),(B,1),(C,2),(D,1)]을 숫자로 정렬하면? 안정/불안정 정렬 차이를 보여주세요.", a: "<strong>안정:</strong> [(B,1),(D,1),(A,2),(C,2)] → 같은 1끼리 B,D 순서 유지<br><strong>불안정:</strong> [(D,1),(B,1),(A,2),(C,2)] → B,D 순서 바뀔 수도<br><span class='key'>핵심</span> 삽입/버블=안정, 선택=불안정!" },
            { n: 30, t: "종합: 성적표 정렬", d: 3, q: "5명의 이름과 점수를 입력받아 <strong>점수 내림차순</strong>으로 정렬하세요. 동점이면 이름 가나다순.", h: "이중 비교 기준: 1차=점수(내림), 2차=이름(오름)", a: "(자유 응답) 핵심:<br>✅ 데이터 입력(배열)<br>✅ 1차: 점수 비교(내림차순)<br>✅ 동점 시 2차: 이름 비교(오름차순)<br>✅ 정렬 결과 출력<br><span class='key'>핵심</span> 다중 기준 정렬 = 실전에서 가장 많이 쓰는 패턴!" },
            { n: 31, t: "배열 합치기", d: 2, q: "[1,4,7]과 [2,5,8]을 <strong>끼워넣기</strong>하여 [1,2,4,5,7,8]로 만드세요.", a: "① 두 배열에서 각각 포인터 시작 ② 1 vs 2 → 1 ③ 4 vs 2 → 2 ④ 4 vs 5 → 4 ⑤ 7 vs 5 → 5 ⑥ 7 vs 8 → 7 ⑦ 8 → [1,2,4,5,7,8]<br><span class='key'>핵심</span> 두 포인터(Two Pointers) = 병합의 핵심 기법!" },
            { n: 32, t: "카운팅 정렬", d: 3, q: "[3,1,2,3,1,2,1]을 <strong>카운팅 정렬</strong>로 정렬하세요. (범위: 1~3)", a: "① 세기: 1→3개, 2→2개, 3→2개 ② 순서대로 나열: [1,1,1,2,2,3,3]<br>비교 없이 정렬! 비교 기반이 아닌 정렬.<br><span class='key'>핵심</span> 범위가 작으면 카운팅 정렬이 O(N)으로 가장 빠름!" },
            { n: 33, t: "이웃 비교", d: 1, q: "[4,2,7,1,5]에서 <strong>이웃한 두 수</strong> 중 왼쪽이 더 큰 쌍을 모두 찾으세요.", a: "(4,2): 4>2 ✅ → (2,7): 2<7 ❌ → (7,1): 7>1 ✅ → (1,5): 1<5 ❌<br>답: <strong>(4,2)와 (7,1)</strong> 2쌍<br><span class='key'>핵심</span> 이 쌍들이 버블 정렬에서 교환되는 것!" },
            { n: 34, t: "밑에서 찾기", d: 2, q: "[5,8,3,9,1,7,4]에서 값 7을 <strong>뒤에서부터</strong> 순차 탐색하세요. 비교 횟수는?", a: "4=7? ❌ → 7=7? ✅ → 뒤에서 <strong>2번째</strong>에 발견!<br>비교 <strong>2번</strong> (앞에서부터면 6번)<br><span class='key'>핵심</span> 뒤에서 탐색이 더 빠른 경우도 있다!" },
            { n: 35, t: "정렬 확인", d: 2, q: "[1,3,5,4,7,9]가 <strong>오름차순으로 정렬되어 있는지</strong> 확인하는 알고리즘을 쓰세요.", a: "① i=0부터 길이-2까지: ② <strong>만약</strong> 배열[i]>배열[i+1] → '정렬 안 됨!' (5>4에서 발견) ③ 끝까지 통과 → '정렬 됨!'<br><span class='key'>핵심</span> 인접 비교 = 정렬 검증의 기본!" },
            { n: 36, t: "퀵 정렬 분할", d: 3, q: "[7,2,1,6,8,5,3,4]에서 피벗=4로 <strong>분할(Partition)</strong>하세요.", h: "4보다 작은 것 / 4 / 4보다 큰 것으로 나누기", a: "4보다 작은: [2,1,3] / 피벗: [4] / 4보다 큰: [7,6,8,5]<br>결과: [2,1,3, <strong>4</strong>, 7,6,8,5]<br><span class='key'>핵심</span> 분할(Partition) = 퀵 정렬의 핵심! 피벗이 제자리로." },
            { n: 37, t: "가장 가까운 수", d: 2, q: "정렬된 [1,5,10,15,20]에서 <strong>7에 가장 가까운 수</strong>를 찾으세요.", a: "이진 탐색으로 7의 위치 찾기 → 5와 10 사이<br>|7-5|=2, |7-10|=3 → <strong>5</strong>가 더 가까움!<br><span class='key'>핵심</span> 이진 탐색 + 양쪽 이웃 비교 = 가장 가까운 값!" },
            { n: 38, t: "역순 쌍 세기", d: 3, q: "[3,1,4,2]에서 <strong>역순 쌍(i<j인데 a[i]>a[j])</strong>의 수를 세세요.", a: "(3,1): 3>1 ✅ (3,2): 3>2 ✅ (4,2): 4>2 ✅ (1,4): 1<4 ❌ (1,2): 1<2 ❌ (4,2): 이미 셈<br>역순 쌍 = <strong>3개</strong><br><span class='key'>핵심</span> 역순 쌍 수 = 정렬까지 필요한 교환 횟수의 척도!" },
            { n: 39, t: "보간 탐색", d: 3, q: "정렬된 [10,20,30,40,50,60,70,80,90,100]에서 <strong>30</strong>을 찾을 때, 이진 탐색은 중간부터 보는데, 더 똑똑한 방법은?", a: "30은 전체 범위의 약 20% 위치 → 인덱스 2 근처를 먼저 확인!<br>인덱스 = (30-10)/(100-10) × 9 ≈ 2 → 바로 발견!<br><span class='key'>핵심</span> 보간 탐색 = 값의 분포를 활용! 균등 분포일 때 O(log log N)" },
            { n: 40, t: "종합: 정렬 시각화", d: 3, q: "[6,3,8,1,5]를 <strong>버블, 선택, 삽입 정렬 세 가지</strong>로 각각 정렬하고, 각 단계를 모두 추적하세요. 비교/교환 횟수도 세세요.", a: "(자유 응답) 평가 기준:<br>✅ 세 가지 정렬 모두 추적?<br>✅ 각 단계 배열 상태 기록?<br>✅ 비교 횟수/교환 횟수 집계?<br>✅ 세 알고리즘 비교 분석?<br><span class='key'>핵심</span> 직접 추적해야 알고리즘이 진짜 이해됨!" },
            { n: 41, t: "중복 있는 배열 정렬", d: 2, q: "[4,2,4,1,3,2,1]을 정렬하세요. <strong>중복이 있을 때</strong> 주의할 점은?", a: "결과: [1,1,2,2,3,4,4]<br>주의: 같은 값끼리의 순서 → 안정 정렬이면 원래 순서 유지<br><span class='key'>핵심</span> 중복 = 등호(≤ vs <) 처리가 중요!" },
            { n: 42, t: "부분 배열 최대합", d: 3, q: "[-2,1,-3,4,-1,2,1,-5,4]에서 <strong>연속 부분 배열의 최대 합</strong>을 구하세요.", h: "카데인 알고리즘: 현재 합이 음수면 버리고 다시 시작", a: "현재합: -2→1→-2→<strong>4→3→5→6</strong>→1→5<br>최대합 = <strong>6</strong> (부분배열 [4,-1,2,1])<br><span class='key'>핵심</span> 카데인 알고리즘 = O(N)으로 최대 부분합 찾기!" },
            { n: 43, t: "선택 정렬 교환", d: 2, q: "선택 정렬에서 N개 원소를 정렬할 때, <strong>교환은 최대 몇 번</strong>?", a: "매 회전마다 교환 최대 1번 × (N-1)회전 = <strong>N-1번</strong><br>N=5면 최대 4번 교환<br>버블은 최대 N(N-1)/2번!<br><span class='key'>핵심</span> 선택 정렬의 장점 = 교환 횟수 최소!" },
            { n: 44, t: "사전에서 단어 찾기", d: 1, q: "사전에서 'pizza'를 찾는 과정은 <strong>이진 탐색</strong>과 같습니다. 어떻게 찾나요?", a: "① 사전 중간 펴기 → 'M' 주변 ② pizza는 P → 뒷부분으로 ③ 뒷부분 중간 → 'S' 주변 ④ P<S → 앞으로 ⑤ 'P' 섹션 찾기 → pi... → pizza!<br><span class='key'>핵심</span> 사전 = 정렬된 데이터, 단어 찾기 = 이진 탐색!" },
            { n: 45, t: "파티션 분류", d: 2, q: "[3,6,1,8,2,7,4,5]를 <strong>5를 기준</strong>으로 '5 이하'와 '5 초과'로 나누세요.", a: "5 이하: [3,1,2,4,5] / 5 초과: [6,8,7]<br><span class='key'>핵심</span> 파티션 = 기준값으로 두 그룹 분류 = 퀵 정렬의 핵심!" },
            { n: 46, t: "정렬 시간 예측", d: 2, q: "버블 정렬로 100개를 1초에 정렬하면, <strong>1000개</strong>는 약 몇 초?", a: "버블 = O(N²)<br>100개: 100² = 10,000 연산 → 1초<br>1000개: 1000² = 1,000,000 연산 → <strong>약 100초!</strong><br><span class='key'>핵심</span> 데이터 10배 → 시간 100배 = N²의 무서움!" },
            { n: 47, t: "최빈값 정렬 활용", d: 2, q: "[3,1,4,1,5,9,2,6,5,3,5]에서 <strong>최빈값</strong>을 정렬을 이용해 찾으세요.", a: "정렬: [1,1,2,3,3,4,5,<strong>5,5</strong>,6,9]<br>같은 수끼리 연속 → 가장 긴 연속=<strong>5</strong>(3번!)<br><span class='key'>핵심</span> 정렬하면 같은 값이 모임 → 최빈값 찾기 쉬워짐!" },
            { n: 48, t: "두 배열 교집합", d: 3, q: "[1,3,5,7,9]와 [2,3,5,8,9]의 <strong>교집합</strong>을 구하세요. (둘 다 정렬됨)", a: "두 포인터: i=0,j=0<br>1<2: i++ → 3=3: 추가! i++,j++ → 5=5: 추가! → 7>8: j++ → 7<8: i++ → 9=9: 추가!<br>교집합: [<strong>3,5,9</strong>]<br><span class='key'>핵심</span> 정렬된 두 배열 = 두 포인터로 O(N)!" },
            { n: 49, t: "정렬 알고리즘 판별", d: 2, q: "다음은 어떤 정렬?<br>'매 단계에서 남은 원소 중 가장 작은 것을 찾아 현재 위치에 놓는다'", a: "<strong>선택 정렬(Selection Sort)!</strong><br>'가장 작은 것을 찾아' = 최솟값 탐색<br>'현재 위치에 놓는다' = 교환<br><span class='key'>핵심</span> 알고리즘을 설명만 보고 판별하는 능력!" },
            { n: 50, t: "종합: 온라인 쇼핑 정렬", d: 3, q: "온라인 쇼핑몰의 상품 목록을 <strong>①가격순 ②인기순 ③최신순</strong>으로 정렬하는 알고리즘을 설계하세요. 사용자가 선택한 기준으로.", a: "(자유 응답) 핵심:<br>✅ 정렬 기준 선택(조건 분기)<br>✅ 각 기준에 맞는 비교 함수<br>✅ 동일 기준일 때 2차 정렬 기준<br>✅ 오름/내림차순 토글<br><span class='key'>핵심</span> 비교 함수만 바꾸면 모든 기준 정렬 가능!" },
            { n: 51, t: "직접 정렬 설계", d: 2, q: "자기만의 <strong>새로운 정렬 방법</strong>을 하나 생각해보세요. [5,1,3,4,2]에 적용하세요.", h: "어떤 방법이든 OK! 결과만 정렬되면 됩니다", a: "(자유 응답) 예시: '짝수 먼저, 홀수 나중에 각각 정렬'<br>[2,4,1,3,5] → 이것도 유효한 정렬!<br><span class='key'>핵심</span> 정렬 알고리즘은 무한히 많다! 효율이 핵심." },
            { n: 52, t: "병합 정렬 분할", d: 3, q: "[8,3,5,1,4,2,7,6]을 <strong>병합 정렬의 분할 단계</strong>만 보여주세요.", a: "[8,3,5,1,4,2,7,6]<br>→ [8,3,5,1] / [4,2,7,6]<br>→ [8,3] / [5,1] / [4,2] / [7,6]<br>→ [8]/[3] / [5]/[1] / [4]/[2] / [7]/[6]<br><span class='key'>핵심</span> 계속 반으로! 1개가 될 때까지 = 분할 정복!" },
            { n: 53, t: "정렬 후 중복 제거", d: 2, q: "[4,2,7,2,4,1,7,3]을 정렬 후 <strong>중복을 제거</strong>하세요.", a: "정렬: [1,2,2,3,4,4,7,7]<br>중복 제거: 이전 값과 같으면 건너뛰기 → [<strong>1,2,3,4,7</strong>]<br><span class='key'>핵심</span> 정렬 후 중복 제거 = 인접 비교만 하면 O(N)!" },
            { n: 54, t: "하한/상한 탐색", d: 3, q: "정렬된 [1,2,2,2,3,4,5]에서 <strong>2가 시작하는 위치</strong>와 <strong>끝나는 위치</strong>를 찾으세요.", a: "하한(Lower Bound): 인덱스 <strong>1</strong> (첫 번째 2)<br>상한(Upper Bound): 인덱스 <strong>4</strong> (2 다음인 3의 위치)<br>2의 개수 = 4-1 = <strong>3개</strong><br><span class='key'>핵심</span> 이진 탐색 변형으로 범위 찾기!" },
            { n: 55, t: "탐색과 정렬 관계", d: 2, q: "정렬이 <strong>탐색을 빠르게</strong> 만드는 이유를 설명하세요.", a: "정렬 안 됨 → 순차 탐색만 가능 → O(N)<br>정렬 됨 → 이진 탐색 가능 → O(log N)<br>N=1만: 순차=1만번 vs 이진=14번!<br><span class='key'>핵심</span> 정렬 비용(O(N log N))을 투자하면 탐색이 기하급수적으로 빨라짐!" },
            { n: 56, t: "상위 3개 추출", d: 2, q: "[45,78,23,91,56,34,87,12]에서 <strong>상위 3개</strong>를 추출하세요.", a: "방법1: 전체 내림차순 정렬 → 앞 3개: [<strong>91, 87, 78</strong>]<br>방법2: 3번 최대값 찾기(찾은 후 제거) → 91→87→78<br><span class='key'>핵심</span> 전체 정렬 vs 부분 탐색 = 트레이드오프!" },
            { n: 57, t: "순위 매기기", d: 2, q: "[78,92,65,92,88]명의 <strong>순위</strong>를 매기세요. 동점은 같은 순위.", a: "92→1위(2명), 88→3위, 78→4위, 65→5위<br>순위 = 나보다 높은 점수의 수 + 1<br><span class='key'>핵심</span> 정렬+동점처리 = 순위 알고리즘!" },
            { n: 58, t: "버블 정렬 최적화", d: 3, q: "버블 정렬에서 <strong>이미 정렬된 부분은 건너뛰는</strong> 최적화를 설명하세요.", a: "마지막 교환 위치를 기억!<br>예: [1,2,5,3,4,6,7,8] → 5↔3, 5↔4 교환 → 마지막 교환=인덱스3<br>다음 회전: 인덱스3까지만 확인 (6,7,8은 이미 정렬)<br><span class='key'>핵심</span> 불필요한 비교 줄이기 = 실전 최적화!" },
            { n: 59, t: "이진 탐색 재귀", d: 3, q: "이진 탐색을 <strong>재귀(함수가 자기 자신을 호출)</strong>로 쓰세요.", a: "binarySearch(배열, 목표, 왼, 오):<br>① <strong>만약</strong> 왼>오 → '없음' ② 중=⌊(왼+오)/2⌋ ③ <strong>만약</strong> 배열[중]=목표 → 중 반환 ④ <strong>만약</strong> 배열[중]<목표 → binarySearch(배열, 목표, 중+1, 오) ⑤ 아니면 → binarySearch(배열, 목표, 왼, 중-1)<br><span class='key'>핵심</span> 재귀 = 문제를 작은 문제로 줄여가며 해결!" },
            { n: 60, t: "종합: 알고리즘 올림픽", d: 3, q: "같은 배열 [9,1,5,3,7,4,8,2,6]를 <strong>5가지 다른 정렬 알고리즘</strong>으로 정렬하고, 각각의 장단점을 비교 분석하세요.", h: "버블/선택/삽입/카운팅/병합 중 5가지", a: "(자유 응답) 평가 기준:<br>✅ 5가지 알고리즘 각각 추적?<br>✅ 비교/교환 횟수 집계?<br>✅ 시간 복잡도 분석?<br>✅ 장단점 비교표?<br>✅ 상황별 최적 알고리즘 추천?<br><span class='key'>핵심</span> 직접 비교해봐야 차이를 실감할 수 있다!" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => {
            const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : p.d <= 3 ? 'hd' : 'ex'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join('');
            c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div>${p.h ? `<div class="hint">${p.h}</div>` : ''}<textarea class="write" placeholder="✍️ 여기에 작성하세요"></textarea><details class="ans"><summary>정답 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`;
        });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>