<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💻 알고리즘 설계 → C언어 (보통) — 탐색·정렬·재귀</title>
    <link rel="stylesheet" href="ct_c.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>💻 알고리즘 설계(Algorithm Design) → C언어</h1>
            <div class="sub">보통 · 탐색·정렬·재귀</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span></span></div>
            <div class="meta"><span class="tag pri"
                    style="background:rgba(245,158,11,.1);border-color:rgba(245,158,11,.3);color:#f59e0b">⚙️ 알고리즘
                    설계</span><span class="tag warn">🟡 보통</span><span class="tag acc">📝 20문제</span><span class="tag">⏱
                    50~70분</span></div>
        </div>
        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>
        <div class="learn">
            <h2><span class="ico" style="background:rgba(245,158,11,.15)">⚙️</span> 보통 난이도 안내</h2>
            <p>이진 탐색, 삽입 정렬, 재귀, 분할 정복 등 <strong>효율적인 알고리즘 설계 기법</strong>을 학습합니다!</p>
            <div class="tip">💡 같은 문제를 더 빠르게 푸는 것이 알고리즘 설계의 핵심!</div>
        </div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p><button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg"><a href="알고리즘설계_C언어_쉬움.html">← 쉬움</a><span class="tag active">보통</span><a
                href="알고리즘설계_C언어_어려움.html">어려움 →</a></div>
        <div class="ft">💻 CT → C언어 · 알고리즘 설계 · 보통 20문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "이진 탐색 알고리즘", d: 3, q: "<strong>정렬된 배열</strong>에서 이진 탐색. key=7의 위치는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>5</span>,<span class='num'>7</span>,<span class='num'>9</span>,<span class='num'>11</span>};<br><span class='ln'>2</span><span class='type'>int</span> lo=<span class='num'>0</span>,hi=<span class='num'>5</span>,key=<span class='num'>7</span>;<br><span class='ln'>3</span><span class='kw'>while</span>(lo<=hi){<br><span class='ln'>4</span>    <span class='type'>int</span> mid=(lo+hi)/<span class='num'>2</span>;<br><span class='ln'>5</span>    <span class='kw'>if</span>(a[mid]==key){<span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,mid);<span class='kw'>break</span>;}<br><span class='ln'>6</span>    <span class='kw'>else if</span>(a[mid]&lt;key) lo=mid+<span class='num'>1</span>;<br><span class='ln'>7</span>    <span class='kw'>else</span> hi=mid-<span class='num'>1</span>;<br><span class='ln'>8</span>}</div>", a: "<span class='key'>출력</span> <code>3</code><br><span class='step'>추적</span><div class='trace'>lo=0,hi=5 → mid=2: a[2]=5<7 → lo=3<br>lo=3,hi=5 → mid=4: a[4]=9>7 → hi=3<br>lo=3,hi=3 → mid=3: a[3]=<span class='val'>7</span>==7 → 출력 3!</div><div class='explain'>💡 <strong>이진 탐색</strong>: 매번 절반 제거! 6개 원소를 3번 비교로 발견. 선형 탐색 O(n) → 이진 탐색 O(log n). 단, 배열이 <strong>정렬</strong>되어 있어야 사용 가능!</div>" },
            { n: 2, t: "삽입 정렬 알고리즘", d: 3, q: "삽입 정렬 진행 과정. 2회전(i=2) 후 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>5</span>,<span class='num'>3</span>,<span class='num'>1</span>,<span class='num'>4</span>,<span class='num'>2</span>};<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>5</span>;i++){<br><span class='ln'>3</span>    <span class='type'>int</span> key=a[i],j=i-<span class='num'>1</span>;<br><span class='ln'>4</span>    <span class='kw'>while</span>(j>=<span class='num'>0</span>&&a[j]>key){a[j+<span class='num'>1</span>]=a[j];j--;}<br><span class='ln'>5</span>    a[j+<span class='num'>1</span>]=key;<br><span class='ln'>6</span>}</div>", a: "<span class='key'>2회전 후</span> {<strong>1, 3, 5</strong>, 4, 2}<br><span class='step'>추적</span><div class='trace'>i=1: key=3, j=0: a[0]=5>3→a[1]=5, j=-1 → a[0]=3<br>배열: {<span class='val'>3,5</span>,1,4,2}<br><br>i=2: key=1, j=1: a[1]=5>1→a[2]=5, j=0<br>j=0: a[0]=3>1→a[1]=3, j=-1 → a[0]=1<br>배열: {<span class='val'>1,3,5</span>,4,2}</div><div class='explain'>💡 <strong>삽입 정렬</strong>: 카드를 정리하듯 올바른 위치에 '삽입'! 이미 정렬된 앞부분에 新 원소를 끼워넣기. 거의 정렬된 데이터에 매우 빠름 O(n)!</div>" },
            { n: 3, t: "재귀 팩토리얼", d: 2, q: "재귀로 팩토리얼 계산. <strong>호출 흐름</strong>을 추적하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>fact</span>(<span class='type'>int</span> n){<br><span class='ln'>2</span>    <span class='kw'>if</span>(n<=<span class='num'>1</span>) <span class='kw'>return</span> <span class='num'>1</span>;<br><span class='ln'>3</span>    <span class='kw'>return</span> n * <span class='fn'>fact</span>(n-<span class='num'>1</span>);<br><span class='ln'>4</span>}<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,<span class='fn'>fact</span>(<span class='num'>5</span>));</div>", a: "<span class='key'>출력</span> <code>120</code><br><span class='step'>호출 흐름</span><div class='trace'>fact(5) → 5 × fact(4)<br>  fact(4) → 4 × fact(3)<br>    fact(3) → 3 × fact(2)<br>      fact(2) → 2 × fact(1)<br>        fact(1) → <span class='val'>1</span> (기저 조건)<br>      return 2×1 = 2<br>    return 3×2 = 6<br>  return 4×6 = 24<br>return 5×24 = <span class='val'>120</span></div><div class='explain'>💡 <strong>재귀</strong>: 자기 자신을 호출! 핵심 2가지: ①기저 조건(n<=1) ②점점 작아지는 인자(n-1). 기저 조건 없으면 무한 루프(스택 오버플로)!</div>" },
            { n: 4, t: "재귀 vs 반복 비교", d: 2, q: "같은 합계를 재귀와 반복으로. <strong>차이점</strong>은?<div class='code-block'><span class='cm'>// 재귀</span><br><span class='type'>int</span> <span class='fn'>sumR</span>(<span class='type'>int</span> n){<span class='kw'>return</span> n<=<span class='num'>0</span>?<span class='num'>0</span>:n+<span class='fn'>sumR</span>(n-<span class='num'>1</span>);}<br><br><span class='cm'>// 반복</span><br><span class='type'>int</span> <span class='fn'>sumL</span>(<span class='type'>int</span> n){<span class='type'>int</span> s=<span class='num'>0</span>;<span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=n;i++)s+=i;<span class='kw'>return</span> s;}<br><br><span class='fn'>printf</span>(<span class='str'>\"%d %d\"</span>,<span class='fn'>sumR</span>(<span class='num'>5</span>),<span class='fn'>sumL</span>(<span class='num'>5</span>));</div>", a: "<span class='key'>출력</span> <code>15 15</code> (결과 동일!)<br><span class='step'>차이점</span><div class='trace'>재귀: 코드 간결, 스택 사용(메모리↑), 함수 호출 오버헤드<br>반복: 코드 조금 길지만, 효율적, 스택 미사용</div><div class='explain'>💡 <strong>재귀↔반복은 상호 변환 가능</strong>! 트리/그래프 탐색은 재귀가 자연스럽고, 단순 누적은 반복이 효율적. 상황에 맞게 선택!</div>" },
            { n: 5, t: "하노이 탑 알고리즘", d: 3, q: "원판 3개의 <strong>하노이 탑</strong>. 이동 순서는?<div class='code-block'><span class='type'>void</span> <span class='fn'>hanoi</span>(<span class='type'>int</span> n,<span class='type'>char</span> from,<span class='type'>char</span> to,<span class='type'>char</span> via){<br>    <span class='kw'>if</span>(n==<span class='num'>1</span>){<span class='fn'>printf</span>(<span class='str'>\"%c→%c \"</span>,from,to);<span class='kw'>return</span>;}<br>    <span class='fn'>hanoi</span>(n-<span class='num'>1</span>,from,via,to);<br>    <span class='fn'>printf</span>(<span class='str'>\"%c→%c \"</span>,from,to);<br>    <span class='fn'>hanoi</span>(n-<span class='num'>1</span>,via,to,from);<br>}<br><span class='fn'>hanoi</span>(<span class='num'>3</span>,<span class='str'>'A'</span>,<span class='str'>'C'</span>,<span class='str'>'B'</span>);</div>", a: "<span class='key'>출력</span> <code>A→C A→B C→B A→C B→A B→C A→C</code> (7회 이동)<br><span class='step'>분할정복 핵심</span><div class='trace'>n=3: ①상위2개 A→B, ②바닥 A→C, ③상위2개 B→C<br>n개 원판 = 2ⁿ-1회 이동 (3개면 7회)</div><div class='explain'>💡 <strong>분할 정복</strong>의 교과서! 큰 문제(n개)를 작은 문제(n-1개)로 분해. 재귀적 사고의 정수!</div>" },
            { n: 6, t: "병합(Merge) 알고리즘", d: 3, q: "정렬된 두 배열을 <strong>하나로 병합</strong>. 결과는?<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>5</span>},b[]={<span class='num'>2</span>,<span class='num'>4</span>,<span class='num'>6</span>},c[<span class='num'>6</span>];<br><span class='type'>int</span> i=<span class='num'>0</span>,j=<span class='num'>0</span>,k=<span class='num'>0</span>;<br><span class='kw'>while</span>(i&lt;<span class='num'>3</span>&&j&lt;<span class='num'>3</span>)<br>    c[k++]=(a[i]<=b[j])?a[i++]:b[j++];<br><span class='kw'>while</span>(i&lt;<span class='num'>3</span>) c[k++]=a[i++];<br><span class='kw'>while</span>(j&lt;<span class='num'>3</span>) c[k++]=b[j++];</div>", a: "<span class='key'>결과</span> c = {1, 2, 3, 4, 5, 6}<br><span class='step'>추적</span><div class='trace'>a[0]=1<b[0]=2 → c[0]=<span class='val'>1</span>, i=1<br>a[1]=3>b[0]=2 → c[1]=<span class='val'>2</span>, j=1<br>a[1]=3<b[1]=4 → c[2]=<span class='val'>3</span>, i=2<br>a[2]=5>b[1]=4 → c[3]=<span class='val'>4</span>, j=2<br>a[2]=5<b[2]=6 → c[4]=<span class='val'>5</span>, i=3<br>나머지: c[5]=<span class='val'>6</span></div><div class='explain'>💡 <strong>병합</strong>: 두 포인터(i,j)로 작은 것부터 선택! 병합 정렬(Merge Sort)의 핵심 연산. O(n) 시간에 두 정렬 배열을 하나로!</div>" },
            { n: 7, t: "빠른 거듭제곱", d: 3, q: "O(log n)으로 거듭제곱 계산. 결과는?<div class='code-block'><span class='type'>long long</span> <span class='fn'>fastPow</span>(<span class='type'>long long</span> b,<span class='type'>int</span> e){<br>    <span class='type'>long long</span> r=<span class='num'>1</span>;<br>    <span class='kw'>while</span>(e><span class='num'>0</span>){<br>        <span class='kw'>if</span>(e%<span class='num'>2</span>) r*=b;<br>        b*=b; e/=<span class='num'>2</span>;<br>    }<br>    <span class='kw'>return</span> r;<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%lld\"</span>,<span class='fn'>fastPow</span>(<span class='num'>2</span>,<span class='num'>10</span>));</div>", a: "<span class='key'>출력</span> <code>1024</code><br><span class='step'>추적</span><div class='trace'>b=2,e=10: 짝수→r=1, b=4, e=5<br>b=4,e=5: 홀수→r=4, b=16, e=2<br>b=16,e=2: 짝수→r=4, b=256, e=1<br>b=256,e=1: 홀수→r=4×256=<span class='val'>1024</span>, e=0</div><div class='explain'>💡 <strong>빠른 거듭제곱</strong>: 지수를 절반씩 줄이며 밑을 제곱! 2¹⁰ 계산에 10번×가 아닌 4번만! O(n)→O(log n). 암호학(RSA)의 핵심!</div>" },
            { n: 8, t: "문자열 뒤집기(재귀)", d: 2, q: "재귀로 문자열을 뒤집기. 결과는?<div class='code-block'><span class='type'>void</span> <span class='fn'>rev</span>(<span class='type'>char</span>*s,<span class='type'>int</span> l,<span class='type'>int</span> r){<br>    <span class='kw'>if</span>(l>=r) <span class='kw'>return</span>;<br>    <span class='type'>char</span> t=s[l];s[l]=s[r];s[r]=t;<br>    <span class='fn'>rev</span>(s,l+<span class='num'>1</span>,r-<span class='num'>1</span>);<br>}<br><span class='type'>char</span> s[]=<span class='str'>\"ABCDE\"</span>;<br><span class='fn'>rev</span>(s,<span class='num'>0</span>,<span class='num'>4</span>);<br><span class='fn'>printf</span>(<span class='str'>\"%s\"</span>,s);</div>", a: "<span class='key'>출력</span> <code>EDCBA</code><br><span class='step'>추적</span><div class='trace'>rev(0,4): swap A↔E → \"EBCDA\", rev(1,3)<br>rev(1,3): swap B↔D → \"EDCBA\", rev(2,2)<br>rev(2,2): l>=r → 종료</div><div class='explain'>💡 반복 뒤집기와 같은 로직이지만 <strong>재귀로 표현</strong>! l++, r-- 대신 rev(l+1,r-1) 호출. 기저 조건: l>=r(중앙 도달).</div>" },
            { n: 9, t: "순열(Permutation) 생성", d: 3, q: "3개 원소의 <strong>모든 순열</strong>을 생성하는 재귀. 몇 개?<div class='code-block'><span class='type'>void</span> <span class='fn'>perm</span>(<span class='type'>int</span> a[],<span class='type'>int</span> l,<span class='type'>int</span> r){<br>    <span class='kw'>if</span>(l==r){<span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i<=r;i++)<span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,a[i]);<span class='fn'>printf</span>(<span class='str'>\" \"</span>);}<br>    <span class='kw'>for</span>(<span class='type'>int</span> i=l;i<=r;i++){<br>        <span class='type'>int</span> t=a[l];a[l]=a[i];a[i]=t; <span class='cm'>// swap</span><br>        <span class='fn'>perm</span>(a,l+<span class='num'>1</span>,r);<br>        t=a[l];a[l]=a[i];a[i]=t; <span class='cm'>// 복원</span><br>    }<br>}<br><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>};<br><span class='fn'>perm</span>(a,<span class='num'>0</span>,<span class='num'>2</span>);</div>", a: "<span class='key'>출력</span> <code>123 132 213 231 321 312</code> (3!=6개)<br><span class='step'>원리</span><div class='trace'>첫 번째 자리에 1,2,3을 순서대로 고정<br>→ 나머지 자리에 대해 재귀적으로 순열 생성<br>→ 복원(backtrack)하여 다음 경우 시도</div><div class='explain'>💡 <strong>백트래킹</strong>: swap→재귀→swap(복원)! 가능한 모든 경우를 체계적으로 탐색. n! 개의 순열을 빠짐없이 생성!</div>" },
            { n: 10, t: "에라토스테네스의 체", d: 3, q: "1~20 사이 <strong>소수 찾기</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> sieve[<span class='num'>21</span>]={<span class='num'>0</span>}; <span class='cm'>// 0=소수 후보</span><br><span class='ln'>2</span>sieve[<span class='num'>0</span>]=sieve[<span class='num'>1</span>]=<span class='num'>1</span>; <span class='cm'>// 0,1은 소수 아님</span><br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>2</span>;i*i<=<span class='num'>20</span>;i++)<br><span class='ln'>4</span>    <span class='kw'>if</span>(!sieve[i])<br><span class='ln'>5</span>        <span class='kw'>for</span>(<span class='type'>int</span> j=i*i;j<=<span class='num'>20</span>;j+=i) sieve[j]=<span class='num'>1</span>;<br><span class='ln'>6</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>2</span>;i<=<span class='num'>20</span>;i++)<br><span class='ln'>7</span>    <span class='kw'>if</span>(!sieve[i]) <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,i);</div>", a: "<span class='key'>출력</span> <code>2 3 5 7 11 13 17 19</code><br><span class='step'>체 과정</span><div class='trace'>i=2: 4,6,8,10,12,14,16,18,20 제거<br>i=3: 9,12,15,18 제거(일부 중복)<br>i=4: 이미 제거됨→skip<br>4×4=16>20 → 종료</div><div class='explain'>💡 <strong>에라토스테네스의 체</strong>: 소수의 배수를 지우면 남는 것이 소수! 2300년 된 알고리즘. O(n log log n)으로 매우 효율적!</div>" },
            { n: 11, t: "이진법 카운팅으로 부분집합", d: 3, q: "{A,B,C}의 <strong>모든 부분집합</strong>을 비트로 열거.<div class='code-block'><span class='type'>char</span> set[]={<span class='str'>'A'</span>,<span class='str'>'B'</span>,<span class='str'>'C'</span>};<br><span class='kw'>for</span>(<span class='type'>int</span> mask=<span class='num'>0</span>;mask&lt;<span class='num'>8</span>;mask++){<br>    <span class='fn'>printf</span>(<span class='str'>\"{\"</span>);<br>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>3</span>;i++)<br>        <span class='kw'>if</span>(mask&(1&lt;&lt;i)) <span class='fn'>printf</span>(<span class='str'>\"%c\"</span>,set[i]);<br>    <span class='fn'>printf</span>(<span class='str'>\"} \"</span>);<br>}</div>", a: "<span class='key'>출력</span> <code>{} {A} {B} {AB} {C} {AC} {BC} {ABC}</code><br><span class='step'>원리</span><div class='trace'>mask=0 (000): 공집합<br>mask=1 (001): A<br>mask=2 (010): B<br>mask=3 (011): A,B<br>... mask=7 (111): A,B,C</div><div class='explain'>💡 <strong>비트마스크 열거</strong>: n개 원소 → 2ⁿ개 부분집합! 각 비트가 원소의 포함/미포함을 결정. 완전 탐색의 핵심 기법!</div>" },
            { n: 12, t: "합병 정렬 개념", d: 3, q: "합병 정렬의 <strong>분할→정복→병합</strong> 과정.<div class='code-block'><span class='cm'>// 개념적 단계 (n=8)</span><br><span class='cm'>// [5,3,8,1,7,2,6,4]</span><br><span class='cm'>// 분할: [5,3,8,1] [7,2,6,4]</span><br><span class='cm'>// 분할: [5,3][8,1] [7,2][6,4]</span><br><span class='cm'>// 분할: [5][3][8][1] [7][2][6][4]</span><br><span class='cm'>// 병합: [3,5][1,8] [2,7][4,6]</span><br><span class='cm'>// 병합: [1,3,5,8] [2,4,6,7]</span><br><span class='cm'>// 병합: [1,2,3,4,5,6,7,8]</span></div>", a: "<span class='key'>시간 복잡도</span> O(n log n) — 항상!<br><span class='step'>단계 분석</span><div class='trace'>분할 단계: log₂8 = <span class='val'>3</span>단계<br>각 단계마다 n개 원소 비교·복사<br>총: n × log n = 8 × 3 = <span class='val'>24</span>회 연산</div><div class='explain'>💡 <strong>합병 정렬</strong>: 분할 정복의 대표! 최악에도 O(n log n) 보장(퀵소트는 최악 O(n²)). 안정 정렬이라 같은 값의 순서 유지!</div>" },
            { n: 13, t: "투 포인터 합 찾기", d: 3, q: "정렬된 배열에서 <strong>합이 10인 쌍</strong> 찾기.<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>5</span>,<span class='num'>7</span>,<span class='num'>8</span>};<br><span class='type'>int</span> l=<span class='num'>0</span>,r=<span class='num'>5</span>;<br><span class='kw'>while</span>(l&lt;r){<br>    <span class='type'>int</span> s=a[l]+a[r];<br>    <span class='kw'>if</span>(s==<span class='num'>10</span>){<span class='fn'>printf</span>(<span class='str'>\"%d+%d \"</span>,a[l],a[r]);l++;r--;}<br>    <span class='kw'>else if</span>(s&lt;<span class='num'>10</span>) l++;<br>    <span class='kw'>else</span> r--;<br>}</div>", a: "<span class='key'>출력</span> <code>2+8 3+7</code><br><span class='step'>추적</span><div class='trace'>l=0,r=5: 1+8=9<10 → l++<br>l=1,r=5: 2+8=10 → <span class='val'>출력</span>, l++, r--<br>l=2,r=4: 3+7=10 → <span class='val'>출력</span>, l++, r--<br>l=3,r=3: l<r 거짓 → 종료</div><div class='explain'>💡 <strong>투 포인터</strong>: 양쪽에서 좁히기! 합이 작으면 l++, 크면 r--. O(n²)→O(n)! 정렬된 배열에서 쌍 찾기의 정석.</div>" },
            { n: 14, t: "슬라이딩 윈도우", d: 3, q: "크기 3인 <strong>연속 부분 배열의 최대 합</strong>. 결과는?<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>2</span>,<span class='num'>1</span>,<span class='num'>5</span>,<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>2</span>}, k=<span class='num'>3</span>;<br><span class='type'>int</span> sum=<span class='num'>0</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;k;i++) sum+=a[i]; <span class='cm'>// 첫 윈도우</span><br><span class='type'>int</span> maxS=sum;<br><span class='kw'>for</span>(<span class='type'>int</span> i=k;i&lt;<span class='num'>6</span>;i++){<br>    sum+=a[i]-a[i-k]; <span class='cm'>// 슬라이드!</span><br>    <span class='kw'>if</span>(sum>maxS) maxS=sum;<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,maxS);</div>", a: "<span class='key'>출력</span> <code>9</code><br><span class='step'>추적</span><div class='trace'>초기 윈도우[0..2]: 2+1+5=<span class='val'>8</span>, maxS=8<br>i=3: sum=8+1-2=<span class='val'>7</span> [1,5,1]<br>i=4: sum=7+3-1=<span class='val'>9</span> [5,1,3] → maxS=9<br>i=5: sum=9+2-5=<span class='val'>6</span> [1,3,2]</div><div class='explain'>💡 <strong>슬라이딩 윈도우</strong>: 윈도우를 한 칸씩 밀며 '새로 들어온 것 더하고 빠진 것 빼기'! 매번 합 전체를 다시 구하면 O(nk), 슬라이딩은 O(n)!</div>" },
            { n: 15, t: "재귀 이진 탐색", d: 2, q: "이진 탐색을 <strong>재귀</strong>로 구현. 결과는?<div class='code-block'><span class='type'>int</span> <span class='fn'>bsearch</span>(<span class='type'>int</span> a[],<span class='type'>int</span> lo,<span class='type'>int</span> hi,<span class='type'>int</span> key){<br>    <span class='kw'>if</span>(lo>hi) <span class='kw'>return</span> -<span class='num'>1</span>;<br>    <span class='type'>int</span> mid=(lo+hi)/<span class='num'>2</span>;<br>    <span class='kw'>if</span>(a[mid]==key) <span class='kw'>return</span> mid;<br>    <span class='kw'>if</span>(a[mid]&lt;key) <span class='kw'>return</span> <span class='fn'>bsearch</span>(a,mid+<span class='num'>1</span>,hi,key);<br>    <span class='kw'>return</span> <span class='fn'>bsearch</span>(a,lo,mid-<span class='num'>1</span>,key);<br>}<br><span class='type'>int</span> a[]={<span class='num'>2</span>,<span class='num'>4</span>,<span class='num'>6</span>,<span class='num'>8</span>,<span class='num'>10</span>};<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,<span class='fn'>bsearch</span>(a,<span class='num'>0</span>,<span class='num'>4</span>,<span class='num'>6</span>));</div>", a: "<span class='key'>출력</span> <code>2</code><br><span class='step'>추적</span><div class='trace'>bsearch(0,4,6): mid=2, a[2]=<span class='val'>6</span>==6 → return 2!</div><div class='explain'>💡 반복 vs 재귀 이진 탐색: 결과 동일, 표현 방식만 다름. 재귀는 '범위를 좁히며 자기 호출' 구조가 직관적!</div>" },
            { n: 16, t: "카운팅 정렬", d: 3, q: "O(n)에 정렬하는 <strong>카운팅 정렬</strong>. 결과는?<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>3</span>,<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>1</span>}, cnt[<span class='num'>4</span>]={<span class='num'>0</span>};<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>5</span>;i++) cnt[a[i]]++;<br><span class='kw'>for</span>(<span class='type'>int</span> v=<span class='num'>0</span>;v&lt;<span class='num'>4</span>;v++)<br>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;cnt[v];j++) <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,v);</div>", a: "<span class='key'>출력</span> <code>1 1 2 3 3</code><br><span class='step'>추적</span><div class='trace'>카운트: cnt[1]=2, cnt[2]=1, cnt[3]=2<br>v=0: cnt[0]=0→skip<br>v=1: 2번 출력→1 1<br>v=2: 1번 출력→2<br>v=3: 2번 출력→3 3</div><div class='explain'>💡 <strong>카운팅 정렬</strong>: 비교 대신 등장 횟수를 세서 정렬! O(n+k). 단, 값의 범위(k)가 작을 때만 효율적. 나이, 점수 정렬에 적합!</div>" },
            { n: 17, t: "퀵 정렬 파티션", d: 3, q: "퀵 정렬의 <strong>파티션</strong> 1단계. 결과는?<div class='code-block'><span class='type'>int</span> a[]={<span class='num'>5</span>,<span class='num'>3</span>,<span class='num'>8</span>,<span class='num'>1</span>,<span class='num'>9</span>,<span class='num'>2</span>}; <span class='cm'>// 피벗=5</span><br><span class='type'>int</span> pivot=a[<span class='num'>0</span>],lo=<span class='num'>1</span>,hi=<span class='num'>5</span>;<br><span class='kw'>while</span>(lo<=hi){<br>    <span class='kw'>while</span>(lo<=hi&&a[lo]<=pivot)lo++;<br>    <span class='kw'>while</span>(lo<=hi&&a[hi]>pivot)hi--;<br>    <span class='kw'>if</span>(lo&lt;hi){<span class='type'>int</span> t=a[lo];a[lo]=a[hi];a[hi]=t;}<br>}<br><span class='type'>int</span> t=a[<span class='num'>0</span>];a[<span class='num'>0</span>]=a[hi];a[hi]=t;</div>", a: "<span class='key'>파티션 후</span> 피벗(5) 기준: {왼쪽<5} <strong>5</strong> {오른쪽>5}<br>결과: {2, 3, 1, <strong>5</strong>, 9, 8} (예시)<div class='explain'>💡 <strong>파티션</strong>: 피벗보다 작은 것은 왼쪽, 큰 것은 오른쪽! 이후 양쪽을 재귀적으로 정렬. 평균 O(n log n), 실전에서 가장 빠른 정렬!</div>" },
            { n: 18, t: "그리디: 거스름돈", d: 2, q: "<strong>최소 동전</strong>으로 거스름돈 주기. 결과는?<div class='code-block'><span class='type'>int</span> coins[]={<span class='num'>500</span>,<span class='num'>100</span>,<span class='num'>50</span>,<span class='num'>10</span>};<br><span class='type'>int</span> money=<span class='num'>730</span>, cnt=<span class='num'>0</span>;<br><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>4</span>;i++){<br>    cnt+=money/coins[i];<br>    money%=coins[i];<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%d개\"</span>,cnt);</div>", a: "<span class='key'>출력</span> <code>5개</code><br><span class='step'>추적</span><div class='trace'>500원: 730/500=<span class='val'>1</span>개, 나머지 230<br>100원: 230/100=<span class='val'>2</span>개, 나머지 30<br>50원: 30/50=<span class='val'>0</span>개, 나머지 30<br>10원: 30/10=<span class='val'>3</span>개, 나머지 0<br>총: 1+2+0+3=<span class='val'>5</span>개</div><div class='explain'>💡 <strong>그리디 알고리즘</strong>: 매 단계에서 가장 큰 동전을 최대한 사용! '현재 최선의 선택'이 전체 최적해. 단, 모든 문제에 적용 가능한 건 아님!</div>" },
            { n: 19, t: "재귀 조합(nCr)", d: 3, q: "조합을 <strong>재귀</strong>로 계산. 5C2는?<div class='code-block'><span class='type'>int</span> <span class='fn'>C</span>(<span class='type'>int</span> n,<span class='type'>int</span> r){<br>    <span class='kw'>if</span>(r==<span class='num'>0</span>||r==n) <span class='kw'>return</span> <span class='num'>1</span>;<br>    <span class='kw'>return</span> <span class='fn'>C</span>(n-<span class='num'>1</span>,r-<span class='num'>1</span>)+<span class='fn'>C</span>(n-<span class='num'>1</span>,r);<br>}<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,<span class='fn'>C</span>(<span class='num'>5</span>,<span class='num'>2</span>));</div>", a: "<span class='key'>출력</span> <code>10</code><br><span class='step'>호출 트리</span><div class='trace'>C(5,2) = C(4,1) + C(4,2)<br>C(4,1) = C(3,0)+C(3,1) = 1+C(2,0)+C(2,1) = 1+1+2 = <span class='val'>4</span><br>C(4,2) = C(3,1)+C(3,2) = 3+C(2,1)+C(2,2) = 3+2+1 = <span class='val'>6</span><br>C(5,2) = 4+6 = <span class='val'>10</span></div><div class='explain'>💡 <strong>파스칼의 삼각형</strong>: C(n,r) = C(n-1,r-1)+C(n-1,r)! '선택하거나 안 하거나' 두 경우로 분해. 중복 계산이 많으므로 DP로 개선 가능!</div>" },
            { n: 20, t: "🏆 알고리즘 설계 전략 정리", d: 3, q: "주요 <strong>알고리즘 설계 전략</strong>을 정리하세요.<br>①완전 탐색 ②그리디 ③분할 정복 ④재귀/백트래킹", a: "<span class='key'>4대 설계 전략</span><div class='trace'>① 완전 탐색 (Brute Force)<br>  • 모든 경우를 시도 → 정확하지만 느림<br>  • 비트마스크, 중첩 반복문<br><br>② 그리디 (Greedy)<br>  • 매 단계 최선을 선택 → 빠르지만 항상 최적은 아님<br>  • 거스름돈, 활동 선택<br><br>③ 분할 정복 (Divide & Conquer)<br>  • 나누고 → 각각 해결 → 합치기<br>  • 합병 정렬, 퀵 정렬, 이진 탐색<br><br>④ 재귀/백트래킹 (Recursion/Backtracking)<br>  • 시도 → 실패하면 되돌아가기<br>  • 순열, 미로 탐색, N-Queen</div><div class='explain'>💡 좋은 알고리즘 설계 = <strong>올바른 전략 선택</strong>! 문제 특성에 따라 적합한 전략이 달라요. 다음 단계(어려움)에서는 DP와 그래프 알고리즘을 배워요!</div>" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => { const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 코드 또는 답을 작성하세요"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>