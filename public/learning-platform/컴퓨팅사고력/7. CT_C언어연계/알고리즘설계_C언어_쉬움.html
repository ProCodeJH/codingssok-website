<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💻 알고리즘 설계 → C언어 (쉬움) — 기초 알고리즘과 순서도</title>
    <link rel="stylesheet" href="ct_c.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>💻 알고리즘 설계(Algorithm Design) → C언어</h1>
            <div class="sub">쉬움 · 기초 알고리즘과 순서도</div>
            <div class="level-bar"><span class="on"></span><span></span><span></span></div>
            <div class="meta"><span class="tag pri"
                    style="background:rgba(245,158,11,.1);border-color:rgba(245,158,11,.3);color:#f59e0b">⚙️ 알고리즘
                    설계</span><span class="tag acc">🟢 쉬움</span><span class="tag acc">📝 20문제</span><span class="tag">⏱
                    30~50분</span></div>
        </div>
        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>
        <div class="learn">
            <h2><span class="ico" style="background:rgba(245,158,11,.15)">⚙️</span> 알고리즘 설계란?</h2>
            <p>문제를 해결하는 <strong>명확한 절차(단계별 지시)</strong>를 만드는 것입니다. C언어에서는 조건문, 반복문, 함수 등으로 알고리즘을 표현해요!</p>
            <div class="tip">💡 알고리즘 = 입력 → 처리 → 출력. 모든 프로그램의 뼈대!</div>
        </div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p><button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p><button
                    class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg"><span class="tag active">쉬움</span><a href="알고리즘설계_C언어_보통.html">보통 →</a><a
                href="알고리즘설계_C언어_어려움.html">어려움 →</a></div>
        <div class="ft">💻 CT → C언어 · 알고리즘 설계 · 쉬움 20문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "최대값 찾기 알고리즘", d: 1, q: "배열에서 최대값을 찾는 알고리즘. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>3</span>,<span class='num'>7</span>,<span class='num'>1</span>,<span class='num'>9</span>,<span class='num'>4</span>};<br><span class='ln'>2</span><span class='type'>int</span> max=a[<span class='num'>0</span>];<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>5</span>;i++)<br><span class='ln'>4</span>    <span class='kw'>if</span>(a[i]>max) max=a[i];<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,max);</div>", a: "<span class='key'>출력</span> <code>9</code><br><span class='step'>추적</span><div class='trace'>max=3<br>i=1: a[1]=7>3 → max=<span class='val'>7</span><br>i=2: a[2]=1<7 → 유지<br>i=3: a[3]=9>7 → max=<span class='val'>9</span><br>i=4: a[4]=4<9 → 유지</div><div class='explain'>💡 <strong>선형 탐색</strong>: 처음부터 끝까지 하나씩 비교! '현재 최대'를 기억하고 더 큰 것을 만나면 갱신. 가장 기본적인 알고리즘 설계 패턴!</div>" },
            { n: 2, t: "카운팅 알고리즘", d: 1, q: "짝수의 <strong>개수</strong>를 세는 알고리즘. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>4</span>,<span class='num'>6</span>,<span class='num'>3</span>,<span class='num'>8</span>,<span class='num'>5</span>};<br><span class='ln'>2</span><span class='type'>int</span> cnt=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>6</span>;i++)<br><span class='ln'>4</span>    <span class='kw'>if</span>(a[i]%<span class='num'>2</span>==<span class='num'>0</span>) cnt++;<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,cnt);</div>", a: "<span class='key'>출력</span> <code>3</code><br><span class='step'>추적</span><div class='trace'>i=0: 1%2=1≠0 → skip<br>i=1: 4%2=0 → cnt=<span class='val'>1</span><br>i=2: 6%2=0 → cnt=<span class='val'>2</span><br>i=3: 3%2=1 → skip<br>i=4: 8%2=0 → cnt=<span class='val'>3</span><br>i=5: 5%2=1 → skip</div><div class='explain'>💡 <strong>카운팅 알고리즘</strong>: 조건에 맞는 항목 개수 세기! cnt=0으로 시작, 조건 만족하면 cnt++. 투표 집계, 통계 처리의 기본!</div>" },
            { n: 3, t: "합계 알고리즘", d: 1, q: "배열의 합을 구하는 알고리즘. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>10</span>,<span class='num'>20</span>,<span class='num'>30</span>,<span class='num'>40</span>};<br><span class='ln'>2</span><span class='type'>int</span> sum=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>4</span>;i++) sum+=a[i];<br><span class='ln'>4</span><span class='fn'>printf</span>(<span class='str'>\"합:%d 평균:%d\"</span>,sum,sum/<span class='num'>4</span>);</div>", a: "<span class='key'>출력</span> <code>합:100 평균:25</code><br><span class='step'>추적</span><div class='trace'>sum=0+10=10<br>sum=10+20=30<br>sum=30+30=60<br>sum=60+40=<span class='val'>100</span><br>평균: 100/4=<span class='val'>25</span></div><div class='explain'>💡 <strong>누적(Accumulator) 알고리즘</strong>: sum=0으로 시작해서 하나씩 더하기! 평균=합÷개수. 매출 합산, 성적 평균 등 모든 곳에서 사용!</div>" },
            { n: 4, t: "교환(Swap) 알고리즘", d: 1, q: "두 변수의 값을 <strong>교환</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a=<span class='num'>5</span>, b=<span class='num'>3</span>;<br><span class='ln'>2</span><span class='type'>int</span> temp=a;<br><span class='ln'>3</span>a=b;<br><span class='ln'>4</span>b=temp;<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d %d\"</span>,a,b);</div>", a: "<span class='key'>출력</span> <code>3 5</code><br><span class='step'>추적</span><div class='trace'>초기: a=5, b=3<br>temp=5 (a 백업)<br>a=3 (b→a)<br>b=5 (temp→b)<br>결과: a=<span class='val'>3</span>, b=<span class='val'>5</span></div><div class='explain'>💡 <strong>Swap 알고리즘</strong>: 임시 변수(temp)로 삼각 교환! 컵 2개의 물을 바꾸려면 빈 컵 1개가 필요한 것과 같아요. 모든 정렬 알고리즘의 기본 연산!</div>" },
            { n: 5, t: "선형 검색 알고리즘", d: 1, q: "배열에서 <strong>값 찾기</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>5</span>,<span class='num'>2</span>,<span class='num'>8</span>,<span class='num'>1</span>,<span class='num'>9</span>};<br><span class='ln'>2</span><span class='type'>int</span> key=<span class='num'>8</span>, pos=-<span class='num'>1</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>5</span>;i++)<br><span class='ln'>4</span>    <span class='kw'>if</span>(a[i]==key){pos=i;<span class='kw'>break</span>;}<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,pos);</div>", a: "<span class='key'>출력</span> <code>2</code><br><span class='step'>추적</span><div class='trace'>i=0: a[0]=5≠8<br>i=1: a[1]=2≠8<br>i=2: a[2]=8==8 → pos=<span class='val'>2</span>, break!</div><div class='explain'>💡 <strong>선형 검색(Linear Search)</strong>: 처음부터 하나씩 비교! 찾으면 break (일찍 종료). 못 찾으면 pos=-1 유지. 정렬되지 않은 데이터에 사용!</div>" },
            { n: 6, t: "역순 출력 알고리즘", d: 1, q: "배열을 <strong>거꾸로 출력</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>4</span>,<span class='num'>5</span>};<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>4</span>;i>=<span class='num'>0</span>;i--)<br><span class='ln'>3</span>    <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,a[i]);</div>", a: "<span class='key'>출력</span> <code>5 4 3 2 1</code><br><span class='step'>추적</span><div class='trace'>i=4: a[4]=5<br>i=3: a[3]=4<br>i=2: a[2]=3<br>i=1: a[1]=2<br>i=0: a[0]=1</div><div class='explain'>💡 <strong>역순 순회</strong>: i를 마지막(n-1)에서 0까지 감소! 문자열 뒤집기, 스택 출력 등에 활용. i--가 핵심!</div>" },
            { n: 7, t: "버블 정렬 알고리즘", d: 2, q: "버블 정렬 1회전 후 배열 상태는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>5</span>,<span class='num'>3</span>,<span class='num'>8</span>,<span class='num'>1</span>};<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;<span class='num'>3</span>;j++){<br><span class='ln'>3</span>    <span class='kw'>if</span>(a[j]>a[j+<span class='num'>1</span>]){<br><span class='ln'>4</span>        <span class='type'>int</span> t=a[j]; a[j]=a[j+<span class='num'>1</span>]; a[j+<span class='num'>1</span>]=t;<br><span class='ln'>5</span>    }<br><span class='ln'>6</span>}</div>", a: "<span class='key'>결과</span> {3, 5, 1, <strong>8</strong>} (최대값이 맨 끝으로!)<br><span class='step'>추적</span><div class='trace'>j=0: 5>3 → swap → {<span class='val'>3,5</span>,8,1}<br>j=1: 5<8 → 유지 → {3,5,8,1}<br>j=2: 8>1 → swap → {3,5,<span class='val'>1,8</span>}</div><div class='explain'>💡 <strong>버블 정렬</strong>: 인접한 두 원소를 비교, 교환! 1회전마다 가장 큰 값이 '거품'처럼 끝으로 이동. 전체 정렬은 n-1회전 필요. O(n²).</div>" },
            { n: 8, t: "팩토리얼 알고리즘", d: 1, q: "반복문으로 <strong>팩토리얼</strong> 계산. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> n=<span class='num'>5</span>, result=<span class='num'>1</span>;<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=n;i++)<br><span class='ln'>3</span>    result*=i;<br><span class='ln'>4</span><span class='fn'>printf</span>(<span class='str'>\"%d! = %d\"</span>,n,result);</div>", a: "<span class='key'>출력</span> <code>5! = 120</code><br><span class='step'>추적</span><div class='trace'>i=1: result=1×1=1<br>i=2: result=1×2=2<br>i=3: result=2×3=6<br>i=4: result=6×4=24<br>i=5: result=24×5=<span class='val'>120</span></div><div class='explain'>💡 <strong>누적 곱셈</strong>: result=1에서 시작(×의 항등원), 하나씩 곱하기! 합계(+=)와 동일한 패턴이지만 연산이 곱셈. 순열, 조합 계산의 기초!</div>" },
            { n: 9, t: "소수 판별 알고리즘", d: 2, q: "주어진 수가 <strong>소수인지</strong> 판별. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> n=<span class='num'>7</span>, isPrime=<span class='num'>1</span>;<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>2</span>;i*i<=n;i++){<br><span class='ln'>3</span>    <span class='kw'>if</span>(n%i==<span class='num'>0</span>){isPrime=<span class='num'>0</span>;<span class='kw'>break</span>;}<br><span class='ln'>4</span>}<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d: %s\"</span>,n,isPrime?<span class='str'>\"소수\"</span>:<span class='str'>\"합성수\"</span>);</div>", a: "<span class='key'>출력</span> <code>7: 소수</code><br><span class='step'>추적</span><div class='trace'>i=2: 2×2=4<=7 → 7%2=1≠0 → 계속<br>i=3: 3×3=9>7 → 종료<br>isPrime=1 → <span class='val'>소수!</span></div><div class='explain'>💡 i*i<=n까지만 확인하면 됨! √7≈2.6이므로 2만 확인. n까지 전부 확인하는 것보다 훨씬 효율적. O(n)→O(√n)!</div>" },
            { n: 10, t: "피보나치 알고리즘", d: 2, q: "피보나치 수열의 <strong>7번째 항</strong>은?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a=<span class='num'>0</span>, b=<span class='num'>1</span>;<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>2</span>;i<=<span class='num'>7</span>;i++){<br><span class='ln'>3</span>    <span class='type'>int</span> c=a+b; a=b; b=c;<br><span class='ln'>4</span>}<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,b);</div>", a: "<span class='key'>출력</span> <code>13</code><br><span class='step'>추적</span><div class='trace'>i=2: c=0+1=1, a=1, b=1<br>i=3: c=1+1=2, a=1, b=2<br>i=4: c=1+2=3, a=2, b=3<br>i=5: c=2+3=5, a=3, b=5<br>i=6: c=3+5=8, a=5, b=8<br>i=7: c=5+8=13, a=8, b=<span class='val'>13</span></div><div class='explain'>💡 <strong>피보나치</strong>: 이전 두 수의 합! 변수 3개(a,b,c)로 '슬라이딩 윈도우'처럼 이동. 재귀보다 반복이 효율적!</div>" },
            { n: 11, t: "최솟값 위치 찾기", d: 1, q: "배열에서 <strong>최소값의 위치(인덱스)</strong>를 찾기. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>4</span>,<span class='num'>2</span>,<span class='num'>7</span>,<span class='num'>1</span>,<span class='num'>5</span>};<br><span class='ln'>2</span><span class='type'>int</span> minIdx=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>5</span>;i++)<br><span class='ln'>4</span>    <span class='kw'>if</span>(a[i]&lt;a[minIdx]) minIdx=i;<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"위치:%d 값:%d\"</span>,minIdx,a[minIdx]);</div>", a: "<span class='key'>출력</span> <code>위치:3 값:1</code><br><span class='step'>추적</span><div class='trace'>minIdx=0 (a[0]=4)<br>i=1: a[1]=2<4 → minIdx=1<br>i=2: a[2]=7>2 → 유지<br>i=3: a[3]=1<2 → minIdx=<span class='val'>3</span><br>i=4: a[4]=5>1 → 유지</div><div class='explain'>💡 값이 아닌 <strong>인덱스</strong>를 기억! a[minIdx]로 값에도 접근 가능. 선택 정렬에서 핵심적으로 사용되는 알고리즘.</div>" },
            { n: 12, t: "문자열 비교 알고리즘", d: 2, q: "두 문자열이 같은지 <strong>직접 비교</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>char</span> a[]=<span class='str'>\"ABC\"</span>, b[]=<span class='str'>\"ABD\"</span>;<br><span class='ln'>2</span><span class='type'>int</span> i=<span class='num'>0</span>, eq=<span class='num'>1</span>;<br><span class='ln'>3</span><span class='kw'>while</span>(a[i]&&b[i]){<br><span class='ln'>4</span>    <span class='kw'>if</span>(a[i]!=b[i]){eq=<span class='num'>0</span>;<span class='kw'>break</span>;}<br><span class='ln'>5</span>    i++;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%s\"</span>,eq?<span class='str'>\"같다\"</span>:<span class='str'>\"다르다\"</span>);</div>", a: "<span class='key'>출력</span> <code>다르다</code><br><span class='step'>추적</span><div class='trace'>i=0: 'A'=='A' → 계속, i=1<br>i=1: 'B'=='B' → 계속, i=2<br>i=2: 'C'!='D' → eq=<span class='val'>0</span>, break!</div><div class='explain'>💡 <strong>문자열 비교 알고리즘</strong>: 한 글자씩 앞에서 비교! 다른 문자를 만나면 즉시 '다르다'. strcmp의 내부 원리!</div>" },
            { n: 13, t: "뒤집기(Reverse) 알고리즘", d: 2, q: "배열을 <strong>제자리에서 뒤집기</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>,<span class='num'>4</span>,<span class='num'>5</span>};<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> l=<span class='num'>0</span>,r=<span class='num'>4</span>;l&lt;r;l++,r--){<br><span class='ln'>3</span>    <span class='type'>int</span> t=a[l];a[l]=a[r];a[r]=t;<br><span class='ln'>4</span>}</div>", a: "<span class='key'>결과</span> {5, 4, 3, 2, 1}<br><span class='step'>추적</span><div class='trace'>l=0,r=4: swap(1,5) → {<span class='val'>5</span>,2,3,4,<span class='val'>1</span>}<br>l=1,r=3: swap(2,4) → {5,<span class='val'>4</span>,3,<span class='val'>2</span>,1}<br>l=2,r=2: l<r 거짓 → 종료 (3은 그대로)</div><div class='explain'>💡 <strong>투 포인터 역전</strong>: 양쪽 끝에서 중앙으로 교환! 추가 배열 없이 O(n/2) 교환으로 뒤집기 완료. 회문 검사에도 활용!</div>" },
            { n: 14, t: "거듭제곱 알고리즘", d: 1, q: "반복문으로 <strong>거듭제곱</strong> 계산. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> base=<span class='num'>2</span>, exp=<span class='num'>10</span>, result=<span class='num'>1</span>;<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;exp;i++)<br><span class='ln'>3</span>    result*=base;<br><span class='ln'>4</span><span class='fn'>printf</span>(<span class='str'>\"%d^%d=%d\"</span>,base,exp,result);</div>", a: "<span class='key'>출력</span> <code>2^10=1024</code><br><span class='step'>추적</span><div class='trace'>i=0: 1×2=2<br>i=1: 2×2=4<br>i=2: 4×2=8<br>...<br>i=9: 512×2=<span class='val'>1024</span></div><div class='explain'>💡 팩토리얼과 같은 <strong>누적 곱셈</strong> 패턴이지만 같은 수를 반복 곱셈! 더 빠른 방법: 빠른 거듭제곱(O(log n))은 어려움 레벨에서 다룰게요.</div>" },
            { n: 15, t: "자릿수 분리 알고리즘", d: 2, q: "정수의 <strong>각 자릿수</strong>를 분리. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> n=<span class='num'>1234</span>;<br><span class='ln'>2</span><span class='kw'>while</span>(n><span class='num'>0</span>){<br><span class='ln'>3</span>    <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,n%<span class='num'>10</span>);<br><span class='ln'>4</span>    n/=<span class='num'>10</span>;<br><span class='ln'>5</span>}</div>", a: "<span class='key'>출력</span> <code>4 3 2 1</code> (역순 주의!)<br><span class='step'>추적</span><div class='trace'>n=1234: 1234%10=<span class='val'>4</span>, n=123<br>n=123: 123%10=<span class='val'>3</span>, n=12<br>n=12: 12%10=<span class='val'>2</span>, n=1<br>n=1: 1%10=<span class='val'>1</span>, n=0 → 종료</div><div class='explain'>💡 <strong>%10으로 마지막 자릿수, /10으로 자릿수 제거!</strong> 나머지와 몫을 반복 사용하는 핵심 알고리즘. 자릿수 합, 회문 수 판별에 필수!</div>" },
            { n: 16, t: "GCD(최대공약수) 알고리즘", d: 2, q: "유클리드 호제법으로 <strong>GCD</strong> 계산. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a=<span class='num'>48</span>, b=<span class='num'>18</span>;<br><span class='ln'>2</span><span class='kw'>while</span>(b!=<span class='num'>0</span>){<br><span class='ln'>3</span>    <span class='type'>int</span> r=a%b; a=b; b=r;<br><span class='ln'>4</span>}<br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"GCD=%d\"</span>,a);</div>", a: "<span class='key'>출력</span> <code>GCD=6</code><br><span class='step'>추적</span><div class='trace'>a=48,b=18: r=48%18=12 → a=18,b=12<br>a=18,b=12: r=18%12=6 → a=12,b=6<br>a=12,b=6: r=12%6=0 → a=6,b=0<br>b==0 → GCD=<span class='val'>6</span></div><div class='explain'>💡 <strong>유클리드 호제법</strong>: 2300년 전 알고리즘인데 여전히 최적! 큰 수를 작은 수로 나눈 나머지로 교체하기를 반복. O(log n) 효율!</div>" },
            { n: 17, t: "선택 정렬 설계", d: 2, q: "선택 정렬의 전체 과정. 1회전 후 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>4</span>,<span class='num'>2</span>,<span class='num'>7</span>,<span class='num'>1</span>};<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>3</span>;i++){<br><span class='ln'>3</span>    <span class='type'>int</span> min=i;<br><span class='ln'>4</span>    <span class='kw'>for</span>(<span class='type'>int</span> j=i+<span class='num'>1</span>;j&lt;<span class='num'>4</span>;j++)<br><span class='ln'>5</span>        <span class='kw'>if</span>(a[j]&lt;a[min]) min=j;<br><span class='ln'>6</span>    <span class='type'>int</span> t=a[i];a[i]=a[min];a[min]=t;<br><span class='ln'>7</span>}</div>", a: "<span class='key'>1회전(i=0) 결과</span> {<strong>1</strong>, 2, 7, 4}<br><span class='step'>추적</span><div class='trace'>i=0: min=0<br>j=1: a[1]=2<4 → min=1<br>j=2: a[2]=7>2 → 유지<br>j=3: a[3]=1<2 → min=3<br>swap(a[0],a[3]): {<span class='val'>1</span>,2,7,<span class='val'>4</span>}</div><div class='explain'>💡 <strong>선택 정렬</strong>: '최소값 찾기' + 'swap' 결합! 매 회전마다 남은 원소 중 최솟값을 찾아 앞으로. 이해하기 쉽지만 O(n²).</div>" },
            { n: 18, t: "진법 변환 알고리즘", d: 2, q: "10진수를 <strong>2진수</strong>로 변환. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> n=<span class='num'>13</span>;<br><span class='ln'>2</span><span class='type'>int</span> bits[<span class='num'>32</span>], cnt=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>while</span>(n><span class='num'>0</span>){<br><span class='ln'>4</span>    bits[cnt++]=n%<span class='num'>2</span>;<br><span class='ln'>5</span>    n/=<span class='num'>2</span>;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='kw'>for</span>(<span class='type'>int</span> i=cnt-<span class='num'>1</span>;i>=<span class='num'>0</span>;i--) <span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,bits[i]);</div>", a: "<span class='key'>출력</span> <code>1101</code><br><span class='step'>추적</span><div class='trace'>n=13: 13%2=1, n=6, bits={1}<br>n=6: 6%2=0, n=3, bits={1,0}<br>n=3: 3%2=1, n=1, bits={1,0,1}<br>n=1: 1%2=1, n=0, bits={1,0,1,1}<br>역순 출력: <span class='val'>1101</span></div><div class='explain'>💡 <strong>진법 변환</strong>: %2로 나머지(비트), /2로 다음 자릿수! 자릿수 분리와 같은 패턴이지만 10 대신 2로 나눔. 8진수면 %8, 16진수면 %16!</div>" },
            { n: 19, t: "배열 삽입 알고리즘", d: 2, q: "배열에 <strong>값 삽입</strong> (중간에 끼워넣기). 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[<span class='num'>6</span>]={<span class='num'>10</span>,<span class='num'>20</span>,<span class='num'>30</span>,<span class='num'>40</span>,<span class='num'>50</span>}, n=<span class='num'>5</span>;<br><span class='ln'>2</span><span class='type'>int</span> pos=<span class='num'>2</span>, val=<span class='num'>25</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=n;i>pos;i--) a[i]=a[i-<span class='num'>1</span>];<br><span class='ln'>4</span>a[pos]=val; n++;</div>", a: "<span class='key'>결과</span> {10, 20, <strong>25</strong>, 30, 40, 50}<br><span class='step'>추적</span><div class='trace'>뒤에서부터 한 칸씩 밀기:<br>i=5: a[5]=a[4]=50 → {10,20,30,40,50,<span class='val'>50</span>}<br>i=4: a[4]=a[3]=40 → {10,20,30,40,<span class='val'>40</span>,50}<br>i=3: a[3]=a[2]=30 → {10,20,30,<span class='val'>30</span>,40,50}<br>a[2]=25 → {10,20,<span class='val'>25</span>,30,40,50}</div><div class='explain'>💡 <strong>배열 삽입</strong>: 뒤에서부터 밀어야 덮어쓰기 방지! 앞에서 밀면 데이터 유실. 삽입 정렬의 핵심 연산!</div>" },
            { n: 20, t: "🏆 알고리즘 설계 체크리스트", d: 2, q: "좋은 알고리즘을 설계하기 위한 <strong>5단계</strong>를 정리하세요.", a: "<span class='key'>알고리즘 설계 5단계</span><div class='trace'>① 문제 이해: 입력/출력 명확히 정의<br>② 예제 실행: 작은 데이터로 손으로 풀기<br>③ 패턴 발견: 반복, 조건, 단계 찾기<br>④ 코드 작성: 의사코드 → C코드<br>⑤ 검증: 경계값(0, 1, 최대값) 테스트</div><span class='step'>설계 도구</span><div class='trace'>• 순서도: 흐름을 시각적으로<br>• 의사코드: 알고리즘을 말로<br>• 추적표: 변수 변화를 표로<br>• 테스트 케이스: 정확성 검증</div><div class='explain'>💡 코드 작성은 5단계 중 <strong>4번째</strong>! 먼저 이해하고, 손으로 풀어보고, 패턴을 찾은 후에 코딩. '생각 먼저, 코딩 나중에'가 핵심!</div>" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => { const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 코드 또는 답을 작성하세요"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>