<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💻 추상화 → C언어 (보통) — 데이터 모델링과 인터페이스</title>
    <link rel="stylesheet" href="ct_c.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>💻 추상화(Abstraction) → C언어</h1>
            <div class="sub">보통 · 데이터 모델링과 인터페이스</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span></span></div>
            <div class="meta"><span class="tag pri"
                    style="background:rgba(168,85,247,.1);border-color:rgba(168,85,247,.3);color:#a855f7">🎭
                    추상화</span><span class="tag warn">🟡 보통</span><span class="tag acc">📝 20문제</span><span class="tag">⏱
                    50~70분</span></div>
        </div>
        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>
        <div class="learn">
            <h2><span class="ico" style="background:rgba(168,85,247,.15)">🎭</span> 보통 난이도 안내</h2>
            <p>struct, 함수 포인터, 추상 데이터 타입(ADT) 등을 활용하여 <strong>복잡한 데이터를 모델링</strong>하고 <strong>인터페이스를 설계</strong>하는 연습을
                합니다!</p>
            <div class="tip">💡 좋은 추상화 = 사용하기 쉽고, 변경하기 쉬운 코드!</div>
        </div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p>
            <button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p>
                <button class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg">
            <a href="추상화_C언어_쉬움.html">← 쉬움</a>
            <span class="tag active">보통</span>
            <a href="추상화_C언어_어려움.html">어려움 →</a>
        </div>
        <div class="ft">💻 CT → C언어 · 추상화(Abstraction) · 보통 20문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "struct 중첩 (주소록)", d: 2, q: "struct 안에 struct를 넣어 <strong>계층적 추상화</strong>. 출력은?<div class='code-block'><span class='ln'>1</span><span class='kw'>struct</span> <span class='fn'>Date</span>{ <span class='type'>int</span> y,m,d; };<br><span class='ln'>2</span><span class='kw'>struct</span> <span class='fn'>Person</span>{<br><span class='ln'>3</span>    <span class='type'>char</span> name[<span class='num'>20</span>];<br><span class='ln'>4</span>    <span class='kw'>struct</span> <span class='fn'>Date</span> birth;<br><span class='ln'>5</span>};<br><span class='ln'>6</span><span class='kw'>struct</span> <span class='fn'>Person</span> p={<span class='str'>\"김영희\"</span>,{<span class='num'>2010</span>,<span class='num'>5</span>,<span class='num'>15</span>}};<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%s %d년 %d월 %d일\"</span>,p.name,p.birth.y,p.birth.m,p.birth.d);</div>", a: "<span class='key'>출력</span> <code>김영희 2010년 5월 15일</code><br><span class='step'>추상화 계층</span><div class='trace'>Person (상위 추상화)<br>  ├── name: 이름 (문자열)<br>  └── birth: 생년월일 (Date 구조체)<br>        ├── y: 연도<br>        ├── m: 월<br>        └── d: 일</div><div class='explain'>💡 <strong>계층적 추상화</strong>: Date는 연/월/일을 하나로 묶고, Person은 이름+생년월일을 묶어요. 현실 세계의 관계를 코드로 표현!</div>" },
            { n: 2, t: "struct 배열 (학급)", d: 2, q: "학생 배열의 평균 점수. 결과는?<div class='code-block'><span class='ln'>1</span><span class='kw'>struct</span> <span class='fn'>Student</span>{<span class='type'>char</span> name[<span class='num'>10</span>]; <span class='type'>int</span> score;};<br><span class='ln'>2</span><span class='kw'>struct</span> <span class='fn'>Student</span> cls[]={<br><span class='ln'>3</span>    {<span class='str'>\"민수\"</span>,<span class='num'>85</span>},{<span class='str'>\"지은\"</span>,<span class='num'>92</span>},{<span class='str'>\"현우\"</span>,<span class='num'>78</span>}<br><span class='ln'>4</span>};<br><span class='ln'>5</span><span class='type'>int</span> sum=<span class='num'>0</span>;<br><span class='ln'>6</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>3</span>;i++) sum+=cls[i].score;<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"평균: %d\"</span>,sum/<span class='num'>3</span>);</div>", a: "<span class='key'>출력</span> <code>평균: 85</code><br><span class='step'>추적</span><div class='trace'>cls[0].score=85 + cls[1].score=92 + cls[2].score=78<br>sum = 85+92+78 = <span class='val'>255</span><br>255/3 = <span class='val'>85</span></div><div class='explain'>💡 <strong>struct 배열</strong>: 같은 유형의 데이터 묶음! <code>cls[i].score</code>처럼 접근하여 '학급의 i번째 학생의 점수'를 자연스럽게 표현. 구조체 배열은 데이터베이스의 테이블과 유사!</div>" },
            { n: 3, t: "함수 포인터 추상화", d: 3, q: "함수 포인터로 <strong>동작을 추상화</strong>. 출력은?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>add</span>(<span class='type'>int</span> a,<span class='type'>int</span> b){<span class='kw'>return</span> a+b;}<br><span class='ln'>2</span><span class='type'>int</span> <span class='fn'>mul</span>(<span class='type'>int</span> a,<span class='type'>int</span> b){<span class='kw'>return</span> a*b;}<br><span class='ln'>3</span><br><span class='ln'>4</span><span class='type'>int</span> <span class='fn'>apply</span>(<span class='type'>int</span> (*op)(<span class='type'>int</span>,<span class='type'>int</span>), <span class='type'>int</span> x, <span class='type'>int</span> y){<br><span class='ln'>5</span>    <span class='kw'>return</span> op(x,y);<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d %d\"</span>, <span class='fn'>apply</span>(add,<span class='num'>3</span>,<span class='num'>4</span>), <span class='fn'>apply</span>(mul,<span class='num'>3</span>,<span class='num'>4</span>));</div>", a: "<span class='key'>출력</span> <code>7 12</code><br><span class='step'>추상화 분석</span><br>• <code>apply</code>는 <strong>어떤 연산이든</strong> 받아서 실행!<br>• add를 넣으면 덧셈, mul을 넣으면 곱셈<br>• apply 함수는 변경 없이 새로운 연산 추가 가능<div class='trace'>apply(add, 3, 4): op=add → add(3,4) = <span class='val'>7</span><br>apply(mul, 3, 4): op=mul → mul(3,4) = <span class='val'>12</span></div><div class='explain'>💡 <strong>함수 포인터 = 동작의 추상화</strong>! 데이터뿐 아니라 '행동'도 매개변수로 전달 가능. 이것이 C에서 다형성(polymorphism)을 구현하는 방법!</div>" },
            { n: 4, t: "콜백 함수 패턴", d: 3, q: "qsort에 비교 함수를 <strong>콜백</strong>으로 전달. 추적하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>cmpAsc</span>(<span class='type'>const void</span>*a,<span class='type'>const void</span>*b){<br><span class='ln'>2</span>    <span class='kw'>return</span> *(<span class='type'>int</span>*)a - *(<span class='type'>int</span>*)b;<br><span class='ln'>3</span>}<br><span class='ln'>4</span><span class='type'>int</span> arr[]={<span class='num'>5</span>,<span class='num'>2</span>,<span class='num'>8</span>,<span class='num'>1</span>};<br><span class='ln'>5</span><span class='fn'>qsort</span>(arr, <span class='num'>4</span>, <span class='kw'>sizeof</span>(<span class='type'>int</span>), cmpAsc);<br><span class='ln'>6</span><span class='cm'>// arr → ?</span></div>", a: "<span class='key'>결과</span> arr = {1, 2, 5, 8} (오름차순)<br><span class='step'>콜백 추상화</span><br>• <code>qsort</code>: 정렬 알고리즘 (라이브러리가 구현)<br>• <code>cmpAsc</code>: 비교 방법 (우리가 정의)<br>• qsort는 <strong>어떤 타입이든, 어떤 비교든</strong> 가능!<div class='trace'>qsort가 내부에서:<br>cmpAsc(5,2): 5-2=3>0 → 5가 뒤<br>cmpAsc(2,1): 2-1=1>0 → 2가 뒤<br>... (정렬 완료: 1,2,5,8)</div><div class='explain'>💡 <strong>콜백 패턴</strong>: '무엇을 할지'는 사용자가, '어떻게 실행할지'는 라이브러리가! 내림차순? cmpAsc에서 b-a로 바꾸면 끝. qsort는 수정 불필요!</div>" },
            { n: 5, t: "스택 ADT (추상 데이터 타입)", d: 2, q: "스택의 <strong>인터페이스</strong>만 보고 결과를 예측하세요.<div class='code-block'><span class='cm'>// 스택 인터페이스 (내부 구현 몰라도 됨!)</span><br><span class='fn'>push</span>(&s, <span class='num'>10</span>);<br><span class='fn'>push</span>(&s, <span class='num'>20</span>);<br><span class='fn'>push</span>(&s, <span class='num'>30</span>);<br><span class='fn'>printf</span>(<span class='str'>\"%d \"</span>, <span class='fn'>pop</span>(&s));<br><span class='fn'>printf</span>(<span class='str'>\"%d \"</span>, <span class='fn'>pop</span>(&s));<br><span class='fn'>push</span>(&s, <span class='num'>40</span>);<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>, <span class='fn'>pop</span>(&s));</div>", a: "<span class='key'>출력</span> <code>30 20 40</code><br><span class='step'>추상화 관점</span><br>• push(값): 넣기, pop(): 꺼내기 — 이것만 알면 됨!<br>• LIFO(후입선출): 마지막에 넣은 것이 먼저 나옴<div class='trace'>push 10 → [10]<br>push 20 → [10,20]<br>push 30 → [10,20,30]<br>pop → <span class='val'>30</span>, [10,20]<br>pop → <span class='val'>20</span>, [10]<br>push 40 → [10,40]<br>pop → <span class='val'>40</span>, [10]</div><div class='explain'>💡 <strong>ADT(추상 데이터 타입)</strong>: 구현을 몰라도 '규칙'만 알면 사용 가능! 스택은 배열/연결리스트 등으로 구현할 수 있지만, 사용자는 push/pop만 알면 됩니다.</div>" },
            { n: 6, t: "큐 ADT", d: 2, q: "큐의 인터페이스로 결과 예측. 스택과 비교하세요.<div class='code-block'><span class='fn'>enqueue</span>(&q, <span class='num'>10</span>);<br><span class='fn'>enqueue</span>(&q, <span class='num'>20</span>);<br><span class='fn'>enqueue</span>(&q, <span class='num'>30</span>);<br><span class='fn'>printf</span>(<span class='str'>\"%d \"</span>, <span class='fn'>dequeue</span>(&q));<br><span class='fn'>printf</span>(<span class='str'>\"%d \"</span>, <span class='fn'>dequeue</span>(&q));<br><span class='fn'>enqueue</span>(&q, <span class='num'>40</span>);<br><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>, <span class='fn'>dequeue</span>(&q));</div>", a: "<span class='key'>출력</span> <code>10 20 30</code><br><span class='step'>스택 vs 큐</span><div class='trace'>큐(FIFO): 은행 줄서기 → 먼저 온 사람 먼저!<br>enqueue 10 → [10]<br>enqueue 20 → [10,20]<br>enqueue 30 → [10,20,30]<br>dequeue → <span class='val'>10</span>(먼저 넣은 것!), [20,30]<br>dequeue → <span class='val'>20</span>, [30]<br>enqueue 40 → [30,40]<br>dequeue → <span class='val'>30</span>, [40]</div><div class='explain'>💡 같은 데이터(10,20,30)를 넣었지만 스택은 30-20-10, 큐는 10-20-30 순으로 나와요. <strong>추상화(규칙)가 다르면 결과가 다릅니다</strong>!</div>" },
            { n: 7, t: "구조체 + 함수 = 모듈", d: 2, q: "은행 계좌를 구조체+함수로 <strong>모듈화</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='kw'>typedef struct</span>{<span class='type'>int</span> balance;} <span class='fn'>Account</span>;<br><span class='ln'>2</span><span class='type'>void</span> <span class='fn'>deposit</span>(<span class='fn'>Account</span>*a,<span class='type'>int</span> amt){a->balance+=amt;}<br><span class='ln'>3</span><span class='type'>int</span> <span class='fn'>withdraw</span>(<span class='fn'>Account</span>*a,<span class='type'>int</span> amt){<br><span class='ln'>4</span>    <span class='kw'>if</span>(a->balance>=amt){a->balance-=amt;<span class='kw'>return</span> <span class='num'>1</span>;}<br><span class='ln'>5</span>    <span class='kw'>return</span> <span class='num'>0</span>;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>Account</span> acc={<span class='num'>1000</span>};<br><span class='ln'>8</span><span class='fn'>deposit</span>(&acc,<span class='num'>500</span>);<br><span class='ln'>9</span><span class='fn'>withdraw</span>(&acc,<span class='num'>200</span>);<br><span class='ln'>10</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,acc.balance);</div>", a: "<span class='key'>출력</span> <code>1300</code><br><span class='step'>추적</span><div class='trace'>acc.balance = 1000<br>deposit(500): balance = 1000+500 = <span class='val'>1500</span><br>withdraw(200): 1500>=200 ✓ → balance = 1500-200 = <span class='val'>1300</span></div><span class='step'>추상화 효과</span><br>• 사용자: deposit/withdraw만 호출<br>• 잔액 부족 시 자동 거부 (안전장치)<br>• balance를 직접 수정하지 않음 (캡슐화)<br><div class='explain'>💡 <strong>구조체+함수 = 모듈(module)</strong>! 데이터(balance)와 동작(deposit/withdraw)을 묶으면 객체지향의 기초가 돼요. C에서의 캡슐화!</div>" },
            { n: 8, t: "void* 제네릭 추상화", d: 3, q: "<code>void*</code>로 어떤 타입이든 받는 <strong>제네릭 함수</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>void</span> <span class='fn'>printVal</span>(<span class='type'>void</span>*ptr, <span class='type'>char</span> type){<br><span class='ln'>2</span>    <span class='kw'>if</span>(type==<span class='str'>'i'</span>) <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,*(<span class='type'>int</span>*)ptr);<br><span class='ln'>3</span>    <span class='kw'>else if</span>(type==<span class='str'>'f'</span>) <span class='fn'>printf</span>(<span class='str'>\"%.1f \"</span>,*(<span class='type'>float</span>*)ptr);<br><span class='ln'>4</span>    <span class='kw'>else if</span>(type==<span class='str'>'c'</span>) <span class='fn'>printf</span>(<span class='str'>\"%c \"</span>,*(<span class='type'>char</span>*)ptr);<br><span class='ln'>5</span>}<br><span class='ln'>6</span><span class='type'>int</span> n=<span class='num'>42</span>; <span class='type'>float</span> f=<span class='num'>3.14</span>; <span class='type'>char</span> c=<span class='str'>'A'</span>;<br><span class='ln'>7</span><span class='fn'>printVal</span>(&n,<span class='str'>'i'</span>); <span class='fn'>printVal</span>(&f,<span class='str'>'f'</span>); <span class='fn'>printVal</span>(&c,<span class='str'>'c'</span>);</div>", a: "<span class='key'>출력</span> <code>42 3.1 A</code><br><span class='step'>void* 추상화</span><br>• <code>void*</code>: '아무 타입이든 가리킬 수 있는' 포인터<br>• 사용 시 타입 정보를 따로 전달(type 매개변수)<br>• 하나의 함수로 int/float/char 모두 처리!<br><div class='explain'>💡 <strong>void* = C의 제네릭</strong>! 타입을 '추상화'해서 하나의 함수로 여러 타입을 처리. qsort가 어떤 타입이든 정렬할 수 있는 이유가 바로 이것!</div>" },
            { n: 9, t: "불투명 포인터(Opaque)", d: 3, q: "사용자에게 <strong>내부를 숨기는</strong> 불투명 포인터 패턴.<div class='code-block'><span class='cm'>// stack.h (사용자가 보는 것)</span><br><span class='kw'>typedef struct</span> <span class='fn'>Stack</span> <span class='fn'>Stack</span>; <span class='cm'>// 내부 구현 숨김!</span><br><span class='fn'>Stack</span>* <span class='fn'>stack_create</span>(<span class='type'>void</span>);<br><span class='type'>void</span> <span class='fn'>stack_push</span>(<span class='fn'>Stack</span>*s, <span class='type'>int</span> val);<br><span class='type'>int</span> <span class='fn'>stack_pop</span>(<span class='fn'>Stack</span>*s);<br><span class='type'>void</span> <span class='fn'>stack_destroy</span>(<span class='fn'>Stack</span>*s);<br><br><span class='cm'>// 사용자는 Stack 내부를 알 수 없음!</span></div>", a: "<span class='key'>핵심</span> 사용자는 Stack이 배열인지 연결리스트인지 <strong>모름</strong>!<br><span class='step'>불투명 포인터 원리</span><div class='trace'>헤더(.h): Stack의 '선언'만 (struct Stack;)<br>소스(.c): Stack의 '정의' (struct Stack { int data[100]; int top; };)<br><br>사용자: 포인터로만 접근, 내부 필드 접근 불가<br>→ s->data 불가! stack_push/pop으로만 조작</div><div class='explain'>💡 <strong>불투명 포인터(Opaque Pointer)</strong>: 가장 강력한 C 추상화! 내부 구현을 완전히 숨기고 함수 인터페이스로만 소통. 나중에 내부를 배열→연결리스트로 바꿔도 사용자 코드 변경 불필요!</div>" },
            { n: 10, t: "비교 함수 추상화", d: 2, q: "비교 함수를 바꿔 정렬 기준을 <strong>추상화</strong>.<div class='code-block'><span class='kw'>struct</span> <span class='fn'>Student</span>{<span class='type'>char</span> name[<span class='num'>10</span>]; <span class='type'>int</span> score;};<br><br><span class='cm'>// 점수 기준 비교</span><br><span class='type'>int</span> <span class='fn'>byScore</span>(<span class='type'>const void</span>*a,<span class='type'>const void</span>*b){<br>    <span class='kw'>return</span> ((<span class='kw'>struct</span> <span class='fn'>Student</span>*)b)->score - ((<span class='kw'>struct</span> <span class='fn'>Student</span>*)a)->score;<br>}<br><span class='cm'>// 이름 기준 비교</span><br><span class='type'>int</span> <span class='fn'>byName</span>(<span class='type'>const void</span>*a,<span class='type'>const void</span>*b){<br>    <span class='kw'>return</span> <span class='fn'>strcmp</span>(((<span class='kw'>struct</span> <span class='fn'>Student</span>*)a)->name, ((<span class='kw'>struct</span> <span class='fn'>Student</span>*)b)->name);<br>}</div>", a: "<span class='key'>추상화 포인트</span><br>• qsort(students, n, sizeof(Student), <strong>byScore</strong>) → 점수 내림차순<br>• qsort(students, n, sizeof(Student), <strong>byName</strong>) → 이름 오름차순<br>• <strong>정렬 알고리즘은 동일</strong>, 비교 기준만 교체!<div class='explain'>💡 비교 함수를 바꾸는 것만으로 정렬 기준이 완전히 달라져요. 정렬 로직(qsort)은 추상화되어 있고, 우리는 '어떤 기준으로?'만 정의. 이것이 <strong>전략 패턴(Strategy Pattern)</strong>!</div>" },
            { n: 11, t: "에러 처리 추상화", d: 2, q: "에러 메시지를 <strong>일관되게 처리</strong>하는 추상화. 빈칸을 채우세요.<div class='code-block'><span class='ln'>1</span><span class='kw'>typedef enum</span> {<br><span class='ln'>2</span>    OK, ERR_NULL, ERR_RANGE, ERR_MEMORY<br><span class='ln'>3</span>} <span class='fn'>Error</span>;<br><span class='ln'>4</span><br><span class='ln'>5</span><span class='type'>const char</span>* <span class='fn'>errorMsg</span>(<span class='fn'>Error</span> e){<br><span class='ln'>6</span>    <span class='type'>const char</span>* msgs[]={<br><span class='ln'>7</span>        <span class='str'>\"성공\"</span>,<span class='str'>\"NULL 포인터\"</span>,<span class='str'>\"범위 초과\"</span>,<span class='str'>\"메모리 부족\"</span><br><span class='ln'>8</span>    };<br><span class='ln'>9</span>    <span class='kw'>return</span> msgs[e];<br><span class='ln'>10</span>}<br><span class='ln'>11</span><span class='fn'>printf</span>(<span class='str'>\"%s\"</span>, <span class='fn'>errorMsg</span>(ERR_RANGE));</div>", a: "<span class='key'>출력</span> <code>범위 초과</code><br><span class='step'>추상화 효과</span><br>• enum: 에러 코드에 이름 부여<br>• errorMsg: 코드→메시지 변환 추상화<br>• 새 에러 추가 시: enum에 추가 + msgs 배열에 추가<div class='trace'>ERR_RANGE = 2 → msgs[2] = <span class='val'>\"범위 초과\"</span></div><div class='explain'>💡 에러 처리를 한 곳에 모아 추상화하면 코드 전체에서 <strong>일관된 에러 메시지</strong>를 보여줄 수 있어요!</div>" },
            { n: 12, t: "typedef 함수 포인터", d: 3, q: "함수 포인터 타입을 <strong>typedef로 추상화</strong>. 출력은?<div class='code-block'><span class='ln'>1</span><span class='kw'>typedef</span> <span class='type'>int</span> (*<span class='fn'>BinOp</span>)(<span class='type'>int</span>,<span class='type'>int</span>);<br><span class='ln'>2</span><br><span class='ln'>3</span><span class='type'>int</span> <span class='fn'>add</span>(<span class='type'>int</span> a,<span class='type'>int</span> b){<span class='kw'>return</span> a+b;}<br><span class='ln'>4</span><span class='type'>int</span> <span class='fn'>sub</span>(<span class='type'>int</span> a,<span class='type'>int</span> b){<span class='kw'>return</span> a-b;}<br><span class='ln'>5</span><br><span class='ln'>6</span><span class='fn'>BinOp</span> ops[]={add, sub};<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d %d\"</span>, ops[<span class='num'>0</span>](<span class='num'>10</span>,<span class='num'>3</span>), ops[<span class='num'>1</span>](<span class='num'>10</span>,<span class='num'>3</span>));</div>", a: "<span class='key'>출력</span> <code>13 7</code><br><span class='step'>추상화 분석</span><div class='trace'>BinOp = 'int 2개를 받아 int를 반환하는 함수'<br><br>typedef 전: int (*ops[])(int,int) = {add,sub}; ← 복잡!<br>typedef 후: BinOp ops[] = {add, sub}; ← 깔끔!<br><br>ops[0](10,3) = add(10,3) = <span class='val'>13</span><br>ops[1](10,3) = sub(10,3) = <span class='val'>7</span></div><div class='explain'>💡 <strong>typedef로 함수 포인터를 추상화</strong>하면 읽기 쉬워져요! <code>BinOp</code>이라는 이름으로 '이항 연산'이라는 개념을 표현. 배열에 담으면 '연산 테이블' 완성!</div>" },
            { n: 13, t: "매크로 조건부 컴파일", d: 2, q: "<strong>#ifdef</strong>로 디버그 모드를 추상화.<div class='code-block'><span class='ln'>1</span><span class='pp'>#define</span> <span class='fn'>DEBUG</span><br><span class='ln'>2</span><br><span class='ln'>3</span><span class='pp'>#ifdef</span> <span class='fn'>DEBUG</span><br><span class='ln'>4</span><span class='pp'>#define</span> <span class='fn'>LOG</span>(msg) <span class='fn'>printf</span>(<span class='str'>\"[DEBUG] %s\\n\"</span>, msg)<br><span class='ln'>5</span><span class='pp'>#else</span><br><span class='ln'>6</span><span class='pp'>#define</span> <span class='fn'>LOG</span>(msg)<br><span class='ln'>7</span><span class='pp'>#endif</span><br><span class='ln'>8</span><br><span class='ln'>9</span><span class='fn'>LOG</span>(<span class='str'>\"프로그램 시작\"</span>);<br><span class='ln'>10</span><span class='fn'>LOG</span>(<span class='str'>\"처리 완료\"</span>);</div>", a: "<span class='key'>DEBUG 정의 시 출력</span><div class='trace'>[DEBUG] 프로그램 시작<br>[DEBUG] 처리 완료</div><span class='key'>DEBUG 미정의 시</span> (아무것도 안 나옴)<br><span class='step'>추상화 효과</span><br>• LOG(msg)만 쓰면 됨, DEBUG 여부는 자동 처리<br>• 배포 시 #define DEBUG만 삭제하면 모든 로그 제거<br><div class='explain'>💡 <strong>조건부 컴파일</strong>: 빌드 시점에 코드를 포함/제외! 디버그용 코드를 배포판에서 완전히 제거하면서도 개발 중에는 유용하게 사용할 수 있어요.</div>" },
            { n: 14, t: "문자열 ADT", d: 2, q: "문자열 조작 함수를 <strong>추상화</strong>. 출력은?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>myStrLen</span>(<span class='type'>const char</span>*s){<span class='type'>int</span> n=<span class='num'>0</span>;<span class='kw'>while</span>(s[n])n++;<span class='kw'>return</span> n;}<br><span class='ln'>2</span><span class='type'>void</span> <span class='fn'>myStrCpy</span>(<span class='type'>char</span>*d,<span class='type'>const char</span>*s){<span class='kw'>while</span>((*d++=*s++));}<br><span class='ln'>3</span><span class='type'>int</span> <span class='fn'>myStrCmp</span>(<span class='type'>const char</span>*a,<span class='type'>const char</span>*b){<br><span class='ln'>4</span>    <span class='kw'>while</span>(*a && *a==*b){a++;b++;}<br><span class='ln'>5</span>    <span class='kw'>return</span> *a-*b;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d %d\"</span>,<span class='fn'>myStrLen</span>(<span class='str'>\"ABC\"</span>),<span class='fn'>myStrCmp</span>(<span class='str'>\"ABC\"</span>,<span class='str'>\"ABD\"</span>));</div>", a: "<span class='key'>출력</span> <code>3 -1</code><br><span class='step'>추적</span><div class='trace'>myStrLen(\"ABC\"): A→B→C→\\0, len=<span class='val'>3</span><br><br>myStrCmp(\"ABC\",\"ABD\"):<br>'A'=='A' → next<br>'B'=='B' → next<br>'C'!='D' → return 'C'-'D'=67-68=<span class='val'>-1</span></div><div class='explain'>💡 strlen, strcpy, strcmp의 <strong>내부 구현</strong>을 이해하면서도, 평소에는 이름만으로 사용하는 것이 추상화! 구현을 알면 언제 비효율적인지도 알 수 있어요.</div>" },
            { n: 15, t: "2D 좌표 추상화", d: 2, q: "2차원 좌표를 struct로 추상화. 거리 계산 결과는?<div class='code-block'><span class='ln'>1</span><span class='pp'>#include</span> &lt;math.h&gt;<br><span class='ln'>2</span><span class='kw'>typedef struct</span>{<span class='type'>double</span> x,y;} <span class='fn'>Point</span>;<br><span class='ln'>3</span><br><span class='ln'>4</span><span class='type'>double</span> <span class='fn'>distance</span>(<span class='fn'>Point</span> a, <span class='fn'>Point</span> b){<br><span class='ln'>5</span>    <span class='kw'>return</span> <span class='fn'>sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>Point</span> p1={<span class='num'>0</span>,<span class='num'>0</span>}, p2={<span class='num'>3</span>,<span class='num'>4</span>};<br><span class='ln'>8</span><span class='fn'>printf</span>(<span class='str'>\"%.1f\"</span>, <span class='fn'>distance</span>(p1,p2));</div>", a: "<span class='key'>출력</span> <code>5.0</code><br><span class='step'>추적</span><div class='trace'>dx = 3-0 = 3<br>dy = 4-0 = 4<br>distance = √(9+16) = √25 = <span class='val'>5.0</span></div><span class='step'>추상화 효과</span><br>• Point: x,y를 하나의 '점'으로 추상화<br>• distance(a,b): 계산 공식을 이름으로 추상화<br><div class='explain'>💡 <code>distance(p1,p2)</code>만 쓰면 유클리드 거리를 구해요. 내부의 sqrt, 제곱 등은 숨겨져 있어요!</div>" },
            { n: 16, t: "상수 배열 추상화 (요일)", d: 2, q: "숫자를 <strong>이름으로 변환</strong>하는 추상화. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>const char</span>* <span class='fn'>dayName</span>(<span class='type'>int</span> d){<br><span class='ln'>2</span>    <span class='type'>const char</span>* names[]={<br><span class='ln'>3</span>        <span class='str'>\"일\"</span>,<span class='str'>\"월\"</span>,<span class='str'>\"화\"</span>,<span class='str'>\"수\"</span>,<span class='str'>\"목\"</span>,<span class='str'>\"금\"</span>,<span class='str'>\"토\"</span><br><span class='ln'>4</span>    };<br><span class='ln'>5</span>    <span class='kw'>return</span> (d>=<span class='num'>0</span>&&d&lt;<span class='num'>7</span>) ? names[d] : <span class='str'>\"??\"</span>;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%s요일\"</span>, <span class='fn'>dayName</span>(<span class='num'>3</span>));</div>", a: "<span class='key'>출력</span> <code>수요일</code><br><span class='step'>추상화</span> 숫자 3 → 문자열 \"수\"<div class='trace'>d=3, 범위 확인(0<=3<7 ✓)<br>names[3] = <span class='val'>\"수\"</span></div><div class='explain'>💡 <strong>룩업 테이블 추상화</strong>: 배열을 사전처럼 사용! 번호→이름 변환, 월→영문 변환, 에러코드→메시지 등에 광범위 활용. if/else if 연쇄보다 깔끔!</div>" },
            { n: 17, t: "이터레이터 패턴", d: 3, q: "배열을 <strong>순회하는 방법</strong>을 추상화.  어떤 장점이 있나요?<div class='code-block'><span class='kw'>typedef struct</span>{<br>    <span class='type'>int</span>*data; <span class='type'>int</span> size; <span class='type'>int</span> pos;<br>} <span class='fn'>Iterator</span>;<br><br><span class='type'>void</span> <span class='fn'>iter_init</span>(<span class='fn'>Iterator</span>*it,<span class='type'>int</span>*a,<span class='type'>int</span> n){it->data=a;it->size=n;it->pos=<span class='num'>0</span>;}<br><span class='type'>int</span> <span class='fn'>iter_hasNext</span>(<span class='fn'>Iterator</span>*it){<span class='kw'>return</span> it->pos&lt;it->size;}<br><span class='type'>int</span> <span class='fn'>iter_next</span>(<span class='fn'>Iterator</span>*it){<span class='kw'>return</span> it->data[it->pos++];}<br><br><span class='cm'>// 사용</span><br><span class='fn'>Iterator</span> it; <span class='type'>int</span> arr[]={<span class='num'>10</span>,<span class='num'>20</span>,<span class='num'>30</span>};<br><span class='fn'>iter_init</span>(&it,arr,<span class='num'>3</span>);<br><span class='kw'>while</span>(<span class='fn'>iter_hasNext</span>(&it)) <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,<span class='fn'>iter_next</span>(&it));</div>", a: "<span class='key'>출력</span> <code>10 20 30</code><br><span class='step'>추상화 효과</span><br>• 사용자: init → hasNext/next 반복만!<br>• 내부 인덱스(pos)를 직접 관리할 필요 없음<br>• 배열 외에 연결리스트, 파일 등으로 교체 가능<div class='trace'>init: pos=0<br>hasNext: 0<3 ✓ → next: data[0]=10, pos=1<br>hasNext: 1<3 ✓ → next: data[1]=20, pos=2<br>hasNext: 2<3 ✓ → next: data[2]=30, pos=3<br>hasNext: 3<3 ✗ → 종료</div><div class='explain'>💡 <strong>이터레이터 패턴</strong>: 순회 방법을 추상화! 데이터 구조가 바뀌어도 while(hasNext) + next() 코드는 변하지 않아요.</div>" },
            { n: 18, t: "추상화 수준 선택", d: 2, q: "같은 문제를 <strong>다른 추상화 수준</strong>으로 해결. 어떤 것이 적절한가요?<div class='code-block'><span class='cm'>// 수준 1: 너무 낮음 (비트 연산)</span><br>result = (a & <span class='num'>1</span>) ? <span class='num'>0</span> : <span class='num'>1</span>;<br><br><span class='cm'>// 수준 2: 적당함</span><br>result = (a % <span class='num'>2</span> == <span class='num'>0</span>) ? <span class='num'>1</span> : <span class='num'>0</span>;<br><br><span class='cm'>// 수준 3: 높은 추상화</span><br>result = <span class='fn'>isEven</span>(a);</div>", a: "<span class='key'>정답</span> 상황에 따라 다름!<br><span class='step'>분석</span><div class='trace'>수준 1: a&1 → 최하위 비트 체크 (가장 빠르지만 이해 어려움)<br>수준 2: a%2==0 → 나머지 연산 (대부분의 상황에 적절)<br>수준 3: isEven(a) → 가장 읽기 쉬움 (함수 호출 오버헤드)</div><div class='explain'>💡 <strong>추상화 수준은 트레이드오프</strong>! 높은 추상화=읽기 쉬움+성능↓, 낮은 추상화=읽기 어려움+성능↑. 보통은 수준 2~3이 적절. 성능이 중요하면 수준 1을 사용하되 주석 필수!</div>" },
            { n: 19, t: "인터페이스 통일", d: 2, q: "다른 도형이지만 <strong>같은 인터페이스</strong>로 사용. 빈칸을 채우세요.<div class='code-block'><span class='kw'>typedef struct</span>{<span class='type'>double</span> r;} <span class='fn'>Circle</span>;<br><span class='kw'>typedef struct</span>{<span class='type'>double</span> w,h;} <span class='fn'>Rect</span>;<br><br><span class='type'>double</span> <span class='fn'>circleArea</span>(<span class='fn'>Circle</span> c){<span class='kw'>return</span> <span class='num'>3.14</span>*c.r*c.r;}<br><span class='type'>double</span> <span class='fn'>rectArea</span>(<span class='fn'>Rect</span> r){<span class='kw'>return</span> r.w*r.h;}<br><br><span class='cm'>// 통일된 인터페이스</span><br><span class='kw'>typedef</span> <span class='type'>double</span>(*<span class='fn'>AreaFn</span>)(<span class='type'>void</span>*);<br><span class='fn'>Circle</span> c={<span class='num'>5</span>}; <span class='fn'>Rect</span> r={<span class='num'>3</span>,<span class='num'>4</span>};</div>", a: "<span class='key'>핵심</span><br>• Circle과 Rect는 구조가 다르지만<br>• area 함수라는 <strong>동일한 개념(인터페이스)</strong>으로 사용 가능<br><span class='step'>결과</span><div class='trace'>circleArea({r=5}) = 3.14×25 = <span class='val'>78.5</span><br>rectArea({w=3,h=4}) = 3×4 = <span class='val'>12.0</span></div><div class='explain'>💡 <strong>인터페이스 추상화</strong>: 다른 구현이지만 같은 '계약'! '넓이를 구한다'는 공통 인터페이스로 원/사각형/삼각형 등 어떤 도형이든 다룰 수 있어요. 이것이 객체지향 프로그래밍의 기초!</div>" },
            { n: 20, t: "🏆 추상화 설계 원칙", d: 3, q: "좋은 추상화를 만드는 <strong>5가지 원칙</strong>을 설명하세요.", a: "<span class='key'>추상화 5대 원칙</span><div class='trace'>① 단일 책임: 함수/struct는 하나의 일만!<br>② 정보 은닉: 내부 구현을 외부에 숨기기<br>③ 일관된 인터페이스: 비슷한 것은 비슷하게 사용<br>④ 적절한 수준: 너무 높지도 낮지도 않게<br>⑤ 이름이 곧 설명: 코드 자체가 문서</div><span class='step'>실천 체크리스트</span><div class='trace'>✅ 함수명만 보고 기능을 알 수 있는가?<br>✅ 매개변수명이 역할을 설명하는가?<br>✅ 사용자가 내부 구현을 몰라도 되는가?<br>✅ 변경 시 한 곳만 수정하면 되는가?<br>✅ 다른 프로그램에서도 재사용 가능한가?</div><div class='explain'>💡 이 5가지를 지키면 '10년 후 다른 사람이 읽어도 이해할 수 있는 코드'가 됩니다. 추상화는 코드의 <strong>품격</strong>을 결정하는 핵심 역량이에요!</div>" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => { const dc = p.d <= 1 ? 'ez' : p.d <= 2 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 코드 또는 답을 작성하세요"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>