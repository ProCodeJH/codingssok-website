<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>💻 패턴인식 → C언어 (어려움) — 알고리즘 패턴과 고급 기법</title>
    <link rel="stylesheet" href="ct_c.css">
</head>

<body>
    <div class="wrap">
        <div class="hdr">
            <h1>💻 패턴인식(Pattern Recognition) → C언어</h1>
            <div class="sub">어려움 · 알고리즘 패턴과 고급 기법</div>
            <div class="level-bar"><span class="on"></span><span class="on"></span><span class="on"></span></div>
            <div class="meta"><span class="tag pri"
                    style="background:rgba(16,185,129,.1);border-color:rgba(16,185,129,.3);color:#10b981">🔍
                    패턴인식</span><span class="tag" style="color:var(--err);border-color:rgba(248,113,113,.3)">🔴
                    어려움</span><span class="tag acc">📝 20문제</span><span class="tag">⏱ 60~90분</span></div>
        </div>
        <div class="stu-bar">
            <label>👤 이름 <input type="text" id="stu-name" placeholder="이름"></label>
            <label>📅 날짜 <input type="date" id="stu-date"></label>
        </div>
        <div class="learn">
            <h2><span class="ico" style="background:rgba(248,113,113,.15)">🔍</span> 어려움 난이도 안내</h2>
            <p>해시 테이블, 분할 정복, 동적 프로그래밍 등 <strong>고급 알고리즘 패턴</strong>을 발견합니다. 패턴을 이해하면 어떤 문제든 풀 수 있어요!</p>
            <div class="tip">💡 모든 알고리즘은 결국 몇 가지 기본 패턴의 조합입니다.</div>
        </div>
        <div id="problems"></div>
        <div class="submit-section">
            <p>모든 문제를 풀었나요? 📨</p>
            <button class="btn-submit" id="btn-submit">📄 제출하기</button>
        </div>
        <div class="modal-overlay" id="submit-modal">
            <div class="modal-box">
                <div class="modal-icon">✅</div>
                <h3>제출 완료!</h3>
                <p>학습지가 저장되었습니다.</p>
                <div style="margin:12px 0"><span class="info-tag" id="modal-name"></span> <span class="info-tag"
                        id="modal-date"></span> <span class="info-tag" id="modal-count"></span></div>
                <p style="font-size:.78rem;color:var(--dim)">📁 <strong id="modal-filename"></strong></p>
                <button class="btn-close-modal" id="btn-close-modal">확인</button>
            </div>
        </div>
        <div class="pg">
            <a href="패턴인식_C언어_쉬움.html">← 쉬움</a>
            <a href="패턴인식_C언어_보통.html">보통</a>
            <span class="tag active">어려움</span>
        </div>
        <div class="ft">💻 CT → C언어 · 패턴인식(Pattern Recognition) · 어려움 20문제</div>
    </div>
    <script>
        const P = [
            { n: 1, t: "해시 테이블 패턴", d: 3, q: "배열에서 <strong>두 수의 합</strong>이 target인 쌍 찾기. 해시 패턴으로 O(n)!<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> hash[<span class='num'>1000</span>]={<span class='num'>0</span>};<br><span class='ln'>2</span><span class='type'>int</span> a[]={<span class='num'>2</span>,<span class='num'>7</span>,<span class='num'>11</span>,<span class='num'>15</span>}, target=<span class='num'>9</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>4</span>;i++){<br><span class='ln'>4</span>    <span class='type'>int</span> need = target - a[i];<br><span class='ln'>5</span>    <span class='kw'>if</span>(need>=<span class='num'>0</span> && hash[need])<br><span class='ln'>6</span>        <span class='fn'>printf</span>(<span class='str'>\"%d+%d=%d\\n\"</span>,need,a[i],target);<br><span class='ln'>7</span>    hash[a[i]] = <span class='num'>1</span>;<br><span class='ln'>8</span>}</div>", a: "<span class='key'>출력</span> <code>2+7=9</code><br><span class='step'>추적</span><div class='trace'>i=0: a[0]=2, need=9-2=7, hash[7]=0 → skip, hash[2]=1<br>i=1: a[1]=7, need=9-7=2, hash[2]=<span class='val'>1</span>! → 출력 \"2+7=9\"<br>hash[7]=1<br>i=2,3: need가 hash에 없음 → skip</div><div class='explain'>💡 <strong>해시 룩업 패턴</strong>: 이미 본 값을 hash 배열에 기록! 새 값이 올 때 '필요한 값(target-현재값)'이 이미 있는지 O(1)로 확인. 이중 for문 O(n²) → 해시로 O(n)!</div>" },
            { n: 2, t: "분할 정복: 최댓값", d: 3, q: "배열을 <strong>반으로 나눠</strong> 최댓값을 찾는 재귀 패턴. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>maxDC</span>(<span class='type'>int</span> a[], <span class='type'>int</span> lo, <span class='type'>int</span> hi) {<br><span class='ln'>2</span>    <span class='kw'>if</span>(lo==hi) <span class='kw'>return</span> a[lo];<br><span class='ln'>3</span>    <span class='type'>int</span> mid=(lo+hi)/<span class='num'>2</span>;<br><span class='ln'>4</span>    <span class='type'>int</span> L=<span class='fn'>maxDC</span>(a,lo,mid);<br><span class='ln'>5</span>    <span class='type'>int</span> R=<span class='fn'>maxDC</span>(a,mid+<span class='num'>1</span>,hi);<br><span class='ln'>6</span>    <span class='kw'>return</span> L>R ? L : R;<br><span class='ln'>7</span>}<br><span class='ln'>8</span><span class='cm'>// a={3,8,1,5}, maxDC(a,0,3) → ?</span></div>", a: "<span class='key'>정답</span> <strong>8</strong><br><span class='step'>추적</span><div class='trace'>maxDC(0,3): mid=1<br>  L=maxDC(0,1): mid=0<br>    L=maxDC(0,0)=a[0]=<span class='val'>3</span><br>    R=maxDC(1,1)=a[1]=<span class='val'>8</span><br>    return max(3,8)=<span class='val'>8</span><br>  R=maxDC(2,3): mid=2<br>    L=maxDC(2,2)=a[2]=<span class='val'>1</span><br>    R=maxDC(3,3)=a[3]=<span class='val'>5</span><br>    return max(1,5)=<span class='val'>5</span><br>  return max(8,5)=<span class='val'>8</span></div><div class='explain'>💡 <strong>분할 정복 패턴</strong>: ①분할(반으로) ②정복(각각 해결) ③합치기(더 큰 것 선택). 이진 탐색, 병합 정렬, 퀵 정렬 모두 이 패턴!</div>" },
            { n: 3, t: "병합 정렬 패턴", d: 4, q: "병합(merge) 함수의 <strong>두 포인터 패턴</strong>을 추적하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>void</span> <span class='fn'>merge</span>(<span class='type'>int</span> L[], <span class='type'>int</span> lN, <span class='type'>int</span> R[], <span class='type'>int</span> rN, <span class='type'>int</span> out[]) {<br><span class='ln'>2</span>    <span class='type'>int</span> i=<span class='num'>0</span>,j=<span class='num'>0</span>,k=<span class='num'>0</span>;<br><span class='ln'>3</span>    <span class='kw'>while</span>(i&lt;lN && j&lt;rN)<br><span class='ln'>4</span>        out[k++]=(L[i]<=R[j])?L[i++]:R[j++];<br><span class='ln'>5</span>    <span class='kw'>while</span>(i&lt;lN) out[k++]=L[i++];<br><span class='ln'>6</span>    <span class='kw'>while</span>(j&lt;rN) out[k++]=R[j++];<br><span class='ln'>7</span>}<br><span class='ln'>8</span><span class='cm'>// L={1,4,7}, R={2,5,6} → out=?</span></div>", a: "<span class='key'>결과</span> out={1,2,4,5,6,7}<br><span class='step'>추적</span><div class='trace'>i=0,j=0: L[0]=1 <= R[0]=2 → out[0]=<span class='val'>1</span>, i=1<br>i=1,j=0: L[1]=4 > R[0]=2 → out[1]=<span class='val'>2</span>, j=1<br>i=1,j=1: L[1]=4 <= R[1]=5 → out[2]=<span class='val'>4</span>, i=2<br>i=2,j=1: L[2]=7 > R[1]=5 → out[3]=<span class='val'>5</span>, j=2<br>i=2,j=2: L[2]=7 > R[2]=6 → out[4]=<span class='val'>6</span>, j=3<br>j=3>=3 → 나머지: out[5]=<span class='val'>7</span></div><div class='explain'>💡 <strong>병합 패턴</strong>: 두 정렬된 배열을 하나로! 각 배열의 포인터를 비교하며 작은 것부터 넣어요. O(n)으로 합치기 가능!</div>" },
            { n: 4, t: "DP: 계단 오르기", d: 3, q: "n개 계단을 1칸 또는 2칸씩 오를 수 있을 때, <strong>경우의 수</strong>는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> dp[<span class='num'>10</span>];<br><span class='ln'>2</span>dp[<span class='num'>1</span>]=<span class='num'>1</span>; dp[<span class='num'>2</span>]=<span class='num'>2</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>3</span>;i<=<span class='num'>6</span>;i++)<br><span class='ln'>4</span>    dp[i]=dp[i-<span class='num'>1</span>]+dp[i-<span class='num'>2</span>];<br><span class='ln'>5</span><span class='cm'>// dp[5] → ?</span></div>", a: "<span class='key'>정답</span> dp[5] = <strong>8</strong><br><span class='step'>추적</span><div class='trace'>dp[1]=1, dp[2]=2<br>dp[3]=dp[2]+dp[1]=2+1=<span class='val'>3</span><br>dp[4]=dp[3]+dp[2]=3+2=<span class='val'>5</span><br>dp[5]=dp[4]+dp[3]=5+3=<span class='val'>8</span><br>dp[6]=dp[5]+dp[4]=8+5=<span class='val'>13</span></div>이것은... <strong>피보나치</strong>와 같은 패턴!<br><div class='explain'>💡 <strong>DP(동적 프로그래밍) 패턴</strong>: 큰 문제를 작은 문제의 답으로! dp[n]=dp[n-1]+dp[n-2]는 피보나치와 동일한 점화식. 계단 문제가 수열 문제와 같은 패턴이라는 발견!</div>" },
            { n: 5, t: "DP: 동전 교환", d: 4, q: "1원, 3원, 5원 동전으로 <strong>11원</strong>을 만드는 최소 동전 수는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> coins[]={<span class='num'>1</span>,<span class='num'>3</span>,<span class='num'>5</span>}, dp[<span class='num'>12</span>];<br><span class='ln'>2</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>12</span>;i++) dp[i]=<span class='num'>999</span>;<br><span class='ln'>3</span>dp[<span class='num'>0</span>]=<span class='num'>0</span>;<br><span class='ln'>4</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i<=<span class='num'>11</span>;i++)<br><span class='ln'>5</span>    <span class='kw'>for</span>(<span class='type'>int</span> j=<span class='num'>0</span>;j&lt;<span class='num'>3</span>;j++)<br><span class='ln'>6</span>        <span class='kw'>if</span>(coins[j]<=i && dp[i-coins[j]]+<span class='num'>1</span>&lt;dp[i])<br><span class='ln'>7</span>            dp[i]=dp[i-coins[j]]+<span class='num'>1</span>;<br><span class='ln'>8</span><span class='cm'>// dp[11] → ?</span></div>", a: "<span class='key'>정답</span> dp[11] = <strong>3</strong> (5+5+1 또는 5+3+3)<br><span class='step'>dp 테이블</span><div class='trace'>dp[0]=0<br>dp[1]=dp[0]+1=<span class='val'>1</span> (1원)<br>dp[2]=dp[1]+1=<span class='val'>2</span> (1+1)<br>dp[3]=dp[0]+1=<span class='val'>1</span> (3원!)<br>dp[4]=dp[3]+1=<span class='val'>2</span> (3+1)<br>dp[5]=dp[0]+1=<span class='val'>1</span> (5원!)<br>dp[6]=dp[3]+1=<span class='val'>2</span> (3+3)<br>...<br>dp[11]=dp[6]+1=<span class='val'>3</span> (5+3+3)</div><div class='explain'>💡 DP의 핵심 패턴: <code>dp[i] = min(dp[i-coin]+1)</code> 모든 동전에 대해! 현재 금액에서 각 동전을 빼면 이전 상태가 나오고, 거기에 +1하면 됩니다.</div>" },
            { n: 6, t: "비트마스크 패턴", d: 3, q: "비트마스크로 <strong>집합</strong>을 표현하는 패턴. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> set = <span class='num'>0</span>; <span class='cm'>// 공집합</span><br><span class='ln'>2</span>set |= (<span class='num'>1</span><<<span class='num'>0</span>); <span class='cm'>// {0} 추가</span><br><span class='ln'>3</span>set |= (<span class='num'>1</span><<<span class='num'>2</span>); <span class='cm'>// {0,2} 추가</span><br><span class='ln'>4</span>set |= (<span class='num'>1</span><<<span class='num'>4</span>); <span class='cm'>// {0,2,4} 추가</span><br><span class='ln'>5</span><span class='fn'>printf</span>(<span class='str'>\"%d\\n\"</span>, set); <span class='cm'>// 이진수로?</span><br><span class='ln'>6</span><span class='fn'>printf</span>(<span class='str'>\"%d\\n\"</span>, set & (<span class='num'>1</span><<<span class='num'>2</span>)); <span class='cm'>// 2 포함?</span><br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d\\n\"</span>, set & (<span class='num'>1</span><<<span class='num'>3</span>)); <span class='cm'>// 3 포함?</span></div>", a: "<span class='key'>출력</span><div class='trace'>21 (= 10101₂)<br>4 (≠0, 포함!)<br>0 (미포함)</div><span class='step'>추적</span><div class='trace'>set=00000 → |00001 → <span class='val'>00001</span> {0}<br>set=00001 → |00100 → <span class='val'>00101</span> {0,2}<br>set=00101 → |10000 → <span class='val'>10101</span> {0,2,4} = 21<br><br>10101 & 00100 = 00100 = <span class='val'>4</span> (≠0 → 2는 있음)<br>10101 & 01000 = 00000 = <span class='val'>0</span> (3은 없음)</div><div class='explain'>💡 <strong>비트마스크 패턴</strong>: 비트 하나 = 원소 하나! 추가(|=), 삭제(&=~), 포함검사(&), 토글(^=). 집합 연산을 O(1)로!</div>" },
            { n: 7, t: "재귀 패턴: 하노이 탑", d: 4, q: "하노이 탑 3개 원반의 <strong>이동 순서</strong>를 추적하세요.<div class='code-block'><span class='ln'>1</span><span class='type'>void</span> <span class='fn'>hanoi</span>(<span class='type'>int</span> n, <span class='type'>char</span> from, <span class='type'>char</span> to, <span class='type'>char</span> via){<br><span class='ln'>2</span>    <span class='kw'>if</span>(n==<span class='num'>0</span>) <span class='kw'>return</span>;<br><span class='ln'>3</span>    <span class='fn'>hanoi</span>(n-<span class='num'>1</span>,from,via,to);<br><span class='ln'>4</span>    <span class='fn'>printf</span>(<span class='str'>\"%d: %c→%c\\n\"</span>,n,from,to);<br><span class='ln'>5</span>    <span class='fn'>hanoi</span>(n-<span class='num'>1</span>,via,to,from);<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='cm'>// hanoi(3,'A','C','B') → ?</span></div>", a: "<span class='key'>출력</span><div class='trace'>1: A→C<br>2: A→B<br>1: C→B<br>3: A→C<br>1: B→A<br>2: B→C<br>1: A→C</div><span class='step'>패턴</span> 총 7번(2³-1) 이동!<br>재귀 패턴: n개 이동 = (n-1개 이동) + 1개 이동 + (n-1개 이동)<br><div class='explain'>💡 하노이 탑은 <strong>재귀의 교과서</strong>! 큰 문제(n개 옮기기)를 작은 문제(n-1개 옮기기)로 분해. 이동 횟수: 2ⁿ-1이라는 패턴도 있어요.</div>" },
            { n: 8, t: "그리디 패턴: 거스름돈", d: 3, q: "거스름돈을 최소 동전으로 주는 <strong>그리디 패턴</strong>. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> coins[]={<span class='num'>500</span>,<span class='num'>100</span>,<span class='num'>50</span>,<span class='num'>10</span>};<br><span class='ln'>2</span><span class='type'>int</span> change=<span class='num'>1260</span>, count=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>4</span>;i++){<br><span class='ln'>4</span>    count += change/coins[i];<br><span class='ln'>5</span>    change %= coins[i];<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,count);</div>", a: "<span class='key'>출력</span> <code>6</code><br><span class='step'>추적</span><div class='trace'>500원: 1260/500=<span class='val'>2</span>장, 나머지=260<br>100원: 260/100=<span class='val'>2</span>개, 나머지=60<br>50원: 60/50=<span class='val'>1</span>개, 나머지=10<br>10원: 10/10=<span class='val'>1</span>개, 나머지=0<br>총: 2+2+1+1 = <span class='val'>6</span>개</div><div class='explain'>💡 <strong>그리디 패턴</strong>: 매 순간 가장 좋은 선택(큰 동전부터)! 항상 최적해를 보장하진 않지만, 동전 문제처럼 단위가 배수 관계면 OK.</div>" },
            { n: 9, t: "카데인 알고리즘", d: 4, q: "연속 부분 배열의 <strong>최대 합</strong>을 O(n)으로 찾는 패턴. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={-<span class='num'>2</span>,<span class='num'>1</span>,-<span class='num'>3</span>,<span class='num'>4</span>,-<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>1</span>,-<span class='num'>5</span>,<span class='num'>4</span>};<br><span class='ln'>2</span><span class='type'>int</span> cur=a[<span class='num'>0</span>], best=a[<span class='num'>0</span>];<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>9</span>;i++){<br><span class='ln'>4</span>    cur = (cur+a[i] > a[i]) ? cur+a[i] : a[i];<br><span class='ln'>5</span>    <span class='kw'>if</span>(cur > best) best = cur;<br><span class='ln'>6</span>}<br><span class='ln'>7</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,best);</div>", a: "<span class='key'>출력</span> <code>6</code><br><span class='step'>추적</span><div class='trace'>i=0: cur=-2, best=-2<br>i=1: cur=max(-2+1,1)=<span class='val'>1</span>, best=1<br>i=2: cur=max(1-3,-3)=<span class='val'>-2</span><br>i=3: cur=max(-2+4,4)=<span class='val'>4</span>, best=4<br>i=4: cur=max(4-1,-1)=<span class='val'>3</span><br>i=5: cur=max(3+2,2)=<span class='val'>5</span>, best=5<br>i=6: cur=max(5+1,1)=<span class='val'>6</span>, best=<span class='val'>6</span><br>i=7: cur=max(6-5,-5)=<span class='val'>1</span><br>i=8: cur=max(1+4,4)=<span class='val'>5</span></div>최대 부분합: {4,-1,2,1} = <span class='val'>6</span><br><div class='explain'>💡 <strong>카데인 패턴</strong>: '지금까지의 합이 유리한가, 새로 시작하는 게 유리한가?' 매 단계 판단! 이 판단 패턴이 DP의 핵심이에요.</div>" },
            { n: 10, t: "투 포인터: 물통", d: 3, q: "<strong>가장 많은 물</strong>을 담을 수 있는 두 벽을 찾는 패턴. 최대 넓이는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> h[]={<span class='num'>1</span>,<span class='num'>8</span>,<span class='num'>6</span>,<span class='num'>2</span>,<span class='num'>5</span>,<span class='num'>4</span>,<span class='num'>8</span>,<span class='num'>3</span>,<span class='num'>7</span>};<br><span class='ln'>2</span><span class='type'>int</span> lo=<span class='num'>0</span>,hi=<span class='num'>8</span>,best=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>while</span>(lo&lt;hi){<br><span class='ln'>4</span>    <span class='type'>int</span> area=(hi-lo)*(h[lo]&lt;h[hi]?h[lo]:h[hi]);<br><span class='ln'>5</span>    <span class='kw'>if</span>(area>best) best=area;<br><span class='ln'>6</span>    <span class='kw'>if</span>(h[lo]&lt;h[hi]) lo++; <span class='kw'>else</span> hi--;<br><span class='ln'>7</span>}<br><span class='ln'>8</span><span class='fn'>printf</span>(<span class='str'>\"%d\"</span>,best);</div>", a: "<span class='key'>출력</span> <code>49</code><br><span class='step'>핵심 추적</span><div class='trace'>lo=0,hi=8: area=8×min(1,7)=8×1=8, h[0]<h[8] → lo++<br>lo=1,hi=8: area=7×min(8,7)=7×7=<span class='val'>49</span>, best=49<br>h[1]>h[8] → hi--<br>...(이후 49보다 큰 값 없음)</div><div class='explain'>💡 <strong>양 끝 포인터 패턴</strong>: 넓이=높이×너비. 짧은 벽 쪽 포인터를 이동시키면 높이가 나아질 가능성! 긴 쪽을 움직이면 너비만 줄고 높이 개선 불가. 이 논리적 판단이 그리디의 핵심.</div>" },
            { n: 11, t: "접두사 합 패턴", d: 3, q: "구간 합을 O(1)로 구하는 <strong>접두사 합</strong> 패턴. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>3</span>,<span class='num'>1</span>,<span class='num'>4</span>,<span class='num'>1</span>,<span class='num'>5</span>,<span class='num'>9</span>};<br><span class='ln'>2</span><span class='type'>int</span> pre[<span class='num'>7</span>]={<span class='num'>0</span>};<br><span class='ln'>3</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>6</span>;i++) pre[i+<span class='num'>1</span>]=pre[i]+a[i];<br><span class='ln'>4</span><span class='cm'>// a[2]~a[4]의 합 = pre[5]-pre[2] = ?</span></div>", a: "<span class='key'>정답</span> <strong>10</strong><br><span class='step'>접두사 합 테이블</span><div class='trace'>pre[0]=0<br>pre[1]=0+3=<span class='val'>3</span><br>pre[2]=3+1=<span class='val'>4</span><br>pre[3]=4+4=<span class='val'>8</span><br>pre[4]=8+1=<span class='val'>9</span><br>pre[5]=9+5=<span class='val'>14</span><br>pre[6]=14+9=<span class='val'>23</span><br><br>a[2]~a[4] = pre[5]-pre[2] = 14-4 = <span class='val'>10</span></div>검증: a[2]+a[3]+a[4] = 4+1+5 = 10 ✓<br><div class='explain'>💡 <strong>접두사 합 패턴</strong>: 한 번 전처리(O(n)) 후, 어떤 구간 합이든 O(1)으로! pre[R+1]-pre[L] = a[L]~a[R]의 합. 누적합 패턴의 고급 활용!</div>" },
            { n: 12, t: "KMP 부분 문자열 패턴", d: 4, q: "문자열에서 <strong>패턴 매칭</strong>의 실패 함수 패턴. fail 배열의 값은?<div class='code-block'><span class='ln'>1</span><span class='type'>char</span> p[]=<span class='str'>\"ABCABD\"</span>;<br><span class='ln'>2</span><span class='type'>int</span> fail[<span class='num'>6</span>]={<span class='num'>0</span>};<br><span class='ln'>3</span><span class='type'>int</span> j=<span class='num'>0</span>;<br><span class='ln'>4</span><span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>1</span>;i&lt;<span class='num'>6</span>;i++){<br><span class='ln'>5</span>    <span class='kw'>while</span>(j>0 && p[i]!=p[j]) j=fail[j-<span class='num'>1</span>];<br><span class='ln'>6</span>    <span class='kw'>if</span>(p[i]==p[j]) fail[i]=++j;<br><span class='ln'>7</span>}<br><span class='ln'>8</span><span class='cm'>// fail = ?</span></div>", a: "<span class='key'>정답</span> fail = {0, 0, 0, 1, 2, 0}<br><span class='step'>추적</span><div class='trace'>i=1(B): p[1]≠p[0] → fail[1]=<span class='val'>0</span><br>i=2(C): p[2]≠p[0] → fail[2]=<span class='val'>0</span><br>i=3(A): p[3]==p[0] → j=1, fail[3]=<span class='val'>1</span><br>i=4(B): p[4]==p[1] → j=2, fail[4]=<span class='val'>2</span><br>i=5(D): p[5]≠p[2], j=fail[1]=0, p[5]≠p[0] → fail[5]=<span class='val'>0</span></div><div class='explain'>💡 fail[i] = i까지의 접두사와 접미사가 일치하는 최대 길이! \"ABCAB\"에서 AB가 접두사이자 접미사 → fail[4]=2. 이 패턴으로 문자열 탐색을 O(n+m)으로!</div>" },
            { n: 13, t: "백트래킹 패턴", d: 4, q: "3개 원소의 <strong>모든 순열</strong>을 생성하는 패턴. 몇 가지?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> a[]={<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>}, used[<span class='num'>3</span>]={<span class='num'>0</span>}, perm[<span class='num'>3</span>];<br><span class='ln'>2</span><span class='type'>void</span> <span class='fn'>solve</span>(<span class='type'>int</span> depth){<br><span class='ln'>3</span>    <span class='kw'>if</span>(depth==<span class='num'>3</span>){printPerm(); <span class='kw'>return</span>;}<br><span class='ln'>4</span>    <span class='kw'>for</span>(<span class='type'>int</span> i=<span class='num'>0</span>;i&lt;<span class='num'>3</span>;i++){<br><span class='ln'>5</span>        <span class='kw'>if</span>(!used[i]){<br><span class='ln'>6</span>            used[i]=<span class='num'>1</span>; perm[depth]=a[i];<br><span class='ln'>7</span>            <span class='fn'>solve</span>(depth+<span class='num'>1</span>);<br><span class='ln'>8</span>            used[i]=<span class='num'>0</span>; <span class='cm'>// 백트래킹!</span><br><span class='ln'>9</span>        }<br><span class='ln'>10</span>   }<br><span class='ln'>11</span>}</div>", a: "<span class='key'>총 6가지</span> (3!=3×2×1)<div class='trace'>1 2 3<br>1 3 2<br>2 1 3<br>2 3 1<br>3 1 2<br>3 2 1</div><span class='step'>추적 (처음 2개)</span><div class='trace'>solve(0): i=0, used[0]=1, perm[0]=1<br>  solve(1): i=1, used[1]=1, perm[1]=2<br>    solve(2): i=2, used[2]=1, perm[2]=3<br>      solve(3): depth==3! → 출력 [1,2,3]<br>    used[2]=0 ← 백트래킹<br>  used[1]=0 ← 백트래킹<br>  solve(1): i=2, used[2]=1, perm[1]=3<br>    → [1,3,2]...</div><div class='explain'>💡 <strong>백트래킹 패턴</strong>: 선택→탐색→되돌리기! <code>used[i]=1</code>→<code>solve</code>→<code>used[i]=0</code>이 핵심 3단계. 모든 경우를 체계적으로 탐색하면서 불필요한 경로는 가지치기!</div>" },
            { n: 14, t: "이진 탐색 패턴 변형", d: 3, q: "target보다 크거나 같은 <strong>첫 위치</strong>를 찾는 lower_bound. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> <span class='fn'>lowerBound</span>(<span class='type'>int</span> a[],<span class='type'>int</span> n,<span class='type'>int</span> t){<br><span class='ln'>2</span>    <span class='type'>int</span> lo=<span class='num'>0</span>,hi=n;<br><span class='ln'>3</span>    <span class='kw'>while</span>(lo&lt;hi){<br><span class='ln'>4</span>        <span class='type'>int</span> mid=(lo+hi)/<span class='num'>2</span>;<br><span class='ln'>5</span>        <span class='kw'>if</span>(a[mid]&lt;t) lo=mid+<span class='num'>1</span>;<br><span class='ln'>6</span>        <span class='kw'>else</span> hi=mid;<br><span class='ln'>7</span>    }<br><span class='ln'>8</span>    <span class='kw'>return</span> lo;<br><span class='ln'>9</span>}<br><span class='ln'>10</span><span class='cm'>// a={1,3,3,5,7}, lowerBound(a,5,3) → ?</span></div>", a: "<span class='key'>정답</span> <strong>1</strong> (인덱스 1, 첫 번째 3의 위치)<br><span class='step'>추적</span><div class='trace'>lo=0, hi=5<br>mid=2: a[2]=3 >= 3 → hi=2<br>mid=1: a[1]=3 >= 3 → hi=1<br>lo=0, hi=1: mid=0: a[0]=1 < 3 → lo=1<br>lo==hi==1 → return <span class='val'>1</span></div><div class='explain'>💡 이진 탐색의 <strong>변형 패턴</strong>! 정확히 찾는 대신 '경계'를 찾아요. lo<hi 패턴(등호 없음)과 hi=mid(+1 없음)가 핵심 차이. 이 패턴으로 upper_bound, 삽입 위치 등 모든 경계 문제 해결!</div>" },
            { n: 15, t: "행렬 나선 순회 패턴", d: 4, q: "3×3 행렬을 <strong>나선형(spiral)</strong>으로 순회할 때의 출력 순서는?<div class='code-block'><span class='ln'>1</span><span class='type'>int</span> m[<span class='num'>3</span>][<span class='num'>3</span>]={{<span class='num'>1</span>,<span class='num'>2</span>,<span class='num'>3</span>},{<span class='num'>4</span>,<span class='num'>5</span>,<span class='num'>6</span>},{<span class='num'>7</span>,<span class='num'>8</span>,<span class='num'>9</span>}};<br><span class='cm'>// 순서: →↓←↑ 반복하며 안쪽으로</span><br><span class='cm'>// 방향 패턴: dx={0,1,0,-1}, dy={1,0,-1,0}</span></div>", a: "<span class='key'>출력 순서</span> <code>1 2 3 6 9 8 7 4 5</code><br><span class='step'>패턴 추적</span><div class='trace'>→ 방향: 1, 2, 3 (1행 전체)<br>↓ 방향: 6, 9 (마지막 열 아래로)<br>← 방향: 8, 7 (마지막 행 왼쪽으로)<br>↑ 방향: 4 (첫 열 위로)<br>→ 방향: 5 (중앙)</div><div class='explain'>💡 <strong>방향 배열 패턴</strong>: dx/dy 배열로 4방향을 표현! 경계에 닿으면 방향을 바꾸는 패턴. 이 패턴은 미로 탐색, 게임 이동 등에 광범위하게 사용돼요.</div>" },
            { n: 16, t: "그래프 BFS 패턴", d: 4, q: "큐를 사용한 <strong>너비 우선 탐색(BFS)</strong>의 방문 순서는?<div class='code-block'><span class='cm'>// 인접 리스트: 0-[1,2], 1-[3], 2-[3,4], 3-[], 4-[]</span><br><span class='cm'>// 큐에서 꺼내며 이웃 추가</span><br><span class='cm'>// 시작: 노드 0</span></div>", a: "<span class='key'>방문 순서</span> <code>0 → 1 → 2 → 3 → 4</code><br><span class='step'>BFS 추적</span><div class='trace'>큐: [0], 방문: {0}<br>꺼냄: 0, 이웃 1,2 추가 → 큐: [1,2]<br>꺼냄: 1, 이웃 3 추가 → 큐: [2,3]<br>꺼냄: 2, 이웃 3(방문됨),4 → 큐: [3,4]<br>꺼냄: 3, 이웃 없음 → 큐: [4]<br>꺼냄: 4, 이웃 없음 → 큐: []</div><div class='explain'>💡 <strong>BFS 패턴</strong>: 큐 사용 + 가까운 것부터! ①큐에서 꺼내기 ②이웃 탐색 ③미방문이면 큐에 추가. 최단 경로 문제의 기본 패턴이에요.</div>" },
            { n: 17, t: "그래프 DFS 패턴", d: 4, q: "스택/재귀를 사용한 <strong>깊이 우선 탐색(DFS)</strong>. BFS와 비교하세요.<div class='code-block'><span class='cm'>// 같은 그래프: 0-[1,2], 1-[3], 2-[3,4]</span><br><span class='ln'>1</span><span class='type'>void</span> <span class='fn'>dfs</span>(<span class='type'>int</span> node, <span class='type'>int</span> visited[]){<br><span class='ln'>2</span>    <span class='kw'>if</span>(visited[node]) <span class='kw'>return</span>;<br><span class='ln'>3</span>    visited[node]=<span class='num'>1</span>;<br><span class='ln'>4</span>    <span class='fn'>printf</span>(<span class='str'>\"%d \"</span>,node);<br><span class='ln'>5</span>    <span class='kw'>for</span>(이웃 탐색) <span class='fn'>dfs</span>(이웃, visited);<br><span class='ln'>6</span>}</div>", a: "<span class='key'>방문 순서</span> <code>0 → 1 → 3 → 2 → 4</code><br><span class='step'>DFS vs BFS 비교</span><div class='trace'>DFS: 0→1→3(깊이 먼저!)→2→4<br>BFS: 0→1→2(너비 먼저!)→3→4</div><span class='step'>패턴 비교</span><br>• BFS: <strong>큐</strong>(FIFO) → 가까운 것 먼저<br>• DFS: <strong>스택/재귀</strong>(LIFO) → 깊은 것 먼저<br><div class='explain'>💡 BFS와 DFS는 <strong>자료구조만 다른 같은 패턴</strong>! 큐→BFS, 스택→DFS. 이 한 가지 차이가 전혀 다른 탐색 순서를 만들어요.</div>" },
            { n: 18, t: "문자열 압축 패턴", d: 3, q: "연속 같은 문자를 <strong>압축</strong>하는 RLE 패턴. 결과는?<div class='code-block'><span class='ln'>1</span><span class='type'>char</span> s[]=<span class='str'>\"aaabbbccddddee\"</span>;<br><span class='ln'>2</span><span class='type'>int</span> i=<span class='num'>0</span>;<br><span class='ln'>3</span><span class='kw'>while</span>(s[i]){<br><span class='ln'>4</span>    <span class='type'>char</span> c=s[i]; <span class='type'>int</span> cnt=<span class='num'>0</span>;<br><span class='ln'>5</span>    <span class='kw'>while</span>(s[i]==c){i++;cnt++;}<br><span class='ln'>6</span>    <span class='fn'>printf</span>(<span class='str'>\"%c%d\"</span>,c,cnt);<br><span class='ln'>7</span>}</div>", a: "<span class='key'>출력</span> <code>a3b3c2d4e2</code><br><span class='step'>추적</span><div class='trace'>i=0: c='a', 연속 3개 → \"a3\", i=3<br>i=3: c='b', 연속 3개 → \"b3\", i=6<br>i=6: c='c', 연속 2개 → \"c2\", i=8<br>i=8: c='d', 연속 4개 → \"d4\", i=12<br>i=12: c='e', 연속 2개 → \"e2\", i=14</div><div class='explain'>💡 <strong>RLE(Run-Length Encoding)</strong>: 같은 문자의 연속을 '문자+개수'로 압축! 이중 while 패턴: 바깥=전체 순회, 안쪽=같은 문자 카운팅.</div>" },
            { n: 19, t: "자연수 분할 패턴", d: 4, q: "숫자 n을 <strong>합으로 분할</strong>하는 경우의 수 패턴. partition(5)의 결과는?<div class='code-block'><span class='cm'>// 5 = 5</span><br><span class='cm'>// 5 = 4+1</span><br><span class='cm'>// 5 = 3+2</span><br><span class='cm'>// 5 = 3+1+1</span><br><span class='cm'>// 5 = 2+2+1</span><br><span class='cm'>// 5 = 2+1+1+1</span><br><span class='cm'>// 5 = 1+1+1+1+1</span></div>", a: "<span class='key'>정답</span> <strong>7</strong>가지<br><span class='step'>패턴 분석</span><div class='trace'>가장 큰 수 기준으로 분류:<br>max=5: {5} → 1가지<br>max=4: {4+1} → 1가지<br>max=3: {3+2, 3+1+1} → 2가지<br>max=2: {2+2+1, 2+1+1+1} → 2가지<br>max=1: {1+1+1+1+1} → 1가지<br>총: <span class='val'>7</span>가지</div><div class='explain'>💡 분할 문제의 재귀 패턴: p(n,k) = p(n-k,k) + p(n,k-1). k를 사용하는 경우 + 사용하지 않는 경우! DP로 풀면 효율적이에요.</div>" },
            { n: 20, t: "🏆 알고리즘 패턴 족보", d: 5, q: "아래 10가지 알고리즘 패턴을 정리하고, 각 패턴이 <strong>언제</strong> 쓰이는지 설명하세요.<br>①완전탐색 ②이진탐색 ③투포인터 ④슬라이딩윈도우 ⑤그리디 ⑥DP ⑦분할정복 ⑧백트래킹 ⑨BFS ⑩DFS", a: "<span class='key'>알고리즘 패턴 족보</span><div class='trace'>① 완전탐색: 모든 경우를 다 해봄 (N≤20)<br>② 이진탐색: 정렬된 데이터에서 찾기 (O(logN))<br>③ 투포인터: 정렬 배열에서 쌍 찾기 (O(N))<br>④ 슬라이딩윈도우: 연속 구간 처리 (O(N))<br>⑤ 그리디: 매 순간 최선 선택 (최적해 보장 시)<br>⑥ DP: 작은 문제→큰 문제 (중복 부분문제)<br>⑦ 분할정복: 반으로 나눠 정복 (병합정렬 등)<br>⑧ 백트래킹: 선택→탐색→되돌리기 (순열/조합)<br>⑨ BFS: 큐, 최단거리 (가중치 없는 그래프)<br>⑩ DFS: 스택/재귀, 경로 탐색 (모든 경로 필요 시)</div><span class='step'>선택 기준</span><br>• 정렬된 배열? → ②③<br>• 연속 구간? → ④⑪(접두사합)<br>• 최적해? → ⑤(증명가능) or ⑥(일반적)<br>• 모든 경우? → ①⑧⑩<br>• 최단거리? → ⑨<br><div class='explain'>💡 모든 알고리즘은 이 10가지 패턴의 <strong>조합</strong>! 문제를 보고 어떤 패턴이 맞는지 판단하는 것이 진정한 패턴 인식이에요. 이것이 CT의 최종 목표입니다!</div>" }
        ];
        const c = document.getElementById('problems');
        P.forEach(p => { const dc = p.d <= 2 ? 'ez' : p.d <= 3 ? 'md' : 'hd'; const dots = Array.from({ length: 5 }, (_, i) => `<span${i < p.d ? ' class="on"' : ''}></span>`).join(''); c.innerHTML += `<div class="prob"><div class="prob-top"><div class="prob-num ${dc}">${p.n}</div><div class="prob-title">${p.t}</div><div class="diff-dots">${dots}</div></div><div class="prob-body"><div class="q">${p.q}</div><textarea class="write" placeholder="✍️ 코드 또는 답을 작성하세요"></textarea><details class="ans"><summary>정답 및 해설 보기</summary><div class="ans-body">${p.a}</div></details></div></div>`; });
    </script>
    <script src="submit.js"></script>
    <script src="../../platform.js"></script>
</body>

</html>